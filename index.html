<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-950">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#020617" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <title>CompNavAir</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Omnivore (KML import) -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- FontAwesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    .no-select { user-select: none; -webkit-user-select: none; }
    .safe-bottom { padding-bottom: calc(env(safe-area-inset-bottom) + 0px); }
    .safe-top { padding-top: env(safe-area-inset-top); }
    #map { height: 100%; width: 100%; }
    .leaflet-container { background: #0b1220; }
    .btn-touch { touch-action: manipulation; }
    .shadow-soft { box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .panel-scroll { max-height: calc(100vh - 7.5rem); overflow: auto; -webkit-overflow-scrolling: touch; }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    .balloon-icon { width: 28px; height: 28px; display: grid; place-items: center; }
    .balloon-rot { width: 28px; height: 28px; display: grid; place-items: center; transform-origin: 50% 50%; }
    .leaflet-control-container { z-index: 10; }
  </style>
</head>

<body class="h-full text-slate-100">
  <div id="app" class="h-full w-full flex flex-col bg-slate-950">
    <!-- Header -->
    <header class="safe-top z-40 bg-slate-950/90 backdrop-blur border-b border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-2xl bg-slate-900 border border-slate-800 grid place-items-center">
            <i class="fa-solid fa-balloon text-sky-300"></i>
          </div>
          <div class="min-w-0">
            <div class="font-extrabold leading-5 truncate">CompNavAir</div>
            <div class="text-xs text-slate-400 leading-4 truncate">
              <span id="gpsBadge" class="inline-flex items-center gap-1">
                <span id="gpsDot" class="w-2 h-2 rounded-full bg-slate-500 inline-block"></span>
                <span id="gpsText">GPS: –</span>
              </span>
              <span class="mx-2 text-slate-600">•</span>
              <span id="modeText">LIVE</span>
            </div>
          </div>
        </div>

        <div class="ml-auto flex items-center gap-2">
          <button id="btnStartFlight" class="btn-touch h-10 px-3 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-play mr-2"></i>Start
          </button>
          <button id="btnFinish" class="btn-touch hidden h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-flag-checkered mr-2"></i>Fertig
          </button>

          <!-- Wind dock toggle -->
          <button id="btnWindHud" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="Windpanel ein/ausklappen">
            <i class="fa-solid fa-wind text-slate-200"></i>
          </button>

          <!-- Point edit dock toggle -->
          <button id="btnPointDock" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="Punkt ändern (ohne Menü)">
            <i class="fa-solid fa-crosshairs text-slate-200"></i>
          </button>

          <button id="btnMapSettings" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-layer-group text-slate-200"></i>
          </button>

          <button id="btnCenter" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-location-crosshairs text-slate-200"></i>
          </button>

          <button id="btnMenu" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-bars text-slate-200"></i>
          </button>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="relative flex-1 min-h-0">
      <div id="map" class="absolute inset-0 z-0"></div>

      <!-- Wind Dock (LEFT, collapsible) -->
      <div class="absolute left-0 top-3 z-50">
        <!-- Collapsed -->
        <div id="windDockCollapsed" class="hidden rounded-r-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft px-2 py-2 flex flex-col items-center gap-2">
          <button id="btnWindDockExpand" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="Windpanel öffnen">
            <i class="fa-solid fa-chevron-right"></i>
          </button>
          <button id="btnWindDockFetchMini" class="btn-touch h-10 w-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold" title="Online-Wind">
            <i class="fa-solid fa-cloud-arrow-down"></i>
          </button>
          <div class="w-10 h-px bg-slate-800 my-1"></div>
          <div class="text-[10px] text-slate-400 text-center leading-3">
            <div class="font-bold text-slate-200">NAV</div>
            <div id="windDockMiniDist" class="mono text-slate-200">–</div>
          </div>
        </div>

        <!-- Expanded -->
        <div id="windDockExpanded" class="rounded-r-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft w-[72vw] max-w-[320px]">
          <div class="px-2 py-2 flex items-center gap-2 border-b border-slate-800">
            <button id="btnWindDockCollapse" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="Einklappen">
              <i class="fa-solid fa-chevron-left"></i>
            </button>
            <div class="font-extrabold text-sm flex items-center gap-2">
              <i class="fa-solid fa-wind text-sky-300"></i>
              <span>Wind</span>
            </div>
            <div class="ml-auto flex items-center gap-2">
              <button id="btnWindFetch" class="btn-touch px-3 h-10 rounded-xl bg-sky-400 text-slate-950 font-extrabold text-sm hover:bg-sky-300 active:bg-sky-500" title="Online von Open-Meteo">
                <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Online
              </button>
            </div>
          </div>

          <div class="px-2 py-2">
            <div class="text-[11px] text-slate-400 mb-2">
              Pfeil zeigt <span class="text-slate-200 font-bold">DRIFT (to)</span>, darunter <span class="text-slate-200 font-bold">FROM</span>.
            </div>

            <div id="windDockLayers" class="space-y-1"></div>

            <div class="mt-2 border-t border-slate-800 pt-2">
              <div class="flex items-center gap-2 mb-1">
                <i class="fa-solid fa-route text-emerald-300"></i>
                <div class="font-extrabold text-sm truncate" id="windDockNavName">Kein Task aktiv</div>
              </div>
              <div class="grid grid-cols-2 gap-2">
                <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
                  <div class="text-[11px] text-slate-400">Distanz</div>
                  <div class="font-extrabold mono text-base" id="windDockNavDist">–</div>
                </div>
                <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
                  <div class="text-[11px] text-slate-400">Bearing</div>
                  <div class="font-extrabold mono text-base" id="windDockNavBrg">–</div>
                </div>
              </div>
              <div class="mt-2 rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
                <div class="text-[11px] text-slate-400">Empfehlung</div>
                <div class="font-extrabold text-sm" id="windDockNavRec">–</div>
              </div>
              <div class="mt-2 text-xs text-slate-400">
                Task kommt aus dem <span class="text-slate-200 font-bold">Briefing</span> (Menü → Task).
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- Point Dock (RIGHT, keep map active) -->
      <div class="absolute right-3 top-28 z-50">
        <div id="pointDockCollapsed" class="rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft px-2 py-2">
          <button id="btnPointDockExpand" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="Punkt ändern">
            <i class="fa-solid fa-crosshairs"></i>
          </button>
        </div>

        <div id="pointDockExpanded" class="hidden w-[72vw] max-w-[330px] rounded-2xl bg-slate-950/85 backdrop-blur border border-slate-800 shadow-soft">
          <div class="px-3 py-2 flex items-center gap-2 border-b border-slate-800">
            <div class="font-extrabold text-sm flex items-center gap-2">
              <i class="fa-solid fa-crosshairs text-amber-300"></i>
              <span>Punkt ändern</span>
            </div>
            <button id="btnPointDockCollapse" class="ml-auto btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>

          <div class="px-3 py-2">
            <div class="text-xs text-slate-400 mb-2">
              Tipp: Du kannst jeden Punkt jederzeit neu setzen — ohne Menü.
            </div>

            <div class="rounded-2xl bg-slate-900/50 border border-slate-800 px-3 py-2 mb-2">
              <div class="text-[11px] text-slate-400">Aktuell</div>
              <div class="font-extrabold text-sm truncate" id="pointDockTaskName">Kein Task</div>
            </div>

            <div class="flex items-center gap-2">
              <div class="text-xs text-slate-400 shrink-0">Punkt</div>
              <div id="pointDockPoints" class="flex-1 flex gap-1 overflow-x-auto"></div>
            </div>

            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnPointPick" class="btn-touch h-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-hand-pointer mr-2"></i>Auf Karte setzen
              </button>
              <button id="btnPointCancelPick" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-ban mr-2"></i>Abbrechen
              </button>
            </div>

            <div id="pointPickHint" class="hidden mt-2 rounded-2xl bg-amber-400/10 border border-amber-400/30 px-3 py-2 text-xs text-amber-200">
              Jetzt auf die Karte tippen, um den ausgewählten Punkt neu zu setzen.
            </div>

            <div class="mt-2 rounded-2xl bg-slate-900/50 border border-slate-800 px-3 py-2">
              <div class="text-[11px] text-slate-400">Koordinaten</div>
              <div class="mono font-extrabold text-sm" id="pointDockCoords">–</div>
            </div>
          </div>
        </div>
      </div>

      <!-- Simulation Controls -->
      <div id="simControls" class="hidden absolute left-3 top-28 z-50 flex flex-col gap-2">
        <button id="btnBurner" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-orange-400 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-fire-flame-curved mr-2"></i>AUF
        </button>
        <button id="btnVent" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-sky-300 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-arrow-down-wide-short mr-2"></i>AB
        </button>
      </div>

      <!-- Map Settings Modal -->
      <div id="mapModal" class="hidden absolute inset-0 z-50">
        <div id="mapModalBg" class="absolute inset-0 bg-black/60"></div>
        <div class="absolute left-1/2 top-24 -translate-x-1/2 w-[92vw] max-w-[420px] rounded-2xl bg-slate-950 border border-slate-800 shadow-soft">
          <div class="px-4 py-3 flex items-center border-b border-slate-800">
            <div class="font-extrabold"><i class="fa-solid fa-layer-group mr-2 text-sky-300"></i>Karte</div>
            <button id="btnMapModalClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
          <div class="p-4 space-y-3">
            <div class="grid grid-cols-2 gap-2">
              <button id="btnBaseOSM" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-map mr-2"></i>OSM
              </button>
              <button id="btnBaseSAT" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-satellite mr-2"></i>Sat
              </button>
            </div>
            <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">GPS Follow</div>
                <div class="text-xs text-slate-400">Wenn du die Karte ziehst, wird Follow automatisch aus.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglFollow" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglFollowKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>
          </div>
        </div>
      </div>

      <!-- Snackbar -->
      <div id="snackbar" class="hidden absolute left-1/2 bottom-24 -translate-x-1/2 z-50 max-w-[92vw] rounded-2xl bg-slate-950/90 border border-slate-800 shadow-soft px-4 py-2 text-sm"></div>
    </main>

    <!-- Footer Cockpit -->
    <footer class="safe-bottom z-40 bg-slate-950/95 backdrop-blur border-t border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex-1 grid grid-cols-3 gap-2">
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">GS</div>
            <div class="text-lg font-extrabold mono"><span id="instGS">–</span> <span class="text-xs font-bold text-slate-400">km/h</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">ALT</div>
            <div class="text-lg font-extrabold mono"><span id="instALT">–</span> <span class="text-xs font-bold text-slate-400">m</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">VARIO</div>
            <div class="text-lg font-extrabold mono"><span id="instVAR">–</span> <span class="text-xs font-bold text-slate-400">m/s</span></div>
          </div>
        </div>

        <button id="btnMarker" class="btn-touch w-20 h-16 rounded-2xl bg-pink-400 hover:bg-pink-300 active:bg-pink-500 text-slate-950 font-extrabold shadow-soft">
          <i class="fa-solid fa-location-dot mr-2"></i>MARK
        </button>
      </div>
    </footer>
  </div>

  <!-- Side Drawer -->
  <div id="drawerWrap" class="hidden fixed inset-0 z-[60]">
    <div id="drawerBg" class="absolute inset-0 bg-black/60"></div>
    <aside id="drawer" class="absolute right-0 top-0 h-full w-[90vw] max-w-[380px] bg-slate-950 border-l border-slate-800 shadow-soft flex flex-col">
      <div class="safe-top px-4 py-3 flex items-center border-b border-slate-800">
        <div class="font-extrabold"><i class="fa-solid fa-compass mr-2 text-sky-300"></i>Menü</div>
        <button id="btnDrawerClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="px-3 py-2 border-b border-slate-800">
        <div class="grid grid-cols-4 gap-2">
          <button data-tab="task" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Task</button>
          <button data-tab="wind" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Wind</button>
          <button data-tab="setup" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Setup</button>
          <button data-tab="archive" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Archiv</button>
        </div>
      </div>

      <div class="px-4 py-3 panel-scroll">
        <!-- TASK -->
        <section id="tab_task" class="space-y-4">
          <!-- sub tabs -->
          <div class="grid grid-cols-2 gap-2">
            <button id="btnTaskSubBriefing" class="btn-touch h-10 rounded-xl bg-sky-400 text-slate-950 font-extrabold border border-sky-300">
              <i class="fa-solid fa-clipboard-list mr-2"></i>Briefing
            </button>
            <button id="btnTaskSubLive" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
              <i class="fa-solid fa-tower-broadcast mr-2"></i>Live
            </button>
          </div>

          <!-- BRIEFING CONTAINER -->
          <div id="taskSub_briefing" class="space-y-3">
            <div class="rounded-2xl bg-slate-900/45 border border-slate-800 p-3">
              <div class="font-extrabold mb-2"><i class="fa-solid fa-tag mr-2 text-amber-300"></i>Briefing Titel</div>
              <input id="briefingTitle" type="text" class="h-10 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold"
                     placeholder="z.B. Morgenfahrt" />
              <div class="mt-2 text-xs text-slate-400">
                Wird für Start/Archiv verwendet (Fahrt startet <span class="text-slate-200 font-bold">nicht automatisch</span>).
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/45 border border-slate-800 p-3">
              <div class="flex items-center gap-2 mb-2">
                <div class="font-extrabold"><i class="fa-solid fa-clipboard-list mr-2 text-emerald-300"></i>Briefing Aufgaben</div>
                <button id="btnBriefingNew" class="ml-auto btn-touch h-9 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                  <i class="fa-solid fa-plus mr-2"></i>Neu
                </button>
              </div>
              <div class="text-xs text-slate-400 mb-2">
                Mehrere Aufgaben anlegen, dann eine als aktiv wählen. Punkte kannst du später auch über das <span class="text-slate-200 font-bold">Fadenkreuz</span> (oben) ändern.
              </div>
              <div id="briefingList" class="space-y-2"></div>
            </div>

            <!-- Smaller editor -->
            <div class="rounded-2xl bg-slate-900/45 border border-slate-800 p-3">
              <div class="flex items-center gap-2 mb-2">
                <div class="font-extrabold"><i class="fa-solid fa-pen-to-square mr-2 text-sky-300"></i>Editor</div>
                <div class="ml-auto flex items-center gap-2">
                  <div class="text-[10px] px-2 py-0.5 rounded-full bg-slate-950/60 border border-slate-800 mono" id="editorModeBadge">Neu</div>
                  <div class="text-[10px] px-2 py-0.5 rounded-full bg-slate-950/60 border border-slate-800 mono" id="editorMarkerBadge">Marker: –</div>
                </div>
              </div>

              <div class="grid grid-cols-1 gap-2">
                <label class="text-[11px] text-slate-400">Task-Typ</label>
                <select id="taskType" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 font-extrabold text-sm"></select>

                <label class="text-[11px] text-slate-400 mt-1">Task-Name (optional)</label>
                <input id="taskTitle" type="text" placeholder="z.B. JDG Ziel 1" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 text-sm" />
              </div>

              <div id="taskFields" class="mt-3 space-y-3"></div>

              <div class="mt-3 grid grid-cols-3 gap-2">
                <button id="btnSaveBriefing" class="btn-touch h-10 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                  <i class="fa-solid fa-floppy-disk mr-2"></i>Save
                </button>
                <button id="btnPreviewTask" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                  <i class="fa-solid fa-map-location-dot mr-2"></i>Vorschau
                </button>
                <button id="btnSetActiveFromEditor" class="btn-touch h-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
                  <i class="fa-solid fa-bullseye mr-2"></i>Aktiv
                </button>
              </div>

              <div class="mt-2 grid grid-cols-2 gap-2">
                <button id="btnClearEditor" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                  <i class="fa-solid fa-eraser mr-2"></i>Leeren
                </button>
                <button id="btnShowActiveOnMap" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                  <i class="fa-solid fa-bullseye mr-2"></i>Aktiv zeigen
                </button>
              </div>

              <div class="mt-3 text-xs text-slate-400">
                Punkte ändern ohne Menü: oben <span class="text-slate-200 font-bold">Fadenkreuz</span> → Punkt wählen → „Auf Karte setzen“.
              </div>
            </div>
          </div>

          <!-- LIVE CONTAINER -->
          <div id="taskSub_live" class="hidden space-y-4">
            <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
              <div class="font-extrabold mb-2"><i class="fa-solid fa-bullseye mr-2 text-emerald-300"></i>Aktiver Task</div>
              <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
                <div class="font-extrabold truncate" id="activeTaskTitle">Kein Task aktiv</div>
                <div class="text-xs text-slate-400 mt-1" id="activeTaskHint">Wähle im Briefing eine Aufgabe und setze sie „Aktiv“.</div>
              </div>
              <div class="mt-2 grid grid-cols-2 gap-2">
                <button id="btnClearActive" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                  <i class="fa-solid fa-trash mr-2"></i>Aktiv löschen
                </button>
                <button id="btnCycleTask" class="btn-touch h-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
                  <i class="fa-solid fa-forward-step mr-2"></i>Nächste
                </button>
              </div>
              <div class="mt-2 text-xs text-slate-400">
                Navigation links im <span class="text-slate-200 font-bold">Windpanel</span>. Punkte neu setzen: Fadenkreuz (oben).
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
              <div class="font-extrabold mb-2"><i class="fa-solid fa-diagram-project mr-2 text-sky-300"></i>ELB Helper (optional)</div>
              <div class="text-xs text-slate-400 mb-3">Nur sinnvoll während aktiver Fahrt (Trackpunkte setzen).</div>
              <div class="grid grid-cols-3 gap-2">
                <button id="btnSetA" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set A</button>
                <button id="btnSetB" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set B</button>
                <button id="btnSetC" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set C</button>
              </div>
              <div class="mt-3 text-sm">
                <div class="text-xs text-slate-400">ELB Ergebnis (°):</div>
                <div class="font-extrabold mono text-lg" id="elbowResult">–</div>
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
              <div class="font-extrabold mb-2"><i class="fa-solid fa-list-check mr-2 text-amber-300"></i>Briefing-Liste</div>
              <div class="text-xs text-slate-400 mb-2">Schnell wechseln (ohne Fahrt-Neustart).</div>
              <div id="briefingQuickList" class="space-y-2"></div>
            </div>
          </div>
        </section>

        <!-- WIND -->
        <section id="tab_wind" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Windprofil</div>
            <div class="text-xs text-slate-400 mb-3">Auto-Record: wenn GS &gt; 10 km/h und ΔH&gt;50 m oder ΔKurs&gt;5° (nur während Fahrt).</div>

            <div class="grid grid-cols-3 gap-2">
              <input id="windAlt" type="number" placeholder="Höhe m" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 text-sm mono" />
              <input id="windDirFrom" type="number" placeholder="FROM °" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 text-sm mono" />
              <input id="windSpd" type="number" placeholder="km/h" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 text-sm mono" />
            </div>
            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnAddWind" class="btn-touch h-10 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-plus mr-2"></i>Hinzufügen
              </button>
              <button id="btnClearWind" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                <i class="fa-solid fa-trash mr-2"></i>Alle löschen
              </button>
            </div>

            <div class="mt-3 space-y-2" id="windList"></div>
          </div>
        </section>

        <!-- SETUP -->
        <section id="tab_setup" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-gear mr-2 text-sky-300"></i>Setup</div>

            <div class="flex items-center justify-between rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">Simulation</div>
                <div class="text-xs text-slate-400">GPS wird pausiert. Drift basiert auf Windprofil.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglSim" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglSimKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnWakeLock" class="btn-touch h-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-mobile-screen mr-2"></i>WakeLock
              </button>
              <button id="btnReset" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                <i class="fa-solid fa-rotate mr-2"></i>Reset UI
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-file-import mr-2 text-emerald-300"></i>KML Import</div>
              <input id="kmlFile" type="file" accept=".kml,.xml" class="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-bold file:bg-slate-900 file:text-slate-200 hover:file:bg-slate-800" />
              <div class="text-xs text-slate-400 mt-2">Importiertes KML wird als Overlay dargestellt (nur Ansicht).</div>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-download mr-2 text-amber-300"></i>PWA Hinweis</div>
              <div class="text-xs text-slate-400">
                Für „ohne Browser“-Look: im Chrome-Menü „Zum Startbildschirm hinzufügen“ → App öffnen.
              </div>
            </div>
          </div>
        </section>

        <!-- ARCHIVE -->
        <section id="tab_archive" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-box-archive mr-2 text-sky-300"></i>Archiv</div>
            <div class="text-xs text-slate-400 mb-3">Beendete Fahrten + KML Export (Track + Marker).</div>
            <div id="archiveList" class="space-y-2"></div>
            <button id="btnClearArchive" class="btn-touch mt-3 w-full h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
              <i class="fa-solid fa-trash mr-2"></i>Archiv löschen
            </button>
          </div>
        </section>
      </div>
    </aside>
  </div>

  <script>
    /********************************************************************
     * 1) KONSTANTEN & KONFIGURATION
     ********************************************************************/
    const APP = {
      name: "CompNavAir",
      version: "1.2.0",
      defaultCenter: { lat: 49.317, lon: 8.448 }, // Speyer/EDRY Nähe
      defaultZoom: 13,
      storageKey: "compnavair_v1_2",
      maxTrackPoints: 20000,
      trackMinDistM: 8,
      maxGpsJumpM: 160,
      gpsSmoothingAlpha: 0.25,
      followPanMinMs: 800,
      kmlName: "CompNavAir_Export",
    };

    const TILE = {
      osm: { url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", attr: '&copy; OpenStreetMap-Mitwirkende' },
      esri:{ url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", attr: "Tiles &copy; Esri" }
    };

    const CIA_TASKS = [
      { num: "15.1",  code: "PDG", title: "SELBST GEWÄHLTES ZIEL" },
      { num: "15.2",  code: "JDG", title: "VORGEGEBENES ZIEL" },
      { num: "15.3",  code: "HWZ", title: "QUAL DER WAHL" },
      { num: "15.4",  code: "FIN", title: "FLY IN" },
      { num: "15.5",  code: "FON", title: "FLY ON" },
      { num: "15.6",  code: "HNH", title: "FUCHSJAGD" },
      { num: "15.7",  code: "WSD", title: "FUCHSJAGD MIT ANLAUF" },
      { num: "15.8",  code: "GBM", title: "GORDON BENNETT MEMORIAL" },
      { num: "15.9",  code: "CRT", title: "ZIELFAHRT MIT ZEITFENSTER" },
      { num: "15.10", code: "RTA", title: "RENNEN ZUM WERTUNGSGEBIET" },
      { num: "15.11", code: "ELB", title: "ELLENBOGEN" },
      { num: "15.12", code: "LRN", title: "DREIECKSFLÄCHE" },
      { num: "15.13", code: "MDT", title: "MINIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.14", code: "SFL", title: "MINIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.15", code: "MDD", title: "MINIMUM DISTANCE ZWEI MARKER" },
      { num: "15.16", code: "XDT", title: "MAXIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.17", code: "XDI", title: "MAXIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.18", code: "XDD", title: "MAXIMUM DISTANCE ZWEI MARKER" },
      { num: "15.19", code: "ANG", title: "WINKEL" },
      { num: "15.20", code: "3DT", title: "3D-AUFGABE" },
      { num: "15.21", code: "APT", title: "HÖHENPROFIL-AUFGABE" } // optional
    ];

    // Schema: was muss wirklich angezeigt werden?
    const TASK_SCHEMA = {
      PDG: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      JDG: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      FIN: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      FON: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      HNH: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      WSD: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      GBM: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      CRT: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      MDT: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      SFL: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      XDT: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      XDI: { points: "A",   minPoints: 1, markers: 1, radii: false, setDir: false, apt: false },
      RTA: { points: "A",   minPoints: 1, markers: 0, radii: false, setDir: false, apt: false }, // vereinfachte Eingabe
      ELB: { points: "ABC", minPoints: 0, markers: 0, radii: false, setDir: false, apt: false }, // eher Trackpunkte
      LRN: { points: "ABC", minPoints: 3, markers: 0, radii: false, setDir: false, apt: false },
      ANG: { points: "AB",  minPoints: 2, markers: 0, radii: false, setDir: true,  apt: false },
      HWZ: { points: "MULTI", minPoints: 2, markers: 1, radii: false, setDir: false, apt: false },
      MDD: { points: "AB",  minPoints: 2, markers: 2, radii: false, setDir: false, apt: false },
      XDD: { points: "AB",  minPoints: 2, markers: 2, radii: false, setDir: false, apt: false },
      "3DT":{ points: "A",  minPoints: 1, markers: 0, radii: true,  setDir: false, apt: false },
      APT: { points: "NONE",minPoints: 0, markers: 0, radii: false, setDir: false, apt: true }
    };

    const MARKER_COLORS = ["pink","amber","emerald","sky","violet","rose","lime","orange"];
    const COLOR_HEX = {
      pink:   "#fb7185",
      amber:  "#fbbf24",
      emerald:"#34d399",
      sky:    "#38bdf8",
      violet: "#a78bfa",
      rose:   "#f43f5e",
      lime:   "#a3e635",
      orange: "#fb923c",
    };

    /********************************************************************
     * 2) GLOBALE VARIABLEN (STATE)
     ********************************************************************/
    const STATE = {
      map: null,
      layers: {
        baseOSM: null,
        baseSAT: null,
        tasksLayer: null,
        trackLayer: null,
        markersLayer: null,
        kmlLayer: null,
        trackLine: null,
      },
      ui: {
        drawerOpen: false,
        drawerTab: "task",
        taskSubTab: "briefing",
        followGps: true,
        base: "osm",
        mapPickMode: false,
        mapPickIndex: 0,
        mapPickLabel: "A",
        snackbarTimer: null,
        wakeLock: null,
        mapUserInteracting: false,
        windDockCollapsed: false,
        pointDockCollapsed: true,
        mapShownTaskId: null,
        pointSelectedIndex: 0,
        showAdvanced: false,
      },
      gps: {
        watchId: null,
        hasFix: false,
        fixTs: 0,
        lat: null,
        lon: null,
        altM: null,
        speedKmh: 0,
        headingDeg: 0,
        accuracyM: null,
        smoothLat: null,
        smoothLon: null,
        lastAltM: null,
        lastAltTs: null,
        lastPanTs: 0,
      },
      sim: {
        enabled: false,
        running: false,
        lat: null,
        lon: null,
        altM: 180,
        headingDeg: 0,
        speedKmh: 0,
        vRateMps: 0,
        timer: null,
        lastTickTs: 0,
      },
      flight: {
        active: false,
        title: "",
        startedTs: 0,
        track: [],
        markers: [],
        archive: [],
      },
      wind: {
        layers: [],
        lastAuto: { altM: null, courseDeg: null, ts: 0 },
      },
      task: {
        active: null,
        pointsABC: { A:null, B:null, C:null },
        apt: { startTs: null },
      },
      briefing: {
        title: "",
        tasks: [],
        editorTaskId: null
      },
      balloon: { marker: null }
    };

    /********************************************************************
     * 3) HELFER-FUNKTIONEN (Math, Formatting)
     ********************************************************************/
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function now() { return Date.now(); }
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }
    function uid() { return Math.random().toString(36).slice(2, 10); }

    function haversineM(a, b) {
      const R = 6371000;
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
      return R * c;
    }

    function bearingDeg(a, b) {
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLon = toRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    function destPoint(a, bearingDegVal, distM) {
      const R = 6371000;
      const brng = toRad(bearingDegVal);
      const lat1 = toRad(a.lat);
      const lon1 = toRad(a.lon);
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(distM/R) + Math.cos(lat1)*Math.sin(distM/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(distM/R)*Math.cos(lat1), Math.cos(distM/R)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: toDeg(lat2), lon: ((toDeg(lon2)+540)%360)-180 };
    }

    function angDiffDeg(a, b) {
      let d = ((a - b + 540) % 360) - 180;
      return Math.abs(d);
    }

    function fmtDist(m) {
      if (m == null || !isFinite(m)) return "–";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }
    function fmtNum(n, digits=0) {
      if (n == null || !isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function safeFloat(v, fallback=null) {
      const n = parseFloat(String(v ?? "").replace(",", "."));
      return Number.isFinite(n) ? n : fallback;
    }

    function smooth(prev, next, alpha) {
      if (prev == null || !isFinite(prev)) return next;
      return prev + alpha * (next - prev);
    }

    function windToDegFrom(fromDeg) { return (fromDeg + 180) % 360; }

    function schemaFor(code) { return TASK_SCHEMA[code] || { points:"A", minPoints:1, markers:1, radii:false, setDir:false, apt:false }; }

    function pointLabelsForTask(code, existingPointsCount=0) {
      const s = schemaFor(code);
      if (s.points === "ABC") return ["A","B","C"];
      if (s.points === "AB") return ["A","B"];
      if (s.points === "A") return ["A"];
      if (s.points === "NONE") return [];
      if (s.points === "MULTI") {
        const n = Math.max(s.minPoints || 2, existingPointsCount || 0, 2);
        return Array.from({length:n}, (_,i)=>`T${i+1}`);
      }
      return ["A"];
    }

    function escapeXml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&apos;");
    }

    function hashStr(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
      return h;
    }

    function showSnackbar(msg, ms=2200) {
      const el = document.getElementById("snackbar");
      if (!el) return;
      el.textContent = msg;
      el.classList.remove("hidden");
      clearTimeout(STATE.ui.snackbarTimer);
      STATE.ui.snackbarTimer = setTimeout(() => el.classList.add("hidden"), ms);
    }

    function setToggleUI(inputEl, knobEl, on) {
      inputEl.checked = !!on;
      knobEl.style.left = on ? "1.6rem" : "0.25rem";
      knobEl.style.background = on ? "#34d399" : "#e2e8f0";
    }

    function deepClone(obj) {
      try { return JSON.parse(JSON.stringify(obj)); } catch { return obj; }
    }

    function getActiveTask() { return STATE.task.active; }

    function setEditorBadge(text) {
      const el = document.getElementById("editorModeBadge");
      if (el) el.textContent = text;
    }
    function setEditorMarkerBadge(code) {
      const s = schemaFor(code);
      const el = document.getElementById("editorMarkerBadge");
      if (el) el.textContent = `Marker: ${s.markers ?? "–"}`;
    }

    /********************************************************************
     * 4) UI-RENDER-FUNKTIONEN
     ********************************************************************/
    function updateGpsBadge() {
      const dot = document.getElementById("gpsDot");
      const txt = document.getElementById("gpsText");
      const mode = document.getElementById("modeText");
      if (!dot || !txt || !mode) return;

      if (STATE.sim.enabled) {
        dot.className = "w-2 h-2 rounded-full bg-amber-300 inline-block";
        txt.textContent = "SIM";
        mode.textContent = "SIM";
        return;
      }
      if (STATE.gps.hasFix) {
        dot.className = "w-2 h-2 rounded-full bg-emerald-400 inline-block";
        const acc = STATE.gps.accuracyM != null ? `±${Math.round(STATE.gps.accuracyM)}m` : "";
        txt.textContent = `GPS: OK ${acc}`.trim();
        mode.textContent = "LIVE";
      } else {
        dot.className = "w-2 h-2 rounded-full bg-slate-500 inline-block";
        txt.textContent = "GPS: –";
        mode.textContent = "LIVE";
      }
    }

    function calcVarioMps() {
      const alt = STATE.gps.altM;
      const ts = now();
      if (alt == null || !isFinite(alt)) return null;

      if (STATE.gps.lastAltM == null) {
        STATE.gps.lastAltM = alt;
        STATE.gps.lastAltTs = ts;
        return 0;
      }
      const dt = (ts - STATE.gps.lastAltTs) / 1000;
      if (dt < 0.6) return null;

      const da = alt - STATE.gps.lastAltM;
      STATE.gps.lastAltM = alt;
      STATE.gps.lastAltTs = ts;
      return da / dt;
    }

    function updateInstruments() {
      const gsEl = document.getElementById("instGS");
      const altEl = document.getElementById("instALT");
      const varEl = document.getElementById("instVAR");

      let gs = 0, alt = null, vario = null;
      if (STATE.sim.enabled) {
        gs = STATE.sim.speedKmh || 0;
        alt = STATE.sim.altM;
        vario = STATE.sim.vRateMps;
      } else {
        gs = STATE.gps.speedKmh || 0;
        alt = STATE.gps.altM;
        vario = calcVarioMps();
      }

      if (gsEl) gsEl.textContent = fmtNum(gs, 1);
      if (altEl) altEl.textContent = alt == null ? "–" : String(Math.round(alt));
      if (varEl) varEl.textContent = vario == null ? "–" : fmtNum(vario, 1);
    }

    function setMarkerButtonColor(taskCode) {
      const btn = document.getElementById("btnMarker");
      if (!btn) return;
      const idx = Math.abs(hashStr(taskCode || "x")) % MARKER_COLORS.length;
      const c = MARKER_COLORS[idx];
      btn.style.background = COLOR_HEX[c];
      btn.style.color = "#0b1220";
    }

    function updateButtons() {
      const bStart = document.getElementById("btnStartFlight");
      const bFin = document.getElementById("btnFinish");
      if (bStart) bStart.classList.toggle("hidden", STATE.flight.active);
      if (bFin) bFin.classList.toggle("hidden", !STATE.flight.active);

      const simControls = document.getElementById("simControls");
      if (simControls) simControls.classList.toggle("hidden", !STATE.sim.enabled);

      updateWindDockVisibility();
      updatePointDockVisibility();
      updateActiveTaskCard();
      updatePointDock();
    }

    function renderTaskTypeOptions() {
      const sel = document.getElementById("taskType");
      if (!sel) return;
      sel.innerHTML = CIA_TASKS.map(t => `<option value="${t.code}">${t.num} ${t.code} — ${t.title}</option>`).join("");
    }

    function taskSummary(t) {
      if (!t) return "–";
      const s = schemaFor(t.code);
      const m = `M${s.markers ?? 0}`;
      const pts = (t.points || []).filter(p=>p && isFinite(p.lat) && isFinite(p.lon));
      const p0 = pts[0] ? `${pts[0].name||"A"} ${pts[0].lat.toFixed(4)},${pts[0].lon.toFixed(4)}` : "ohne Koords";
      const rr = (t.code === "3DT" && (t.r1M || t.r2M)) ? `r ${t.r1M||0}/${t.r2M||0}m` : "";
      return [m, p0, rr].filter(Boolean).join(" • ");
    }

    function updateDrawerTabUi() {
      document.querySelectorAll(".tabBtn").forEach(b => {
        const tab = b.getAttribute("data-tab");
        b.classList.toggle("bg-sky-400", tab === STATE.ui.drawerTab);
        b.classList.toggle("text-slate-950", tab === STATE.ui.drawerTab);
        b.classList.toggle("border-sky-300", tab === STATE.ui.drawerTab);
      });
      ["task","wind","setup","archive"].forEach(t => {
        const el = document.getElementById(`tab_${t}`);
        if (el) el.classList.toggle("hidden", t !== STATE.ui.drawerTab);
      });
      updateTaskSubTabUi();
    }

    function openDrawer(open=true) {
      STATE.ui.drawerOpen = open;
      const wrap = document.getElementById("drawerWrap");
      if (!wrap) return;
      wrap.classList.toggle("hidden", !open);
      if (open) {
        updateDrawerTabUi();
        renderBriefingList();
        renderBriefingQuickList();
      }
    }

    function openMapModal(open=true) {
      const modal = document.getElementById("mapModal");
      if (!modal) return;
      modal.classList.toggle("hidden", !open);
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    function updateWindDockVisibility() {
      const collapsed = document.getElementById("windDockCollapsed");
      const expanded = document.getElementById("windDockExpanded");
      if (!collapsed || !expanded) return;
      collapsed.classList.toggle("hidden", !STATE.ui.windDockCollapsed);
      expanded.classList.toggle("hidden", STATE.ui.windDockCollapsed);
    }

    function toggleWindDock() {
      STATE.ui.windDockCollapsed = !STATE.ui.windDockCollapsed;
      updateWindDockVisibility();
      persistAll();
    }

    function updatePointDockVisibility() {
      const c = document.getElementById("pointDockCollapsed");
      const e = document.getElementById("pointDockExpanded");
      if (!c || !e) return;
      c.classList.toggle("hidden", !STATE.ui.pointDockCollapsed);
      e.classList.toggle("hidden", STATE.ui.pointDockCollapsed);
    }

    function togglePointDock(forceOpen=null) {
      if (forceOpen === true) STATE.ui.pointDockCollapsed = false;
      else if (forceOpen === false) STATE.ui.pointDockCollapsed = true;
      else STATE.ui.pointDockCollapsed = !STATE.ui.pointDockCollapsed;

      // beim Öffnen: wenn kein Punkt gewählt, auf 0
      if (!STATE.ui.pointDockCollapsed) STATE.ui.pointSelectedIndex = 0;

      updatePointDockVisibility();
      updatePointDock();
      persistAll();
    }

    function setTaskSubTab(tab) {
      STATE.ui.taskSubTab = tab;
      updateTaskSubTabUi();
    }

    function updateTaskSubTabUi() {
      const bB = document.getElementById("btnTaskSubBriefing");
      const bL = document.getElementById("btnTaskSubLive");
      const sB = document.getElementById("taskSub_briefing");
      const sL = document.getElementById("taskSub_live");
      if (!bB || !bL || !sB || !sL) return;

      const isBriefing = STATE.ui.taskSubTab === "briefing";
      sB.classList.toggle("hidden", !isBriefing);
      sL.classList.toggle("hidden", isBriefing);

      bB.classList.toggle("bg-sky-400", isBriefing);
      bB.classList.toggle("text-slate-950", isBriefing);
      bB.classList.toggle("border-sky-300", isBriefing);
      bB.classList.toggle("bg-slate-900", !isBriefing);
      bB.classList.toggle("border-slate-800", !isBriefing);

      bL.classList.toggle("bg-sky-400", !isBriefing);
      bL.classList.toggle("text-slate-950", !isBriefing);
      bL.classList.toggle("border-sky-300", !isBriefing);
      bL.classList.toggle("bg-slate-900", isBriefing);
      bL.classList.toggle("border-slate-800", isBriefing);

      if (STATE.ui.drawerOpen && STATE.ui.drawerTab === "task") {
        renderBriefingList();
        renderBriefingQuickList();
      }
    }

    function updateActiveTaskCard() {
      const title = document.getElementById("activeTaskTitle");
      const hint = document.getElementById("activeTaskHint");
      if (!title || !hint) return;

      const t = getActiveTask();
      if (!t) {
        title.textContent = "Kein Task aktiv";
        hint.textContent = "Wähle im Briefing eine Aufgabe und setze sie „Aktiv“.";
      } else {
        title.textContent = `${t.code} — ${t.title || t.typeTitle}`;
        hint.textContent = STATE.flight.active ? "Fahrt läuft — Task-Wechsel ist erlaubt." : "Vor der Fahrt: Task passt. Du kannst jetzt starten.";
      }
    }

    /********************************************************************
     * 5) KERN-LOGIK (GPS, Map, Simulation, Briefing)
     ********************************************************************/
    function initManifestAndSW() {
      try {
        const manifest = {
          name: "CompNavAir",
          short_name: "CompNavAir",
          start_url: ".",
          display: "standalone",
          background_color: "#020617",
          theme_color: "#020617",
          icons: []
        };
        const href = "data:application/manifest+json," + encodeURIComponent(JSON.stringify(manifest));
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = href;
        document.head.appendChild(link);
      } catch {}

      try {
        if (!("serviceWorker" in navigator)) return;
        const swCode = `
          self.addEventListener('install', (e)=>self.skipWaiting());
          self.addEventListener('activate', (e)=>self.clients.claim());
          self.addEventListener('fetch', (e)=>{});
        `;
        const blob = new Blob([swCode], { type: "text/javascript" });
        const url = URL.createObjectURL(blob);
        navigator.serviceWorker.register(url).catch(()=>{});
      } catch {}
    }

    function initMap() {
      const map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
        zoomSnap: 0.25,
        preferCanvas: true,
      });
      STATE.map = map;

      STATE.layers.baseOSM = L.tileLayer(TILE.osm.url, { maxZoom: 19, attribution: TILE.osm.attr });
      STATE.layers.baseSAT = L.tileLayer(TILE.esri.url, { maxZoom: 19, attribution: TILE.esri.attr });

      STATE.layers.baseOSM.addTo(map);

      STATE.layers.tasksLayer = L.layerGroup().addTo(map);
      STATE.layers.trackLayer = L.layerGroup().addTo(map);
      STATE.layers.markersLayer = L.layerGroup().addTo(map);

      STATE.layers.trackLine = L.polyline([], { color: "#ef4444", weight: 4, opacity: 0.9, interactive: false }).addTo(STATE.layers.trackLayer);
      map.setView([APP.defaultCenter.lat, APP.defaultCenter.lon], APP.defaultZoom);

      map.on("dragstart", () => {
        STATE.ui.mapUserInteracting = true;
        STATE.ui.followGps = false;
        updateFollowToggleUi();
      });
      map.on("dragend", () => setTimeout(()=>STATE.ui.mapUserInteracting = false, 150));

      // Map click: point-pick without menu
      map.on("click", (e) => {
        if (!STATE.ui.mapPickMode) return;
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        setDisplayedTaskPoint(STATE.ui.mapPickIndex, lat, lon);
        STATE.ui.mapPickMode = false;
        const hint = document.getElementById("pointPickHint");
        if (hint) hint.classList.add("hidden");
        showSnackbar(`Punkt ${STATE.ui.mapPickLabel} gesetzt.`);
      });

      ensureBalloonMarker();
    }

    function ensureBalloonMarker() {
      if (!STATE.map) return;

      const icon = L.divIcon({
        className: "",
        iconSize: [28, 28],
        iconAnchor: [14, 14],
        html: `
          <div class="balloon-icon">
            <div id="balloonRot" class="balloon-rot">
              <i class="fa-solid fa-location-arrow text-sky-300 drop-shadow"></i>
            </div>
          </div>
        `
      });

      const p = getCurrentPos() || APP.defaultCenter;
      STATE.balloon.marker = L.marker([p.lat, p.lon], { icon, interactive: false }).addTo(STATE.map);
    }

    function setBalloonPose(lat, lon, headingDegVal) {
      if (!STATE.balloon.marker) return;
      STATE.balloon.marker.setLatLng([lat, lon]);
      const rot = document.getElementById("balloonRot");
      if (rot) rot.style.transform = `rotate(${headingDegVal || 0}deg)`;
    }

    function setBaseLayer(which) {
      if (!STATE.map) return;
      STATE.ui.base = which;
      try {
        if (which === "sat") {
          STATE.map.removeLayer(STATE.layers.baseOSM);
          STATE.layers.baseSAT.addTo(STATE.map);
        } else {
          STATE.map.removeLayer(STATE.layers.baseSAT);
          STATE.layers.baseOSM.addTo(STATE.map);
        }
      } catch {}
    }

    function updateFollowToggleUi() {
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    function initGPS() {
      if (!("geolocation" in navigator)) { showSnackbar("Geolocation nicht verfügbar."); return; }
      stopGPS();
      const opts = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };

      STATE.gps.watchId = navigator.geolocation.watchPosition(
        (pos) => { try { onGpsPosition(pos); } catch (e) { console.error(e); } },
        (err) => {
          console.warn(err);
          STATE.gps.hasFix = false;
          updateGpsBadge();
          updateWindDock();
        },
        opts
      );
    }

    function stopGPS() {
      try { if (STATE.gps.watchId != null) navigator.geolocation.clearWatch(STATE.gps.watchId); } catch {}
      STATE.gps.watchId = null;
    }

    function onGpsPosition(pos) {
      if (STATE.sim.enabled) return;

      const c = pos.coords;
      const lat = c.latitude;
      const lon = c.longitude;
      const alt = Number.isFinite(c.altitude) ? c.altitude : null;
      const spdKmh = Number.isFinite(c.speed) ? (c.speed * 3.6) : 0;
      const head = Number.isFinite(c.heading) ? c.heading : (STATE.gps.headingDeg || 0);
      const acc = Number.isFinite(c.accuracy) ? c.accuracy : null;

      if (STATE.gps.smoothLat != null && STATE.gps.smoothLon != null) {
        const d = haversineM({ lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon }, { lat, lon });
        const dyn = clamp((spdKmh/3.6) * 3 + 60, 80, 220);
        if (d > Math.max(APP.maxGpsJumpM, dyn)) return;
      }

      STATE.gps.smoothLat = smooth(STATE.gps.smoothLat, lat, APP.gpsSmoothingAlpha);
      STATE.gps.smoothLon = smooth(STATE.gps.smoothLon, lon, APP.gpsSmoothingAlpha);

      STATE.gps.lat = STATE.gps.smoothLat;
      STATE.gps.lon = STATE.gps.smoothLon;
      STATE.gps.altM = alt;
      STATE.gps.speedKmh = spdKmh;
      STATE.gps.headingDeg = head;
      STATE.gps.accuracyM = acc;

      STATE.gps.hasFix = true;
      STATE.gps.fixTs = now();

      setBalloonPose(STATE.gps.lat, STATE.gps.lon, head);

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.gps.lat, STATE.gps.lon], { animate: true, duration: 0.35 });
        }
      }

      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.gps.lat, lon: STATE.gps.lon, altM: alt, ts: now() });
        maybeAutoRecordWind({ altM: alt, courseDeg: head, speedKmh: spdKmh, ts: now() });
      }

      updateGpsBadge();
      updateInstruments();
      updateWindDock();
      updatePointDock();
      persistAllThrottled();
    }

    function getCurrentPos() {
      if (STATE.sim.enabled && STATE.sim.lat != null && STATE.sim.lon != null) return { lat: STATE.sim.lat, lon: STATE.sim.lon };
      if (!STATE.gps.hasFix || STATE.gps.lat == null || STATE.gps.lon == null) return null;
      return { lat: STATE.gps.lat, lon: STATE.gps.lon };
    }

    function getCurrentAltM() {
      if (STATE.sim.enabled) return STATE.sim.altM;
      return STATE.gps.altM;
    }

    function beginFlight() {
      if (STATE.flight.active) return;
      const t = getActiveTask();
      const briefingTitle = (STATE.briefing.title || "").trim();
      const taskTitle = t ? `${t.code} — ${t.title || t.typeTitle}` : "Ohne Task";
      const finalTitle = briefingTitle ? `${briefingTitle} • ${taskTitle}` : taskTitle;

      STATE.flight.active = true;
      STATE.flight.title = finalTitle;
      STATE.flight.startedTs = now();
      STATE.flight.track = [];
      STATE.flight.markers = [];

      try { STATE.layers.trackLine?.setLatLngs([]); } catch {}
      try { STATE.layers.markersLayer?.clearLayers(); } catch {}

      STATE.gps.lastAltM = null;
      STATE.gps.lastAltTs = null;
      STATE.wind.lastAuto = { altM: null, courseDeg: null, ts: 0 };
      STATE.task.apt.startTs = null;

      STATE.ui.mapShownTaskId = null;
      drawDisplayedTaskOnMap();

      updateButtons();
      updateWindDock();
      showSnackbar("Fahrt gestartet.");
      persistAll();
    }

    function finishFlight() {
      if (!STATE.flight.active) return;

      const endedTs = now();
      const flight = {
        id: uid(),
        title: STATE.flight.title || "Fahrt",
        startedTs: STATE.flight.startedTs,
        endedTs,
        track: STATE.flight.track.slice(0),
        markers: STATE.flight.markers.slice(0),
      };

      STATE.flight.archive.push(flight);
      STATE.flight.active = false;
      STATE.flight.title = "";
      STATE.flight.startedTs = 0;
      STATE.task.apt.startTs = null;

      updateButtons();
      updateArchivePanel();
      updateWindDock();
      showSnackbar("Fahrt beendet & archiviert.");
      persistAll();
    }

    function maybeAddTrackPoint(p) {
      if (!STATE.flight.active) return;
      if (!p || p.lat == null || p.lon == null) return;

      const track = STATE.flight.track;
      if (track.length) {
        const last = track[track.length-1];
        const d = haversineM({ lat:last.lat, lon:last.lon }, { lat:p.lat, lon:p.lon });
        if (d < APP.trackMinDistM) return;
      }

      track.push({ lat:p.lat, lon:p.lon, altM:p.altM, ts:p.ts });
      if (track.length > APP.maxTrackPoints) track.shift();

      try {
        const latlngs = track.map(x => [x.lat, x.lon]);
        STATE.layers.trackLine?.setLatLngs(latlngs);
      } catch {}
    }

    function maybeAutoRecordWind({ altM, courseDeg, speedKmh, ts }) {
      if (!STATE.flight.active) return;
      if (speedKmh == null || speedKmh < 10) return;
      if (altM == null || !isFinite(altM)) return;

      const last = STATE.wind.lastAuto;
      const dAlt = last.altM == null ? 9999 : Math.abs(altM - last.altM);
      const dCrs = last.courseDeg == null ? 9999 : angDiffDeg(courseDeg, last.courseDeg);

      if (dAlt > 50 || dCrs > 5) {
        const fromDeg = (courseDeg + 180) % 360;
        addWindLayer({ altM, fromDeg, speedKmh, ts, source: "auto" });
        STATE.wind.lastAuto = { altM, courseDeg, ts };
      }
    }

    function addWindLayer(w) {
      const alt = Math.round(w.altM);
      const from = ((Math.round(w.fromDeg)%360)+360)%360;
      const spd = Math.max(0, safeFloat(w.speedKmh, 0));
      const ts = w.ts || now();

      const idx = STATE.wind.layers.findIndex(x => Math.abs(x.altM - alt) <= 15);
      const item = { altM: alt, fromDeg: from, speedKmh: spd, ts, source: w.source || "manual" };
      if (idx >= 0) STATE.wind.layers[idx] = item;
      else STATE.wind.layers.push(item);

      STATE.wind.layers.sort((a,b)=>a.altM-b.altM);
      persistAll();
      updateWindPanel();
      updateWindDock();
    }

    function windAtAltitude(altM) {
      if (!STATE.wind.layers.length || altM == null) return null;
      let best = null, bestD = Infinity;
      for (const w of STATE.wind.layers) {
        const d = Math.abs(w.altM - altM);
        if (d < bestD) { bestD = d; best = w; }
      }
      return best;
    }

    function recommendLayerText(task, pos, target) {
      if (task && task.code === "3DT" && task.center && task.r1M && task.r2M) {
        const dC = haversineM(pos, task.center);
        if (dC < task.r1M) return "Ungültig (im inneren Kreis)";
        if (dC <= task.r2M) return "Im Ring: Distanz maximieren";
        return "Außerhalb: Ziel = Zentrum";
      }

      if (!STATE.wind.layers.length) return "Kein Windprofil";
      const brg = bearingDeg(pos, target);

      let best = null;
      let bestScore = Infinity;
      for (const w of STATE.wind.layers) {
        const driftTo = windToDegFrom(w.fromDeg);
        const score = angDiffDeg(driftTo, brg);
        if (score < bestScore) { bestScore = score; best = w; }
      }
      if (!best) return "Kein Layer";

      const curAlt = getCurrentAltM();
      const need = Math.round(best.altM);
      if (curAlt == null) return `Layer: ${need}m`;
      const dAlt = need - curAlt;
      if (Math.abs(dAlt) < 25) return `Halten ~${need}m`;
      return dAlt > 0 ? `Steigen auf ${need}m` : `Sinken auf ${need}m`;
    }

    function clearTaskOverlays() {
      try { STATE.layers.tasksLayer?.clearLayers(); } catch {}
    }

    function drawTaskOnMap(task) {
      clearTaskOverlays();
      if (!task || !STATE.map) return;

      const NI = { interactive: false };
      const pts = (task.points || []).filter(p => p && isFinite(p.lat) && isFinite(p.lon));

      pts.forEach((p, idx) => {
        const color = idx === 0 ? "#60a5fa" : "#93c5fd";
        L.circleMarker([p.lat, p.lon], {
          radius: 9, color, weight: 3, fillColor: color, fillOpacity: 0.25, ...NI
        }).addTo(STATE.layers.tasksLayer);

        L.marker([p.lat, p.lon], {
          icon: L.divIcon({
            className: "",
            iconSize: [1,1],
            html: `<div class="mono text-xs font-extrabold text-sky-200 drop-shadow">${escapeXml(p.name||String.fromCharCode(65+idx))}</div>`
          }),
          interactive: false
        }).addTo(STATE.layers.tasksLayer);
      });

      const center = task.center || (pts[0] ? { lat: pts[0].lat, lon: pts[0].lon } : null);
      if (center && (task.r2M || task.r1M)) {
        if (task.r2M) {
          L.circle([center.lat, center.lon], {
            radius: task.r2M, color: "#60a5fa", weight: 3, opacity: 0.9, fillOpacity: 0.05, ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
        if (task.r1M) {
          L.circle([center.lat, center.lon], {
            radius: task.r1M, color: "#93c5fd", weight: 2, opacity: 0.8, dashArray: "6 8", fillOpacity: 0.01, ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
      }

      if (task.code === "ANG" && pts.length >= 2) {
        L.polyline(pts.slice(0,2).map(p => [p.lat,p.lon]), { color:"#38bdf8", weight:3, opacity:0.9, dashArray:"8 8", ...NI })
          .addTo(STATE.layers.tasksLayer);
      }
      if (task.code === "LRN" && pts.length >= 3) {
        L.polyline(pts.slice(0,3).map(p => [p.lat,p.lon]).concat([[pts[0].lat, pts[0].lon]]), { color:"#38bdf8", weight:3, opacity:0.9, ...NI })
          .addTo(STATE.layers.tasksLayer);
      }
    }

    function drawDisplayedTaskOnMap() {
      if (STATE.flight.active) { drawTaskOnMap(STATE.task.active); return; }
      const shownId = STATE.ui.mapShownTaskId;
      if (shownId) {
        const t = STATE.briefing.tasks.find(x => x.id === shownId);
        if (t) { drawTaskOnMap(t); return; }
        STATE.ui.mapShownTaskId = null;
      }
      drawTaskOnMap(STATE.task.active);
    }

    function getDisplayedTaskSource() {
      // Während Fahrt: aktiver Task
      if (STATE.flight.active) {
        return {
          kind: "active",
          get: () => STATE.task.active,
          set: (t) => { STATE.task.active = t; }
        };
      }

      // Vor Fahrt: wenn Vorschau gewählt, dann Briefing-Task
      if (STATE.ui.mapShownTaskId) {
        const id = STATE.ui.mapShownTaskId;
        const idx = STATE.briefing.tasks.findIndex(x => x.id === id);
        if (idx >= 0) {
          return {
            kind: "briefing",
            get: () => STATE.briefing.tasks[idx],
            set: (t) => {
              STATE.briefing.tasks[idx] = t;
              // falls derselbe Task auch aktiv ist (via briefingId) -> aktualisieren
              if (STATE.task.active?.briefingId === id) {
                const a = deepClone(t);
                a.briefingId = id;
                STATE.task.active = a;
              }
            }
          };
        }
      }

      // Default: aktiver Task
      return {
        kind: "active",
        get: () => STATE.task.active,
        set: (t) => { STATE.task.active = t; }
      };
    }

    function setDisplayedTaskPoint(index, lat, lon) {
      const src = getDisplayedTaskSource();
      let t = src.get();
      if (!t) { showSnackbar("Kein Task ausgewählt."); return; }
      t = deepClone(t);

      const labels = pointLabelsForTask(t.code, (t.points||[]).length);
      const label = labels[index] || `P${index+1}`;

      if (!Array.isArray(t.points)) t.points = [];
      while (t.points.length <= index) t.points.push({ name: labels[t.points.length] || `P${t.points.length+1}`, lat: null, lon: null });

      t.points[index] = { name: label, lat, lon };

      // Spezial: 3DT center
      if (t.code === "3DT") t.center = { lat: t.points[0].lat, lon: t.points[0].lon };

      src.set(t);

      // sync editor fields if this is the editor task
      syncEditorPointInputsFromTask(t);
      drawDisplayedTaskOnMap();
      renderBriefingList();
      renderBriefingQuickList();
      updatePointDock();
      updateWindDock();
      persistAll();
    }

    function getPrimaryTarget(task) {
      if (!task) return null;
      if (task.code === "3DT" && task.center) return task.center;
      const pts = (task.points || []).filter(p => p && isFinite(p.lat) && isFinite(p.lon));
      if (pts.length) return { lat: pts[0].lat, lon: pts[0].lon };
      return null;
    }

    function dropMarker() {
      if (!STATE.flight.active) { showSnackbar("Bitte zuerst die Fahrt starten."); return; }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }

      const alt = getCurrentAltM();
      const t = getActiveTask();
      const colorKey = t ? MARKER_COLORS[Math.abs(hashStr(t.code)) % MARKER_COLORS.length] : "pink";
      const color = COLOR_HEX[colorKey];

      const m = { lat: pos.lat, lon: pos.lon, altM: alt, ts: now(), color: colorKey, label: t ? t.code : "MARK" };
      STATE.flight.markers.push(m);

      L.circleMarker([m.lat, m.lon], { radius: 8, color, weight: 3, fillColor: color, fillOpacity: 0.25, interactive: false })
        .addTo(STATE.layers.markersLayer);

      showSnackbar("Marker gesetzt.");
      persistAll();
    }

    async function fetchWindFromOpenMeteo() {
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position für Online-Wind."); return; }

      const lat = pos.lat.toFixed(4);
      const lon = pos.lon.toFixed(4);

      const hourly = [
        "windspeed_10m","winddirection_10m",
        "windspeed_80m","winddirection_80m",
        "windspeed_120m","winddirection_120m",
        "windspeed_180m","winddirection_180m"
      ].join(",");

      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=${hourly}&forecast_days=1&timezone=auto`;

      try {
        showSnackbar("Lade Wind…", 1200);
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        const j = await r.json();

        const h = j.hourly;
        if (!h || !h.time || !h.time.length) throw new Error("no hourly data");

        const tNow = now();
        let bestI = 0, bestD = Infinity;
        for (let i=0;i<h.time.length;i++) {
          const t = Date.parse(h.time[i]);
          const d = Math.abs(t - tNow);
          if (d < bestD) { bestD = d; bestI = i; }
        }

        const mapping = [
          { altM: 10,  spd: h.windspeed_10m?.[bestI],  dir: h.winddirection_10m?.[bestI] },
          { altM: 80,  spd: h.windspeed_80m?.[bestI],  dir: h.winddirection_80m?.[bestI] },
          { altM: 120, spd: h.windspeed_120m?.[bestI], dir: h.winddirection_120m?.[bestI] },
          { altM: 180, spd: h.windspeed_180m?.[bestI], dir: h.winddirection_180m?.[bestI] },
        ];

        let added = 0;
        for (const m of mapping) {
          if (m.spd == null || m.dir == null) continue;
          addWindLayer({ altM: m.altM, fromDeg: m.dir, speedKmh: m.spd, ts: now(), source: "open-meteo" });
          added++;
        }
        showSnackbar(added ? `Wind geladen (${added} Schichten).` : "Keine Windschichten gefunden.");
      } catch (e) {
        console.error(e);
        showSnackbar("Online-Wind fehlgeschlagen.");
      }
    }

    function centerOnPos() {
      const p = getCurrentPos();
      if (!p || !STATE.map) return;
      STATE.ui.followGps = true;
      updateFollowToggleUi();
      STATE.map.panTo([p.lat, p.lon], { animate:true, duration:0.35 });
      showSnackbar("Zentriert.");
    }

    /********************************************************************
     * Editor: Nur notwendige Felder anzeigen
     ********************************************************************/
    function renderTaskFieldsForCode(code, existingTask=null) {
      const wrap = document.getElementById("taskFields");
      if (!wrap) return;

      const s = schemaFor(code);
      setEditorMarkerBadge(code);

      const labels = pointLabelsForTask(code, (existingTask?.points || []).length);

      const pointRow = (label, idx, latVal=null, lonVal=null) => `
        <div class="grid grid-cols-[40px_1fr_1fr] gap-2 items-center" data-pt-row="${idx}">
          <div class="text-xs font-extrabold text-slate-200">${escapeXml(label)}</div>
          <input data-pt-lat="${idx}" type="number" step="0.000001" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="Lat"
                 value="${latVal ?? ""}" />
          <input data-pt-lon="${idx}" type="number" step="0.000001" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="Lon"
                 value="${lonVal ?? ""}" />
        </div>
      `;

      let pointsHtml = "";
      if (s.points === "NONE") {
        pointsHtml = `<div class="text-sm text-slate-400">Keine Koordinaten nötig.</div>`;
      } else {
        const pts = (existingTask?.points || []);
        pointsHtml = `
          <div class="rounded-2xl bg-slate-950/50 border border-slate-800 p-3 space-y-2">
            <div class="flex items-center justify-between">
              <div class="font-extrabold text-sm"><i class="fa-solid fa-location-crosshairs mr-2 text-sky-300"></i>Koordinaten</div>
              <button id="btnEditorPickOpen" class="btn-touch h-9 px-3 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-xs">
                <i class="fa-solid fa-crosshairs mr-2"></i>Über Karte
              </button>
            </div>
            <div id="editorPointsWrap" class="space-y-2">
              ${labels.map((lab, idx) => {
                const p = pts[idx];
                const lv = (p && isFinite(p.lat)) ? p.lat : null;
                const ov = (p && isFinite(p.lon)) ? p.lon : null;
                return pointRow(lab, idx, lv, ov);
              }).join("")}
            </div>
            ${s.points === "MULTI" ? `
              <button id="btnAddTarget" class="btn-touch h-10 w-full rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-sm">
                <i class="fa-solid fa-plus mr-2"></i>Weiteres Ziel (HWZ)
              </button>
            ` : ""}
            <div class="text-xs text-slate-400">
              Schnell ändern ohne Menü: oben <span class="text-slate-200 font-bold">Fadenkreuz</span>.
            </div>
          </div>
        `;
      }

      const radiiHtml = s.radii ? `
        <div class="rounded-2xl bg-slate-950/50 border border-slate-800 p-3">
          <div class="font-extrabold text-sm mb-2"><i class="fa-solid fa-circle-nodes mr-2 text-sky-300"></i>Radien (3DT)</div>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <div class="text-[11px] text-slate-400 mb-1">Innen (m)</div>
              <input id="taskR1" type="number" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="z.B. 50" value="${existingTask?.r1M ?? ""}" />
            </div>
            <div>
              <div class="text-[11px] text-slate-400 mb-1">Außen (m)</div>
              <input id="taskR2" type="number" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="z.B. 200" value="${existingTask?.r2M ?? ""}" />
            </div>
          </div>
        </div>
      ` : "";

      const setDirHtml = s.setDir ? `
        <div class="rounded-2xl bg-slate-950/50 border border-slate-800 p-3">
          <div class="font-extrabold text-sm mb-2"><i class="fa-solid fa-compass mr-2 text-amber-300"></i>Vorgegebene Richtung (ANG)</div>
          <input id="taskSetDir" type="number" class="h-10 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="0..359"
                 value="${existingTask?.setDirDeg ?? ""}" />
        </div>
      ` : "";

      // Advanced (optional)
      const advHtml = `
        <div class="rounded-2xl bg-slate-950/50 border border-slate-800 p-3">
          <div class="flex items-center justify-between">
            <div class="font-extrabold text-sm"><i class="fa-solid fa-sliders mr-2 text-slate-300"></i>Erweitert</div>
            <button id="btnToggleAdv" class="btn-touch h-9 px-3 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold text-xs">
              ${STATE.ui.showAdvanced ? "Ausblenden" : "Anzeigen"}
            </button>
          </div>
          <div id="advWrap" class="${STATE.ui.showAdvanced ? "" : "hidden"} mt-2">
            <div class="grid grid-cols-2 gap-2">
              <div>
                <div class="text-[11px] text-slate-400 mb-1">Min Höhe (m)</div>
                <input id="taskMinAlt" type="number" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="optional" value="${existingTask?.minAltM ?? ""}" />
              </div>
              <div>
                <div class="text-[11px] text-slate-400 mb-1">Max Höhe (m)</div>
                <input id="taskMaxAlt" type="number" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="optional" value="${existingTask?.maxAltM ?? ""}" />
              </div>
            </div>
          </div>
        </div>
      `;

      wrap.innerHTML = `${pointsHtml}${radiiHtml}${setDirHtml}${advHtml}`;
      wireTaskFieldsDynamic(code);
    }

    function wireTaskFieldsDynamic(code) {
      const s = schemaFor(code);

      // Advanced toggle
      const btnAdv = document.getElementById("btnToggleAdv");
      const advWrap = document.getElementById("advWrap");
      if (btnAdv && advWrap) {
        btnAdv.onclick = () => {
          STATE.ui.showAdvanced = !STATE.ui.showAdvanced;
          advWrap.classList.toggle("hidden", !STATE.ui.showAdvanced);
          btnAdv.textContent = STATE.ui.showAdvanced ? "Ausblenden" : "Anzeigen";
          persistAll();
        };
      }

      // Open point dock quickly
      const btnPick = document.getElementById("btnEditorPickOpen");
      if (btnPick) btnPick.onclick = () => {
        togglePointDock(true);
        showSnackbar("Punkt-Dock geöffnet. Punkt wählen → auf Karte setzen.");
      };

      // Multi-target add
      const btnAdd = document.getElementById("btnAddTarget");
      const wrap = document.getElementById("editorPointsWrap");
      if (btnAdd && wrap && s.points === "MULTI") {
        btnAdd.onclick = () => {
          const idx = wrap.querySelectorAll('[data-pt-row]').length;
          const lab = `T${idx+1}`;
          const row = document.createElement("div");
          row.setAttribute("data-pt-row", String(idx));
          row.className = "grid grid-cols-[40px_1fr_1fr] gap-2 items-center";
          row.innerHTML = `
            <div class="text-xs font-extrabold text-slate-200">${escapeXml(lab)}</div>
            <input data-pt-lat="${idx}" type="number" step="0.000001" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="Lat" />
            <input data-pt-lon="${idx}" type="number" step="0.000001" class="h-10 rounded-xl bg-slate-950 border border-slate-700 px-3 mono text-sm" placeholder="Lon" />
          `;
          wrap.appendChild(row);
          showSnackbar("Ziel hinzugefügt.");
        };
      }
    }

    function buildTaskFromForm() {
      const code = document.getElementById("taskType")?.value;
      const meta = CIA_TASKS.find(x => x.code === code);
      if (!code || !meta) return null;
      const s = schemaFor(code);

      const title = document.getElementById("taskTitle")?.value?.trim() || "";

      // points
      let points = [];
      if (s.points !== "NONE") {
        // dynamic inputs
        const latInputs = Array.from(document.querySelectorAll("[data-pt-lat]"));
        const lonInputs = Array.from(document.querySelectorAll("[data-pt-lon]"));
        const map = new Map();
        latInputs.forEach(inp => {
          const idx = parseInt(inp.getAttribute("data-pt-lat"),10);
          if (!Number.isFinite(idx)) return;
          map.set(idx, map.get(idx) || {});
          map.get(idx).lat = safeFloat(inp.value, null);
        });
        lonInputs.forEach(inp => {
          const idx = parseInt(inp.getAttribute("data-pt-lon"),10);
          if (!Number.isFinite(idx)) return;
          map.set(idx, map.get(idx) || {});
          map.get(idx).lon = safeFloat(inp.value, null);
        });

        const labels = pointLabelsForTask(code, map.size);
        const maxIdx = Math.max(...Array.from(map.keys()), labels.length-1, -1);
        for (let i=0;i<=maxIdx;i++) {
          const o = map.get(i) || {};
          if (o.lat == null || o.lon == null) continue;
          points.push({ name: labels[i] || `P${i+1}`, lat:o.lat, lon:o.lon });
        }
      }

      // minimal validation for required points
      if ((s.minPoints || 0) > 0 && points.length < (s.minPoints || 0)) {
        return { _error: `Bitte mind. ${s.minPoints} Punkt(e) setzen.` };
      }

      const task = {
        id: uid(),
        code,
        typeTitle: meta.title,
        title,
        points,
        r1M: null,
        r2M: null,
        minAltM: null,
        maxAltM: null,
        setDirDeg: null,
        center: null,
        apt: null,
      };

      if (s.radii) {
        const r1 = safeFloat(document.getElementById("taskR1")?.value, null);
        const r2 = safeFloat(document.getElementById("taskR2")?.value, null);
        task.r1M = r1 != null ? Math.max(0, r1) : null;
        task.r2M = r2 != null ? Math.max(0, r2) : null;
      }
      if (s.setDir) {
        const setDir = safeFloat(document.getElementById("taskSetDir")?.value, null);
        task.setDirDeg = setDir != null ? ((setDir%360)+360)%360 : null;
      }

      if (STATE.ui.showAdvanced) {
        const minAlt = safeFloat(document.getElementById("taskMinAlt")?.value, null);
        const maxAlt = safeFloat(document.getElementById("taskMaxAlt")?.value, null);
        task.minAltM = minAlt;
        task.maxAltM = maxAlt;
      }

      if (task.code === "3DT") {
        const p0 = task.points[0];
        if (p0) task.center = { lat: p0.lat, lon: p0.lon };
      }
      return task;
    }

    function syncEditorPointInputsFromTask(task) {
      // Nur wenn der Editor gerade genau diesen Briefing-Task bearbeitet (oder aktiv ohne briefingId)
      const editorId = STATE.briefing.editorTaskId;
      if (!editorId) return;
      const edited = STATE.briefing.tasks.find(x => x.id === editorId);
      if (!edited) return;

      // Wenn task.id nicht passt, nichts
      if (task.id !== editorId) return;

      // Update only point fields (do not rerender whole form)
      const pts = (task.points || []);
      pts.forEach((p, idx) => {
        const latEl = document.querySelector(`[data-pt-lat="${idx}"]`);
        const lonEl = document.querySelector(`[data-pt-lon="${idx}"]`);
        if (latEl) latEl.value = (p.lat != null) ? p.lat.toFixed(6) : "";
        if (lonEl) lonEl.value = (p.lon != null) ? p.lon.toFixed(6) : "";
      });
    }

    function restoreFormFromTask(task) {
      if (!task) return;
      const typeSel = document.getElementById("taskType");
      const titleIn = document.getElementById("taskTitle");
      if (typeSel) typeSel.value = task.code;
      if (titleIn) titleIn.value = task.title || "";

      renderTaskFieldsForCode(task.code, task);

      // (Radii/SetDir/Advanced values are embedded via render)
    }

    /********************************************************************
     * Briefing CRUD
     ********************************************************************/
    function briefingNew() {
      STATE.briefing.editorTaskId = null;
      setEditorBadge("Neu");
      const typeSel = document.getElementById("taskType");
      if (typeSel) typeSel.value = "JDG";
      const titleIn = document.getElementById("taskTitle");
      if (titleIn) titleIn.value = "";
      renderTaskFieldsForCode("JDG", null);
      showSnackbar("Neuer Task (Editor).");
    }

    function briefingEdit(id) {
      const t = STATE.briefing.tasks.find(x => x.id === id);
      if (!t) return;
      STATE.briefing.editorTaskId = id;
      setEditorBadge("Edit");
      restoreFormFromTask(t);
      showSnackbar("Task im Editor geladen.");
    }

    function briefingSaveFromEditor() {
      const built = buildTaskFromForm();
      if (!built) { showSnackbar("Task unvollständig."); return; }
      if (built._error) { showSnackbar(built._error); return; }

      const editorId = STATE.briefing.editorTaskId;
      if (editorId) {
        const idx = STATE.briefing.tasks.findIndex(x => x.id === editorId);
        if (idx >= 0) {
          built.id = editorId;
          STATE.briefing.tasks[idx] = built;
          showSnackbar("Briefing-Task aktualisiert.");
        } else {
          STATE.briefing.editorTaskId = null;
          STATE.briefing.tasks.push(built);
          showSnackbar("Briefing-Task gespeichert.");
        }
      } else {
        STATE.briefing.tasks.push(built);
        STATE.briefing.editorTaskId = built.id;
        setEditorBadge("Edit");
        showSnackbar("Briefing-Task gespeichert.");
      }

      persistAll();
      renderBriefingList();
      renderBriefingQuickList();

      // wenn dieser Task als Vorschau gezeigt wird, neu zeichnen
      if (STATE.ui.mapShownTaskId === built.id) drawDisplayedTaskOnMap();
      updatePointDock();
      updateWindDock();
    }

    function briefingDelete(id) {
      const idx = STATE.briefing.tasks.findIndex(x => x.id === id);
      if (idx < 0) return;

      if (STATE.ui.mapShownTaskId === id) STATE.ui.mapShownTaskId = null;
      if (STATE.task.active?.briefingId === id) clearActiveTask();

      if (STATE.briefing.editorTaskId === id) {
        STATE.briefing.editorTaskId = null;
        setEditorBadge("Neu");
      }

      STATE.briefing.tasks.splice(idx, 1);
      persistAll();
      renderBriefingList();
      renderBriefingQuickList();
      drawDisplayedTaskOnMap();
      updatePointDock();
      showSnackbar("Briefing-Task gelöscht.");
    }

    function briefingMove(id, delta) {
      const i = STATE.briefing.tasks.findIndex(x => x.id === id);
      if (i < 0) return;
      const j = i + delta;
      if (j < 0 || j >= STATE.briefing.tasks.length) return;
      const tmp = STATE.briefing.tasks[i];
      STATE.briefing.tasks[i] = STATE.briefing.tasks[j];
      STATE.briefing.tasks[j] = tmp;
      persistAll();
      renderBriefingList();
      renderBriefingQuickList();
    }

    function briefingShowOnMap(id) {
      if (STATE.flight.active) { showSnackbar("Während der Fahrt wird der aktive Task angezeigt."); return; }
      STATE.ui.mapShownTaskId = id;
      drawDisplayedTaskOnMap();
      renderBriefingList();
      updatePointDock();
      showSnackbar("Task-Vorschau auf Karte.");
    }

    function setActiveTaskFromTaskObject(task, briefingId=null) {
      if (!task) return;
      const t = deepClone(task);
      t.briefingId = briefingId || null;
      STATE.task.active = t;

      STATE.ui.mapShownTaskId = null;
      drawDisplayedTaskOnMap();

      setMarkerButtonColor(t.code);
      updateButtons();
      updateWindDock();
      persistAll();

      renderBriefingList();
      renderBriefingQuickList();
      updatePointDock();
    }

    function briefingSetActive(id) {
      const t = STATE.briefing.tasks.find(x => x.id === id);
      if (!t) return;
      setActiveTaskFromTaskObject(t, id);
      showSnackbar("Task ist jetzt aktiv.");
    }

    function clearActiveTask() {
      STATE.task.active = null;
      setMarkerButtonColor("x");
      drawDisplayedTaskOnMap();
      updateButtons();
      updateWindDock();
      persistAll();
      renderBriefingList();
      renderBriefingQuickList();
      updatePointDock();
      showSnackbar("Aktiver Task gelöscht.");
    }

    function cycleToNextTask() {
      const tasks = STATE.briefing.tasks || [];
      if (!tasks.length) { showSnackbar("Keine Briefing-Aufgaben."); return; }
      const activeId = STATE.task.active?.briefingId || null;
      let idx = activeId ? tasks.findIndex(x => x.id === activeId) : -1;
      idx = (idx + 1) % tasks.length;
      briefingSetActive(tasks[idx].id);
    }

    function previewEditorTask() {
      if (STATE.flight.active) { showSnackbar("Während der Fahrt wird der aktive Task angezeigt."); return; }
      const built = buildTaskFromForm();
      if (!built || built._error) { showSnackbar(built? built._error : "Task unvollständig."); return; }
      drawTaskOnMap(built);
      showSnackbar("Editor-Vorschau (nicht gespeichert).");
      updatePointDock();
    }

    function setActiveFromEditor() {
      const built = buildTaskFromForm();
      if (!built || built._error) { showSnackbar(built? built._error : "Task unvollständig."); return; }

      const editorId = STATE.briefing.editorTaskId;
      if (editorId) {
        const t = STATE.briefing.tasks.find(x => x.id === editorId);
        if (t) { briefingSetActive(editorId); return; }
      }
      setActiveTaskFromTaskObject(built, null);
      showSnackbar("Editor-Task als aktiv gesetzt.");
    }

    function clearEditor() {
      STATE.briefing.editorTaskId = null;
      setEditorBadge("Neu");
      briefingNew();
    }

    function showActiveOnMap() {
      STATE.ui.mapShownTaskId = null;
      drawDisplayedTaskOnMap();
      renderBriefingList();
      updatePointDock();
      showSnackbar("Aktiver Task auf Karte.");
    }

    /********************************************************************
     * Point Dock Logic
     ********************************************************************/
    function getDisplayedTaskForPointDock() {
      const src = getDisplayedTaskSource();
      const t = src.get();
      return t ? deepClone(t) : null;
    }

    function updatePointDock() {
      const nameEl = document.getElementById("pointDockTaskName");
      const ptsEl = document.getElementById("pointDockPoints");
      const coordEl = document.getElementById("pointDockCoords");
      if (!nameEl || !ptsEl || !coordEl) return;

      const t = getDisplayedTaskForPointDock();
      if (!t) {
        nameEl.textContent = "Kein Task";
        ptsEl.innerHTML = "";
        coordEl.textContent = "–";
        return;
      }

      nameEl.textContent = `${t.code} — ${t.title || t.typeTitle || ""}`.trim();
      const labels = pointLabelsForTask(t.code, (t.points||[]).length);
      const s = schemaFor(t.code);

      if (s.points === "NONE") {
        ptsEl.innerHTML = `<div class="text-xs text-slate-400">Keine Punkte.</div>`;
        coordEl.textContent = "–";
        return;
      }

      // ensure selected index valid
      STATE.ui.pointSelectedIndex = clamp(STATE.ui.pointSelectedIndex, 0, Math.max(0, labels.length-1));

      ptsEl.innerHTML = labels.map((lab, idx) => {
        const active = idx === STATE.ui.pointSelectedIndex;
        return `
          <button data-pidx="${idx}" class="btn-touch px-3 h-9 rounded-xl border ${active ? "bg-amber-300 text-slate-950 border-amber-200" : "bg-slate-900 text-slate-100 border-slate-800 hover:bg-slate-800"} font-extrabold text-xs">
            ${escapeXml(lab)}
          </button>
        `;
      }).join("");

      ptsEl.querySelectorAll("button[data-pidx]").forEach(b => {
        b.addEventListener("click", (e) => {
          const idx = parseInt(e.currentTarget.getAttribute("data-pidx"), 10);
          if (!Number.isFinite(idx)) return;
          STATE.ui.pointSelectedIndex = idx;
          STATE.ui.mapPickIndex = idx;
          STATE.ui.mapPickLabel = labels[idx] || `P${idx+1}`;
          updatePointDock();
          persistAll();
        });
      });

      // show coords
      const pt = (t.points || [])[STATE.ui.pointSelectedIndex];
      if (pt && isFinite(pt.lat) && isFinite(pt.lon)) coordEl.textContent = `${pt.lat.toFixed(6)}, ${pt.lon.toFixed(6)}`;
      else coordEl.textContent = "–";

      // keep map pick label in sync
      STATE.ui.mapPickIndex = STATE.ui.pointSelectedIndex;
      STATE.ui.mapPickLabel = labels[STATE.ui.pointSelectedIndex] || `P${STATE.ui.pointSelectedIndex+1}`;
    }

    function startPointPick() {
      const t = getDisplayedTaskForPointDock();
      if (!t) { showSnackbar("Kein Task ausgewählt."); return; }
      const s = schemaFor(t.code);
      if (s.points === "NONE") { showSnackbar("Dieser Task hat keine Punkte."); return; }
      STATE.ui.mapPickMode = true;
      const hint = document.getElementById("pointPickHint");
      if (hint) hint.classList.remove("hidden");
      showSnackbar("Jetzt auf die Karte tippen.");
    }

    function cancelPointPick() {
      STATE.ui.mapPickMode = false;
      const hint = document.getElementById("pointPickHint");
      if (hint) hint.classList.add("hidden");
      showSnackbar("Abgebrochen.");
    }

    /********************************************************************
     * ELB helper
     ********************************************************************/
    function setHelperPoint(which) {
      if (!STATE.flight.active) { showSnackbar("Nur während aktiver Fahrt."); return; }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }
      STATE.task.pointsABC[which] = { ...pos };
      showSnackbar(`Punkt ${which} gesetzt.`);
      updateElbowResult();
    }

    function updateElbowResult() {
      const out = document.getElementById("elbowResult");
      if (!out) return;
      const A = STATE.task.pointsABC.A;
      const B = STATE.task.pointsABC.B;
      const C = STATE.task.pointsABC.C;
      if (!A || !B || !C) { out.textContent = "–"; return; }

      const brgBA = bearingDeg(B, A);
      const brgBC = bearingDeg(B, C);
      let ang = angDiffDeg(brgBA, brgBC);
      const res = 180 - ang;
      out.textContent = fmtNum(res, 1);
    }

    /********************************************************************
     * Wind Dock
     ********************************************************************/
    function updateWindDock() {
      const list = document.getElementById("windDockLayers");
      const navName = document.getElementById("windDockNavName");
      const navDist = document.getElementById("windDockNavDist");
      const navBrg  = document.getElementById("windDockNavBrg");
      const navRec  = document.getElementById("windDockNavRec");
      const miniDist = document.getElementById("windDockMiniDist");
      if (!list || !navName || !navDist || !navBrg || !navRec || !miniDist) return;

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM).slice(0, 10);
      if (!items.length) {
        list.innerHTML = `
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 px-3 py-2 text-sm text-slate-400">
            Keine Winddaten.
          </div>
        `;
      } else {
        list.innerHTML = items.map(w => {
          const driftTo = windToDegFrom(w.fromDeg);
          const spd = fmtNum(w.speedKmh,1);
          const alt = Math.round(w.altM);
          const from = Math.round(w.fromDeg);
          const to = Math.round(driftTo);
          return `
            <div class="rounded-2xl bg-slate-900/55 border border-slate-800 px-3 py-2 flex items-center gap-3">
              <div class="w-9 h-9 rounded-2xl bg-slate-950/70 border border-slate-800 grid place-items-center">
                <div style="transform: rotate(${to}deg);" class="text-sky-300">
                  <i class="fa-solid fa-location-arrow"></i>
                </div>
              </div>
              <div class="flex-1 min-w-0">
                <div class="flex items-baseline justify-between gap-2">
                  <div class="font-extrabold mono">${alt} m</div>
                  <div class="font-extrabold mono text-slate-200">${spd} <span class="text-[11px] text-slate-400">km/h</span></div>
                </div>
                <div class="text-[11px] text-slate-400 mono truncate">to ${to}° • from ${from}°</div>
              </div>
            </div>
          `;
        }).join("");
      }

      const t = getActiveTask();
      const pos = getCurrentPos();
      if (!t) {
        navName.textContent = "Kein Task aktiv";
        navDist.textContent = "–";
        navBrg.textContent = "–";
        navRec.textContent = "–";
        miniDist.textContent = "–";
        return;
      }

      navName.textContent = `${t.code} — ${t.title || t.typeTitle}`;
      const target = getPrimaryTarget(t);
      if (!pos || !target) {
        navDist.textContent = "–";
        navBrg.textContent = "–";
        navRec.textContent = !pos ? "Keine Position" : "Kein Ziel";
        miniDist.textContent = "–";
        return;
      }

      const d = haversineM(pos, target);
      const brg = bearingDeg(pos, target);
      navDist.textContent = fmtDist(d);
      navBrg.textContent = `${Math.round(brg)}°`;
      navRec.textContent = recommendLayerText(t, pos, target) || "–";
      miniDist.textContent = fmtDist(d);
    }

    /********************************************************************
     * Wind/Archiv Panels
     ********************************************************************/
    function updateWindPanel() {
      const list = document.getElementById("windList");
      if (!list) return;

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Schichten vorhanden.</div>`;
        return;
      }

      list.innerHTML = items.map((w, idx) => `
        <div class="flex items-center gap-2 rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
          <div class="flex-1">
            <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
            <div class="text-xs text-slate-400 mono">${Math.round(w.fromDeg)}° FROM • ${fmtNum(w.speedKmh,1)} km/h</div>
          </div>
          <button data-widx="${idx}" class="btn-touch btnDelWind h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-trash"></i>
          </button>
        </div>
      `).join("");

      list.querySelectorAll(".btnDelWind").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const idx = parseInt(e.currentTarget.getAttribute("data-widx"), 10);
          if (!Number.isFinite(idx)) return;
          STATE.wind.layers.splice(idx, 1);
          persistAll();
          updateWindPanel();
          updateWindDock();
        });
      });
    }

    function updateArchivePanel() {
      const list = document.getElementById("archiveList");
      if (!list) return;
      const items = [...STATE.flight.archive].sort((a,b)=>b.startedTs-a.startedTs);

      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Noch keine Fahrten im Archiv.</div>`;
        return;
      }

      list.innerHTML = items.map((f) => {
        const dt = new Date(f.startedTs);
        const durMin = f.endedTs ? Math.round((f.endedTs - f.startedTs)/60000) : 0;
        const mCount = (f.markers||[]).length;
        const tCount = (f.track||[]).length;
        return `
          <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div class="flex items-center gap-2">
              <div class="flex-1 min-w-0">
                <div class="font-extrabold truncate">${escapeXml(f.title || "Fahrt")}</div>
                <div class="text-xs text-slate-400">${dt.toLocaleString()} • ${durMin} min • ${tCount} pts • ${mCount} marks</div>
              </div>
              <button data-fid="${f.id}" class="btn-touch btnExport h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-file-arrow-down mr-2"></i>KML
              </button>
            </div>
          </div>
        `;
      }).join("");

      list.querySelectorAll(".btnExport").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const fid = e.currentTarget.getAttribute("data-fid");
          const f = STATE.flight.archive.find(x => x.id === fid);
          if (!f) return;
          exportFlightToKml(f);
        });
      });
    }

    function exportFlightToKml(f) {
      try {
        const name = escapeXml(f.title || APP.kmlName);
        const trackCoords = (f.track || []).map(p => `${p.lon},${p.lat},${p.altM||0}`).join(" ");
        const markerPlacemarks = (f.markers || []).map(m => {
          const when = new Date(m.ts).toISOString();
          return `
            <Placemark>
              <name>${escapeXml(m.label || "MARK")}</name>
              <TimeStamp><when>${when}</when></TimeStamp>
              <Point><coordinates>${m.lon},${m.lat},${m.altM||0}</coordinates></Point>
            </Placemark>
          `;
        }).join("\n");

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Style id="trackStyle"><LineStyle><color>ff4f46e5</color><width>4</width></LineStyle></Style>
    <Placemark>
      <name>Track</name>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>${trackCoords}</coordinates>
      </LineString>
    </Placemark>
    ${markerPlacemarks}
  </Document>
</kml>`;

        const blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const ts = new Date(f.startedTs).toISOString().slice(0,19).replaceAll(":","-");
        a.download = `CompNavAir_${ts}.kml`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
      } catch (e) {
        console.error(e);
        showSnackbar("KML Export fehlgeschlagen.");
      }
    }

    function renderBriefingList() {
      const wrap = document.getElementById("briefingList");
      if (!wrap) return;

      const tasks = STATE.briefing.tasks || [];
      if (!tasks.length) {
        wrap.innerHTML = `<div class="text-sm text-slate-400">Noch keine Aufgaben im Briefing.</div>`;
        return;
      }

      const activeId = STATE.task.active?.briefingId || null;

      wrap.innerHTML = tasks.map((t) => {
        const isActive = activeId && t.id === activeId;
        const isShown = STATE.ui.mapShownTaskId && t.id === STATE.ui.mapShownTaskId;
        const badge = isActive ? `<span class="ml-2 text-[10px] px-2 py-0.5 rounded-full bg-emerald-400 text-slate-950 font-extrabold">aktiv</span>` : "";
        const badge2 = (!isActive && isShown) ? `<span class="ml-2 text-[10px] px-2 py-0.5 rounded-full bg-sky-400 text-slate-950 font-extrabold">Vorschau</span>` : "";

        return `
          <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div class="flex items-start gap-2">
              <div class="flex-1 min-w-0">
                <div class="font-extrabold truncate">
                  ${escapeXml(t.code)} — ${escapeXml(t.title || t.typeTitle || "")}
                  ${badge}${badge2}
                </div>
                <div class="text-xs text-slate-400 mono mt-1 truncate">${escapeXml(taskSummary(t))}</div>
              </div>
              <div class="flex items-center gap-1">
                <button data-act="up" data-id="${t.id}" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="hoch">
                  <i class="fa-solid fa-chevron-up"></i>
                </button>
                <button data-act="down" data-id="${t.id}" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" title="runter">
                  <i class="fa-solid fa-chevron-down"></i>
                </button>
              </div>
            </div>

            <div class="mt-2 grid grid-cols-4 gap-2">
              <button data-act="edit" data-id="${t.id}" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm" title="Edit">
                <i class="fa-solid fa-pen"></i>
              </button>
              <button data-act="show" data-id="${t.id}" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm" title="Vorschau">
                <i class="fa-solid fa-map"></i>
              </button>
              <button data-act="active" data-id="${t.id}" class="btn-touch h-10 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm" title="Als aktiv">
                <i class="fa-solid fa-bullseye"></i>
              </button>
              <button data-act="del" data-id="${t.id}" class="btn-touch h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm" title="Löschen">
                <i class="fa-solid fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      }).join("");

      wrap.querySelectorAll("button[data-act]").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const act = e.currentTarget.getAttribute("data-act");
          const id = e.currentTarget.getAttribute("data-id");
          if (!act || !id) return;
          if (act === "edit") briefingEdit(id);
          else if (act === "show") briefingShowOnMap(id);
          else if (act === "active") briefingSetActive(id);
          else if (act === "del") briefingDelete(id);
          else if (act === "up") briefingMove(id, -1);
          else if (act === "down") briefingMove(id, +1);
        });
      });
    }

    function renderBriefingQuickList() {
      const wrap = document.getElementById("briefingQuickList");
      if (!wrap) return;

      const tasks = STATE.briefing.tasks || [];
      if (!tasks.length) {
        wrap.innerHTML = `<div class="text-sm text-slate-400">Keine Briefing-Aufgaben.</div>`;
        return;
      }

      const activeId = STATE.task.active?.briefingId || null;

      wrap.innerHTML = tasks.map(t => {
        const isActive = activeId && t.id === activeId;
        return `
          <button data-id="${t.id}" class="btn-touch w-full text-left rounded-2xl ${isActive ? "bg-emerald-400 text-slate-950 border-emerald-300" : "bg-slate-950/60 text-slate-100 border-slate-800 hover:bg-slate-900/60"} border px-3 py-2">
            <div class="font-extrabold truncate">${escapeXml(t.code)} — ${escapeXml(t.title || t.typeTitle || "")}</div>
            <div class="text-xs ${isActive ? "text-slate-800" : "text-slate-400"} mono truncate">${escapeXml(taskSummary(t))}</div>
          </button>
        `;
      }).join("");

      wrap.querySelectorAll("button[data-id]").forEach(b => {
        b.addEventListener("click", (e) => {
          const id = e.currentTarget.getAttribute("data-id");
          briefingSetActive(id);
        });
      });
    }

    /********************************************************************
     * Persistenz
     ********************************************************************/
    let _persistT = 0;
    function persistAllThrottled() {
      const t = now();
      if (t - _persistT < 1500) return;
      _persistT = t;
      persistAll();
    }

    function persistAll() {
      try {
        const payload = {
          version: APP.version,
          ui: {
            followGps: STATE.ui.followGps,
            base: STATE.ui.base,
            windDockCollapsed: STATE.ui.windDockCollapsed,
            pointDockCollapsed: STATE.ui.pointDockCollapsed,
            taskSubTab: STATE.ui.taskSubTab,
            showAdvanced: STATE.ui.showAdvanced
          },
          wind: { layers: STATE.wind.layers },
          task: { active: STATE.task.active, aptStartTs: STATE.task.apt.startTs },
          briefing: { title: STATE.briefing.title, tasks: STATE.briefing.tasks },
          flight: {
            active: STATE.flight.active,
            title: STATE.flight.title,
            startedTs: STATE.flight.startedTs,
            track: STATE.flight.track,
            markers: STATE.flight.markers,
            archive: STATE.flight.archive,
          },
          sim: { enabled: STATE.sim.enabled }
        };
        localStorage.setItem(APP.storageKey, JSON.stringify(payload));
      } catch {}
    }

    function restoreAll() {
      try {
        const raw = localStorage.getItem(APP.storageKey);
        if (!raw) return;
        const j = JSON.parse(raw);

        if (j.ui) {
          STATE.ui.followGps = !!j.ui.followGps;
          STATE.ui.base = j.ui.base === "sat" ? "sat" : "osm";
          STATE.ui.windDockCollapsed = !!j.ui.windDockCollapsed;
          STATE.ui.pointDockCollapsed = (j.ui.pointDockCollapsed !== undefined) ? !!j.ui.pointDockCollapsed : true;
          STATE.ui.taskSubTab = (j.ui.taskSubTab === "live") ? "live" : "briefing";
          STATE.ui.showAdvanced = !!j.ui.showAdvanced;
        }
        if (j.wind && Array.isArray(j.wind.layers)) {
          STATE.wind.layers = j.wind.layers.filter(x => x && isFinite(x.altM));
        }
        if (j.task) {
          STATE.task.active = j.task.active || null;
          STATE.task.apt.startTs = j.task.aptStartTs || null;
        }
        if (j.briefing) {
          STATE.briefing.title = (j.briefing.title || "");
          if (Array.isArray(j.briefing.tasks)) STATE.briefing.tasks = j.briefing.tasks.filter(x => x && x.id && x.code);
        }
        if (j.flight) {
          STATE.flight.active = !!j.flight.active;
          STATE.flight.title = j.flight.title || "";
          STATE.flight.startedTs = j.flight.startedTs || 0;
          STATE.flight.track = Array.isArray(j.flight.track) ? j.flight.track : [];
          STATE.flight.markers = Array.isArray(j.flight.markers) ? j.flight.markers : [];
          STATE.flight.archive = Array.isArray(j.flight.archive) ? j.flight.archive : [];
        }
        if (j.sim) STATE.sim.enabled = !!j.sim.enabled;
      } catch {}
    }

    /********************************************************************
     * 6) EVENT-LISTENER & INITIALISIERUNG (window.onload am Ende)
     ********************************************************************/
    window.onload = () => {
      initManifestAndSW();
      restoreAll();

      initMap();
      setBaseLayer(STATE.ui.base);

      renderTaskTypeOptions();

      // Briefing title restore
      const bt = document.getElementById("briefingTitle");
      if (bt) bt.value = STATE.briefing.title || "";

      // Editor initial render
      const initialCode = document.getElementById("taskType")?.value || "JDG";
      renderTaskFieldsForCode(initialCode, null);
      setEditorMarkerBadge(initialCode);

      // Marker-Button Farbe nach aktivem Task
      if (STATE.task.active) setMarkerButtonColor(STATE.task.active.code);
      else setMarkerButtonColor("x");

      // Track/Marker Restore
      if (STATE.flight.active) {
        try {
          const latlngs = (STATE.flight.track||[]).map(p => [p.lat,p.lon]);
          STATE.layers.trackLine?.setLatLngs(latlngs);
        } catch {}
        try {
          (STATE.flight.markers||[]).forEach(m => {
            const color = COLOR_HEX[m.color] || COLOR_HEX.pink;
            L.circleMarker([m.lat,m.lon], { radius:8, color, weight:3, fillColor:color, fillOpacity:0.25, interactive:false })
              .addTo(STATE.layers.markersLayer);
          });
        } catch {}
      }

      drawDisplayedTaskOnMap();

      updateGpsBadge();
      updateButtons();
      updateInstruments();
      updateWindPanel();
      updateArchivePanel();
      updateElbowResult();
      updateFollowToggleUi();
      updateWindDockVisibility();
      updateWindDock();
      updatePointDockVisibility();
      updatePointDock();
      updateDrawerTabUi();
      updateActiveTaskCard();

      // Tabs
      document.querySelectorAll(".tabBtn").forEach(b => {
        b.addEventListener("click", () => {
          STATE.ui.drawerTab = b.getAttribute("data-tab");
          updateDrawerTabUi();
        });
      });

      // Drawer open/close
      document.getElementById("btnMenu")?.addEventListener("click", () => openDrawer(true));
      document.getElementById("btnDrawerClose")?.addEventListener("click", () => openDrawer(false));
      document.getElementById("drawerBg")?.addEventListener("click", () => openDrawer(false));

      // Task sub tabs
      document.getElementById("btnTaskSubBriefing")?.addEventListener("click", () => setTaskSubTab("briefing"));
      document.getElementById("btnTaskSubLive")?.addEventListener("click", () => setTaskSubTab("live"));

      // Briefing title input
      document.getElementById("briefingTitle")?.addEventListener("input", (e) => {
        STATE.briefing.title = e.target.value || "";
        persistAllThrottled();
      });

      // Briefing buttons
      document.getElementById("btnBriefingNew")?.addEventListener("click", briefingNew);
      document.getElementById("btnSaveBriefing")?.addEventListener("click", briefingSaveFromEditor);
      document.getElementById("btnPreviewTask")?.addEventListener("click", previewEditorTask);
      document.getElementById("btnSetActiveFromEditor")?.addEventListener("click", setActiveFromEditor);
      document.getElementById("btnClearEditor")?.addEventListener("click", clearEditor);
      document.getElementById("btnShowActiveOnMap")?.addEventListener("click", showActiveOnMap);

      // Live buttons
      document.getElementById("btnClearActive")?.addEventListener("click", clearActiveTask);
      document.getElementById("btnCycleTask")?.addEventListener("click", cycleToNextTask);

      // Wind dock toggle
      document.getElementById("btnWindHud")?.addEventListener("click", toggleWindDock);
      document.getElementById("btnWindDockCollapse")?.addEventListener("click", toggleWindDock);
      document.getElementById("btnWindDockExpand")?.addEventListener("click", toggleWindDock);
      document.getElementById("btnWindFetch")?.addEventListener("click", fetchWindFromOpenMeteo);
      document.getElementById("btnWindDockFetchMini")?.addEventListener("click", fetchWindFromOpenMeteo);

      // Point dock toggle (header + dock buttons)
      document.getElementById("btnPointDock")?.addEventListener("click", () => togglePointDock());
      document.getElementById("btnPointDockExpand")?.addEventListener("click", () => togglePointDock(true));
      document.getElementById("btnPointDockCollapse")?.addEventListener("click", () => togglePointDock(false));
      document.getElementById("btnPointPick")?.addEventListener("click", startPointPick);
      document.getElementById("btnPointCancelPick")?.addEventListener("click", cancelPointPick);

      // Map settings
      document.getElementById("btnMapSettings")?.addEventListener("click", () => openMapModal(true));
      document.getElementById("btnMapModalClose")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("mapModalBg")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("btnBaseOSM")?.addEventListener("click", () => { setBaseLayer("osm"); persistAll(); });
      document.getElementById("btnBaseSAT")?.addEventListener("click", () => { setBaseLayer("sat"); persistAll(); });

      document.getElementById("btnCenter")?.addEventListener("click", centerOnPos);

      // Follow toggle
      document.getElementById("tglFollow")?.addEventListener("change", (e) => {
        STATE.ui.followGps = !!e.target.checked;
        updateFollowToggleUi();
        persistAll();
      });

      // Flight controls (nicht automatisch)
      document.getElementById("btnStartFlight")?.addEventListener("click", beginFlight);
      document.getElementById("btnFinish")?.addEventListener("click", finishFlight);

      // Marker
      document.getElementById("btnMarker")?.addEventListener("click", dropMarker);

      // Task type change -> rerender only necessary fields
      document.getElementById("taskType")?.addEventListener("change", (e) => {
        const code = e.target.value;
        renderTaskFieldsForCode(code, null);
        setEditorMarkerBadge(code);
        persistAllThrottled();
        updatePointDock();
      });

      // ELB helper
      document.getElementById("btnSetA")?.addEventListener("click", () => setHelperPoint("A"));
      document.getElementById("btnSetB")?.addEventListener("click", () => setHelperPoint("B"));
      document.getElementById("btnSetC")?.addEventListener("click", () => setHelperPoint("C"));

      // Wind panel add/clear
      document.getElementById("btnAddWind")?.addEventListener("click", () => {
        const alt = safeFloat(document.getElementById("windAlt")?.value, null);
        const dir = safeFloat(document.getElementById("windDirFrom")?.value, null);
        const spd = safeFloat(document.getElementById("windSpd")?.value, null);
        if (alt == null || dir == null || spd == null) { showSnackbar("Wind: Werte fehlen."); return; }
        addWindLayer({ altM: alt, fromDeg: dir, speedKmh: spd, ts: now(), source: "manual" });
      });
      document.getElementById("btnClearWind")?.addEventListener("click", () => {
        STATE.wind.layers = [];
        persistAll();
        updateWindPanel();
        updateWindDock();
        showSnackbar("Wind gelöscht.");
      });

      // Setup: Simulation toggle (kept minimal)
      const tglSim = document.getElementById("tglSim");
      const knobSim = document.getElementById("tglSimKnob");
      if (tglSim && knobSim) setToggleUI(tglSim, knobSim, STATE.sim.enabled);
      tglSim?.addEventListener("change", (e) => {
        if (tglSim && knobSim) setToggleUI(tglSim, knobSim, e.target.checked);
        STATE.sim.enabled = !!e.target.checked;
        showSnackbar("Simulation ist in dieser Version UI-only (GPS bleibt).");
        persistAll();
        updateButtons();
      });

      // WakeLock (optional)
      document.getElementById("btnWakeLock")?.addEventListener("click", async () => {
        try {
          if (!("wakeLock" in navigator)) { showSnackbar("Wake Lock nicht unterstützt."); return; }
          STATE.ui.wakeLock = await navigator.wakeLock.request("screen");
          showSnackbar("Wake Lock aktiv.");
        } catch (e) {
          console.warn(e);
          showSnackbar("Wake Lock fehlgeschlagen.");
        }
      });

      document.getElementById("btnReset")?.addEventListener("click", () => {
        STATE.ui.followGps = true;
        updateFollowToggleUi();
        showSnackbar("UI zurückgesetzt.");
        persistAll();
        updateWindDock();
      });

      // KML import
      document.getElementById("kmlFile")?.addEventListener("change", (e) => {
        const f = e.target.files?.[0];
        importKmlFile(f);
      });

      // Archive clear
      document.getElementById("btnClearArchive")?.addEventListener("click", () => {
        STATE.flight.archive = [];
        persistAll();
        updateArchivePanel();
        showSnackbar("Archiv gelöscht.");
      });

      // Start GPS
      initGPS();

      // Initial briefing UI
      renderBriefingList();
      renderBriefingQuickList();
      setTaskSubTab(STATE.ui.taskSubTab);

      // Default briefing title if empty
      if (!STATE.briefing.title) {
        STATE.briefing.title = "Morgenfahrt";
        if (bt) bt.value = STATE.briefing.title;
        persistAllThrottled();
      }
    };

    function importKmlFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const txt = String(reader.result || "");
          if (STATE.layers.kmlLayer) {
            try { STATE.map.removeLayer(STATE.layers.kmlLayer); } catch {}
            STATE.layers.kmlLayer = null;
          }
          const layer = omnivore.kml.parse(txt);
          layer.eachLayer(l => { if (l && typeof l.options === "object") l.options.interactive = false; });
          layer.addTo(STATE.map);
          STATE.layers.kmlLayer = layer;
          showSnackbar("KML importiert.");
        } catch (e) {
          console.error(e);
          showSnackbar("KML Import fehlgeschlagen.");
        }
      };
      reader.readAsText(file);
    }
  </script>
</body>
</html>
