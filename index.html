<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-950">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no, viewport-fit=cover" />
  <meta name="theme-color" content="#020617" />
  <meta name="mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <title>CompNavAir</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <!-- Leaflet Omnivore (KML import) -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- FontAwesome (UI Icons only) -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css"/>

  <style>
    html, body { height: 100%; }
    body { margin: 0; overflow: hidden; -webkit-tap-highlight-color: transparent; }
    .no-select { user-select: none; -webkit-user-select: none; }
    .safe-bottom { padding-bottom: calc(env(safe-area-inset-bottom) + 0px); }
    .safe-top { padding-top: env(safe-area-inset-top); }
    #map { height: 100%; width: 100%; }
    .leaflet-container { background: #0b1220; }
    .btn-touch { touch-action: manipulation; }
    .shadow-soft { box-shadow: 0 12px 30px rgba(0,0,0,.35); }
    .panel-scroll { max-height: calc(100vh - 7.5rem); overflow: auto; -webkit-overflow-scrolling: touch; }
    .mono { font-variant-numeric: tabular-nums; font-feature-settings: "tnum" 1; }
    .leaflet-control-container { z-index: 10; }

    /* Waypoint X marker */
    .wp-x {
      width: 22px; height: 22px;
      display: grid; place-items: center;
      border-radius: 9999px;
      background: rgba(2,6,23,.75);
      border: 2px solid rgba(251,191,36,.95);
      color: rgba(251,191,36,.95);
      font-weight: 900;
      font-size: 14px;
      line-height: 1;
      box-shadow: 0 8px 18px rgba(0,0,0,.35);
      pointer-events: none;
    }
  </style>
</head>

<body class="h-full text-slate-100">
  <div id="app" class="h-full w-full flex flex-col bg-slate-950">
    <!-- Header -->
    <header class="safe-top z-40 bg-slate-950/90 backdrop-blur border-b border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-2xl bg-slate-900 border border-slate-800 grid place-items-center">
            <i class="fa-solid fa-balloon text-sky-300"></i>
          </div>
          <div class="min-w-0">
            <div class="font-extrabold leading-5 truncate">CompNavAir</div>
            <div class="text-xs text-slate-400 leading-4 truncate">
              <span id="gpsBadge" class="inline-flex items-center gap-1">
                <span id="gpsDot" class="w-2 h-2 rounded-full bg-slate-500 inline-block"></span>
                <span id="gpsText">GPS: –</span>
              </span>
              <span class="mx-2 text-slate-600">•</span>
              <span id="modeText">LIVE</span>
            </div>
          </div>
        </div>

        <div class="ml-auto flex items-center gap-2">
          <button id="btnStartFlight" class="btn-touch h-10 px-3 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-play mr-2"></i>Start
          </button>
          <button id="btnFinish" class="btn-touch hidden h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
            <i class="fa-solid fa-flag-checkered mr-2"></i>Fertig
          </button>

          <button id="btnWindHud" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-wind text-slate-200"></i>
          </button>

          <button id="btnMapSettings" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-layer-group text-slate-200"></i>
          </button>

          <button id="btnCenter" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-location-crosshairs text-slate-200"></i>
          </button>

          <button id="btnMenu" class="btn-touch h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-bars text-slate-200"></i>
          </button>
        </div>
      </div>
    </header>

    <!-- Main -->
    <main class="relative flex-1 min-h-0">
      <div id="map" class="absolute inset-0 z-0"></div>

      <!-- Wind HUD -->
      <div id="windHud" class="hidden absolute left-3 top-3 z-50 w-[86vw] max-w-[360px] rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft">
        <div class="px-3 py-2 flex items-center gap-2 border-b border-slate-800">
          <div class="font-bold"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Wind HUD</div>
          <div class="ml-auto flex items-center gap-2">
            <button id="btnWindFetch" class="btn-touch px-3 h-9 rounded-xl bg-sky-400 text-slate-950 font-extrabold text-sm hover:bg-sky-300 active:bg-sky-500">
              <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Online
            </button>
            <button id="btnWindClose" class="btn-touch h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
        </div>
        <div class="px-3 py-2">
          <div class="text-xs text-slate-400 mb-2">Schichten (Höhe / Richtung / Speed)</div>
          <div id="windHudList" class="space-y-2"></div>
        </div>
      </div>

      <!-- Nav Toast (Task oder Waypoint) -->
      <div id="navToast" class="hidden absolute left-1/2 top-3 -translate-x-1/2 z-50 rounded-2xl bg-slate-950/80 backdrop-blur border border-slate-800 shadow-soft px-4 py-2 max-w-[92vw]">
        <div class="text-sm font-bold truncate">
          <i id="navIcon" class="fa-solid fa-route mr-2 text-emerald-300"></i>
          <span id="navTitle">–</span>
        </div>
        <div class="text-xs text-slate-300 mt-0.5">
          <span class="mono" id="navLine1">–</span>
          <span class="mx-2 text-slate-600">•</span>
          <span id="navLine2">–</span>
        </div>
      </div>

      <!-- Simulation Controls -->
      <div id="simControls" class="hidden absolute left-3 top-24 z-50 flex flex-col gap-2">
        <button id="btnBurner" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-orange-400 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-fire-flame-curved mr-2"></i>AUF
        </button>
        <button id="btnVent" class="btn-touch select-none no-select w-28 h-16 rounded-2xl bg-sky-300 text-slate-950 font-extrabold shadow-soft active:scale-[0.99]">
          <i class="fa-solid fa-arrow-down-wide-short mr-2"></i>AB
        </button>
      </div>

      <!-- Map Settings Modal -->
      <div id="mapModal" class="hidden absolute inset-0 z-50">
        <div id="mapModalBg" class="absolute inset-0 bg-black/60"></div>
        <div class="absolute left-1/2 top-24 -translate-x-1/2 w-[92vw] max-w-[420px] rounded-2xl bg-slate-950 border border-slate-800 shadow-soft">
          <div class="px-4 py-3 flex items-center border-b border-slate-800">
            <div class="font-extrabold"><i class="fa-solid fa-layer-group mr-2 text-sky-300"></i>Karte</div>
            <button id="btnMapModalClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
              <i class="fa-solid fa-xmark"></i>
            </button>
          </div>
          <div class="p-4 space-y-3">
            <div class="grid grid-cols-2 gap-2">
              <button id="btnBaseOSM" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-map mr-2"></i>OSM
              </button>
              <button id="btnBaseSAT" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold">
                <i class="fa-solid fa-satellite mr-2"></i>Sat
              </button>
            </div>
            <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">GPS Follow</div>
                <div class="text-xs text-slate-400">Wenn du die Karte ziehst, wird Follow automatisch aus.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglFollow" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglFollowKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>
          </div>
        </div>
      </div>

      <!-- Snackbar -->
      <div id="snackbar" class="hidden absolute left-1/2 bottom-24 -translate-x-1/2 z-50 max-w-[92vw] rounded-2xl bg-slate-950/90 border border-slate-800 shadow-soft px-4 py-2 text-sm"></div>
    </main>

    <!-- Footer Cockpit -->
    <footer class="safe-bottom z-40 bg-slate-950/95 backdrop-blur border-t border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex-1 grid grid-cols-3 gap-2">
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">GS</div>
            <div class="text-lg font-extrabold mono"><span id="instGS">–</span> <span class="text-xs font-bold text-slate-400">km/h</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">ALT</div>
            <div class="text-lg font-extrabold mono"><span id="instALT">–</span> <span class="text-xs font-bold text-slate-400">m</span></div>
          </div>
          <div class="rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="text-[11px] text-slate-400">VARIO</div>
            <div class="text-lg font-extrabold mono"><span id="instVAR">–</span> <span class="text-xs font-bold text-slate-400">m/s</span></div>
          </div>
        </div>

        <button id="btnMarker" class="btn-touch w-20 h-16 rounded-2xl bg-pink-400 hover:bg-pink-300 active:bg-pink-500 text-slate-950 font-extrabold shadow-soft">
          <i class="fa-solid fa-location-dot mr-2"></i>MARK
        </button>
      </div>
    </footer>
  </div>

  <!-- Side Drawer -->
  <div id="drawerWrap" class="hidden fixed inset-0 z-[70]">
    <div id="drawerBg" class="absolute inset-0 bg-black/60"></div>
    <aside id="drawer" class="absolute right-0 top-0 h-full w-[92vw] max-w-[420px] bg-slate-950 border-l border-slate-800 shadow-soft flex flex-col">
      <div class="safe-top px-4 py-3 flex items-center border-b border-slate-800">
        <div class="font-extrabold"><i class="fa-solid fa-compass mr-2 text-sky-300"></i>Menü</div>
        <button id="btnDrawerClose" class="ml-auto h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 btn-touch">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>

      <div class="px-3 py-2 border-b border-slate-800">
        <div class="grid grid-cols-4 gap-2">
          <button data-tab="task" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Task</button>
          <button data-tab="wind" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Wind</button>
          <button data-tab="setup" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Setup</button>
          <button data-tab="archive" class="btn-touch tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Archiv</button>
        </div>
      </div>

      <div class="px-4 py-3 panel-scroll">
        <!-- TASK -->
        <section id="tab_task" class="space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-flag mr-2 text-emerald-300"></i>Aktiver Task (Briefing)</div>

            <label class="text-xs text-slate-400">Task-Typ</label>
            <select id="taskType" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 font-bold"></select>

            <label class="text-xs text-slate-400 mt-3 block">Task-Titel (optional)</label>
            <input id="taskTitle" type="text" placeholder="z.B. Abendfahrt JDG" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3" />

            <div id="taskFields" class="mt-3 space-y-3"></div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnApplyTask" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-check mr-2"></i>Auf Karte
              </button>
              <button id="btnClearTask" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Leeren
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold text-sm mb-1"><i class="fa-solid fa-hand-pointer mr-2 text-sky-300"></i>Karte tippen</div>
              <div id="mapPickHint" class="hidden text-xs text-amber-300">
                Tippe auf die Karte, um Punkt A zu setzen (Briefing).
              </div>
              <div class="text-xs text-slate-400 mt-2">
                Tipp: <span class="font-bold">Langer Klick</span> auf die Karte erstellt einen <span class="font-bold">freien Waypoint</span> (ohne Task).
              </div>
            </div>
          </div>

          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-diagram-project mr-2 text-sky-300"></i>ELB Helper</div>
            <div class="text-xs text-slate-400 mb-3">Nur während aktiver Fahrt.</div>
            <div class="grid grid-cols-3 gap-2">
              <button id="btnSetA" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set A</button>
              <button id="btnSetB" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set B</button>
              <button id="btnSetC" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">Set C</button>
            </div>
            <div class="mt-3 text-sm">
              <div class="text-xs text-slate-400">ELB Ergebnis (°):</div>
              <div class="font-extrabold mono text-lg" id="elbowResult">–</div>
            </div>
          </div>
        </section>

        <!-- WIND -->
        <section id="tab_wind" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-wind mr-2 text-sky-300"></i>Windprofil</div>
            <div class="text-xs text-slate-400 mb-3">Manuell editieren oder Online holen. Auto-Record: GS &gt; 10 km/h &amp;&amp; (ΔH&gt;50 m oder ΔKurs&gt;5°) — nur während Fahrt.</div>

            <div class="grid grid-cols-3 gap-2">
              <input id="windAlt" type="number" placeholder="Höhe m" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windDirFrom" type="number" placeholder="Richtung FROM °" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
              <input id="windSpd" type="number" placeholder="Speed km/h" class="h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" />
            </div>
            <div class="mt-2 grid grid-cols-2 gap-2">
              <button id="btnAddWind" class="btn-touch h-11 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>Hinzufügen
              </button>
              <button id="btnClearWind" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-trash mr-2"></i>Alle löschen
              </button>
            </div>

            <div class="mt-3 space-y-2" id="windList"></div>
          </div>
        </section>

        <!-- SETUP -->
        <section id="tab_setup" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-gear mr-2 text-sky-300"></i>Setup</div>

            <div class="flex items-center justify-between rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
              <div>
                <div class="font-bold">Simulation</div>
                <div class="text-xs text-slate-400">GPS wird pausiert. Drift basiert auf Windprofil.</div>
              </div>
              <label class="inline-flex items-center cursor-pointer">
                <input id="tglSim" type="checkbox" class="sr-only" />
                <div class="w-12 h-7 bg-slate-700 rounded-full relative">
                  <div id="tglSimKnob" class="absolute top-1 left-1 w-5 h-5 rounded-full bg-slate-200 transition-all"></div>
                </div>
              </label>
            </div>

            <div class="mt-3 grid grid-cols-2 gap-2">
              <button id="btnWakeLock" class="btn-touch h-11 rounded-xl bg-sky-400 hover:bg-sky-300 active:bg-sky-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-mobile-screen mr-2"></i>WakeLock
              </button>
              <button id="btnResetUi" class="btn-touch h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
                <i class="fa-solid fa-rotate mr-2"></i>Reset UI
              </button>
            </div>

            <div class="mt-3 grid grid-cols-1 gap-2">
              <button id="btnClearWaypoint" class="btn-touch h-11 w-full rounded-xl bg-amber-300 hover:bg-amber-200 active:bg-amber-400 text-slate-950 font-extrabold">
                <i class="fa-solid fa-xmark mr-2"></i>Waypoint löschen
              </button>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-file-import mr-2 text-emerald-300"></i>KML Import</div>
              <input id="kmlFile" type="file" accept=".kml,.xml" class="block w-full text-sm text-slate-300 file:mr-4 file:py-2 file:px-4 file:rounded-xl file:border-0 file:text-sm file:font-bold file:bg-slate-900 file:text-slate-200 hover:file:bg-slate-800" />
              <div class="text-xs text-slate-400 mt-2">Importiertes KML wird als Overlay dargestellt (nur Ansicht).</div>
            </div>

            <div class="mt-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
              <div class="font-bold mb-2"><i class="fa-solid fa-download mr-2 text-amber-300"></i>PWA Hinweis</div>
              <div class="text-xs text-slate-400">
                Für „ohne Browser“-Look: im Chrome-Menü „Zum Startbildschirm hinzufügen“ → App öffnen.
              </div>
            </div>
          </div>
        </section>

        <!-- ARCHIVE -->
        <section id="tab_archive" class="hidden space-y-4">
          <div class="rounded-2xl bg-slate-900/50 border border-slate-800 p-3">
            <div class="font-extrabold mb-2"><i class="fa-solid fa-box-archive mr-2 text-sky-300"></i>Archiv</div>
            <div class="text-xs text-slate-400 mb-3">Beendete Fahrten + KML Export (Track + Marker).</div>
            <div id="archiveList" class="space-y-2"></div>
            <button id="btnClearArchive" class="btn-touch mt-3 w-full h-11 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-extrabold">
              <i class="fa-solid fa-trash mr-2"></i>Archiv löschen
            </button>
          </div>
        </section>
      </div>
    </aside>
  </div>

  <script>
    /********************************************************************
     * 1) KONSTANTEN & KONFIGURATION
     ********************************************************************/
    const APP = {
      name: "CompNavAir",
      version: "1.2.0",
      defaultCenter: { lat: 49.317, lon: 8.448 }, // Speyer/EDRY
      defaultZoom: 13,
      storageKey: "compnavair_v1_2",
      maxTrackPoints: 20000,
      trackMinDistM: 8,
      maxGpsJumpM: 160,
      gpsSmoothingAlpha: 0.25,
      followPanMinMs: 800,
      longPressMs: 650,
      longPressMovePx: 10,
    };

    const TILE = {
      osm: { url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", attr: '&copy; OpenStreetMap-Mitwirkende' },
      esri:{ url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}", attr: "Tiles &copy; Esri" }
    };

    const CIA_TASKS = [
      { num: "15.1",  code: "PDG", title: "SELBST GEWÄHLTES ZIEL" },
      { num: "15.2",  code: "JDG", title: "VORGEGEBENES ZIEL" },
      { num: "15.3",  code: "HWZ", title: "QUAL DER WAHL" },
      { num: "15.4",  code: "FIN", title: "FLY IN" },
      { num: "15.5",  code: "FON", title: "FLY ON" },
      { num: "15.6",  code: "HNH", title: "FUCHSJAGD" },
      { num: "15.7",  code: "WSD", title: "FUCHSJAGD MIT ANLAUF" },
      { num: "15.8",  code: "GBM", title: "GORDON BENNETT MEMORIAL" },
      { num: "15.9",  code: "CRT", title: "ZIELFAHRT MIT ZEITFENSTER" },
      { num: "15.10", code: "RTA", title: "RENNEN ZUM WERTUNGSGEBIET" },
      { num: "15.11", code: "ELB", title: "ELLENBOGEN" },
      { num: "15.12", code: "LRN", title: "DREIECKSFLÄCHE" },
      { num: "15.13", code: "MDT", title: "MINIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.14", code: "SFL", title: "MINIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.15", code: "MDD", title: "MINIMUM DISTANCE ZWEI MARKER" },
      { num: "15.16", code: "XDT", title: "MAXIMUM DISTANCE MIT ZEITVORGABE" },
      { num: "15.17", code: "XDI", title: "MAXIMUM DISTANCE MIT WERTUNGSGEBIET" },
      { num: "15.18", code: "XDD", title: "MAXIMUM DISTANCE ZWEI MARKER" },
      { num: "15.19", code: "ANG", title: "WINKEL" },
      { num: "15.20", code: "3DT", title: "3D-AUFGABE" },
      { num: "15.21", code: "APT", title: "HÖHENPROFIL-AUFGABE" },
    ];

    const MARKER_COLORS = ["pink","amber","emerald","sky","violet","rose","lime","orange"];
    const COLOR_HEX = {
      pink:"#fb7185", amber:"#fbbf24", emerald:"#34d399", sky:"#38bdf8",
      violet:"#a78bfa", rose:"#f43f5e", lime:"#a3e635", orange:"#fb923c",
    };

    /********************************************************************
     * 2) GLOBALE VARIABLEN (STATE)
     ********************************************************************/
    const STATE = {
      map: null,
      layers: {
        baseOSM: null,
        baseSAT: null,
        tasksLayer: null,
        trackLayer: null,
        markersLayer: null,
        pickLayer: null,
        waypointLayer: null,
        trajectoryLayer: null,
        kmlLayer: null,
        trackLine: null,
      },
      ui: {
        drawerOpen: false,
        drawerTab: "task",
        followGps: true,
        base: "osm",
        windHudOpen: false,

        mapPickMode: false,
        mapPickWhich: "A",
        pickMarkers: { A:null, B:null, C:null },

        snackbarTimer: null,
        wakeLock: null,
        mapUserInteracting: false,

        longPress: {
          active: false,
          timer: null,
          pointerId: null,
          startX: 0,
          startY: 0,
          startLatLng: null,
        },
      },
      gps: {
        watchId: null,
        hasFix: false,
        fixTs: 0,
        lat: null,
        lon: null,
        altM: null,
        speedKmh: 0,
        headingDeg: null,
        accuracyM: null,
        smoothLat: null,
        smoothLon: null,
        lastAltM: null,
        lastAltTs: null,
        lastPanTs: 0,
        lastCourseDeg: null,
      },
      sim: {
        enabled: false,
        running: false,
        lat: null,
        lon: null,
        altM: 180,
        headingDeg: 0,
        speedKmh: 0,
        vRateMps: 0,
        timer: null,
        lastTickTs: 0,
      },
      flight: {
        active: false,
        title: "",
        startedTs: 0,
        track: [],
        markers: [],
        archive: [],
      },
      wind: {
        layers: [], // { altM, fromDeg, speedKmh, ts, source }
        lastAuto: { altM: null, courseDeg: null, ts: 0 },
      },
      task: {
        active: null,
        pointsABC: { A:null, B:null, C:null },
        apt: { startTs: null },
      },
      waypoint: {
        active: null, // {lat, lon, ts}
        marker: null,
        lineToWp: null,
        headingLine: null,
        closestX: null,
      },
      balloon: {
        marker: null,
        el: null, // rotation element
      },
    };

    /********************************************************************
     * 3) HELFER-FUNKTIONEN (Math, Formatting)
     ********************************************************************/
    function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
    function now() { return Date.now(); }
    function toRad(deg) { return deg * Math.PI / 180; }
    function toDeg(rad) { return rad * 180 / Math.PI; }

    function haversineM(a, b) {
      const R = 6371000;
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLat = toRad(b.lat - a.lat);
      const dLon = toRad(b.lon - a.lon);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      return 2 * R * Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
    }

    function bearingDeg(a, b) {
      const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
      const dLon = toRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return (toDeg(Math.atan2(y, x)) + 360) % 360;
    }

    function destPoint(a, bearingDegVal, distM) {
      const R = 6371000;
      const brng = toRad(bearingDegVal);
      const lat1 = toRad(a.lat);
      const lon1 = toRad(a.lon);
      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(distM/R) + Math.cos(lat1)*Math.sin(distM/R)*Math.cos(brng));
      const lon2 = lon1 + Math.atan2(Math.sin(brng)*Math.sin(distM/R)*Math.cos(lat1), Math.cos(distM/R)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: toDeg(lat2), lon: ((toDeg(lon2)+540)%360)-180 };
    }

    function angDiffDeg(a, b) {
      let d = ((a - b + 540) % 360) - 180;
      return Math.abs(d);
    }

    function fmtDist(m) {
      if (m == null || !isFinite(m)) return "–";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }

    function fmtNum(n, digits=0) {
      if (n == null || !isFinite(n)) return "–";
      return n.toFixed(digits);
    }

    function fmtTime(sec) {
      if (sec == null || !isFinite(sec) || sec < 0) return "–";
      const s = Math.round(sec);
      const m = Math.floor(s / 60);
      const r = s % 60;
      if (m < 60) return `${String(m).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
      const h = Math.floor(m / 60);
      const mm = m % 60;
      return `${h}:${String(mm).padStart(2,"0")}:${String(r).padStart(2,"0")}`;
    }

    function safeFloat(v, fallback=null) {
      const n = parseFloat(String(v ?? "").replace(",", "."));
      return Number.isFinite(n) ? n : fallback;
    }

    function smooth(prev, next, alpha) {
      if (prev == null || !isFinite(prev)) return next;
      return prev + alpha * (next - prev);
    }

    function windToDegFrom(fromDeg) { return (fromDeg + 180) % 360; }

    function uid() { return Math.random().toString(36).slice(2, 10); }

    function escapeXml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&apos;");
    }

    function hashStr(s) {
      let h = 0;
      for (let i=0;i<s.length;i++) h = ((h<<5)-h) + s.charCodeAt(i) | 0;
      return h;
    }

    function showSnackbar(msg, ms=2200) {
      const el = document.getElementById("snackbar");
      if (!el) return;
      el.textContent = msg;
      el.classList.remove("hidden");
      clearTimeout(STATE.ui.snackbarTimer);
      STATE.ui.snackbarTimer = setTimeout(() => el.classList.add("hidden"), ms);
    }

    function setToggleUI(inputEl, knobEl, on) {
      inputEl.checked = !!on;
      knobEl.style.left = on ? "1.6rem" : "0.25rem";
      knobEl.style.background = on ? "#34d399" : "#e2e8f0";
    }

    function getCurrentPos() {
      if (STATE.sim.enabled && STATE.sim.lat != null && STATE.sim.lon != null) return { lat: STATE.sim.lat, lon: STATE.sim.lon };
      if (!STATE.gps.hasFix || STATE.gps.lat == null || STATE.gps.lon == null) return null;
      return { lat: STATE.gps.lat, lon: STATE.gps.lon };
    }

    function getCurrentAltM() {
      if (STATE.sim.enabled) return STATE.sim.altM;
      return STATE.gps.altM;
    }

    function getGroundSpeedMps() {
      const kmh = STATE.sim.enabled ? (STATE.sim.speedKmh || 0) : (STATE.gps.speedKmh || 0);
      return Math.max(0, kmh) / 3.6;
    }

    function getCourseDeg() {
      // Prefer sim heading
      if (STATE.sim.enabled) return (STATE.sim.headingDeg ?? 0);

      // Use GPS heading if plausible
      const h = STATE.gps.headingDeg;
      const gs = STATE.gps.speedKmh || 0;
      if (h != null && isFinite(h) && gs >= 3) return ((h % 360) + 360) % 360;

      // Derive from last 2 track points (even if flight not active: use last smoothed positions)
      // Fallback using lastCourseDeg if set
      if (STATE.gps.lastCourseDeg != null) return STATE.gps.lastCourseDeg;

      return 0;
    }

    // Project waypoint onto heading ray from current position (local tangent approx)
    function projectOntoHeadingRay(pos, headingDegVal, wp) {
      const R = 6371000;
      const lat0 = toRad(pos.lat);
      const cosLat = Math.cos(lat0);

      const dx = toRad(wp.lon - pos.lon) * R * cosLat; // east meters
      const dy = toRad(wp.lat - pos.lat) * R;          // north meters

      const h = toRad(headingDegVal);
      const ux = Math.sin(h);
      const uy = Math.cos(h);

      const s = dx*ux + dy*uy;          // along-track meters
      const sClamped = Math.max(0, s);  // only forward
      const px = ux * sClamped;
      const py = uy * sClamped;

      const offx = dx - px;
      const offy = dy - py;
      const dca = Math.hypot(offx, offy);

      const latP = pos.lat + toDeg(py / R);
      const lonP = pos.lon + toDeg(px / (R * cosLat));

      return { alongM: sClamped, dcaM: dca, closest: { lat: latP, lon: lonP } };
    }

    /********************************************************************
     * 4) UI-RENDER-FUNKTIONEN
     ********************************************************************/
    function updateGpsBadge() {
      const dot = document.getElementById("gpsDot");
      const txt = document.getElementById("gpsText");
      const mode = document.getElementById("modeText");
      if (!dot || !txt || !mode) return;

      if (STATE.sim.enabled) {
        dot.className = "w-2 h-2 rounded-full bg-amber-300 inline-block";
        txt.textContent = "SIM";
        mode.textContent = "SIM";
        return;
      }

      if (STATE.gps.hasFix) {
        dot.className = "w-2 h-2 rounded-full bg-emerald-400 inline-block";
        const acc = STATE.gps.accuracyM != null ? `±${Math.round(STATE.gps.accuracyM)}m` : "";
        txt.textContent = `GPS: OK ${acc}`.trim();
        mode.textContent = "LIVE";
      } else {
        dot.className = "w-2 h-2 rounded-full bg-slate-500 inline-block";
        txt.textContent = "GPS: –";
        mode.textContent = "LIVE";
      }
    }

    function updateButtons() {
      document.getElementById("btnStartFlight")?.classList.toggle("hidden", STATE.flight.active);
      document.getElementById("btnFinish")?.classList.toggle("hidden", !STATE.flight.active);
      document.getElementById("simControls")?.classList.toggle("hidden", !STATE.sim.enabled);

      // Nav toast visible when task OR waypoint exists
      const showNav = !!STATE.task.active || !!STATE.waypoint.active;
      document.getElementById("navToast")?.classList.toggle("hidden", !showNav);
    }

    function updateInstruments() {
      const gsEl = document.getElementById("instGS");
      const altEl = document.getElementById("instALT");
      const varEl = document.getElementById("instVAR");

      let gs = 0, alt = null, vario = null;

      if (STATE.sim.enabled) {
        gs = STATE.sim.speedKmh || 0;
        alt = STATE.sim.altM;
        vario = STATE.sim.vRateMps;
      } else {
        gs = STATE.gps.speedKmh || 0;
        alt = STATE.gps.altM;
        vario = calcVarioMps();
      }

      if (gsEl) gsEl.textContent = fmtNum(gs, 1);
      if (altEl) altEl.textContent = alt == null ? "–" : String(Math.round(alt));
      if (varEl) varEl.textContent = vario == null ? "–" : fmtNum(vario, 1);
    }

    function calcVarioMps() {
      const alt = STATE.gps.altM;
      const ts = now();
      if (alt == null || !isFinite(alt)) return null;

      if (STATE.gps.lastAltM == null) {
        STATE.gps.lastAltM = alt;
        STATE.gps.lastAltTs = ts;
        return 0;
      }
      const dt = (ts - STATE.gps.lastAltTs) / 1000;
      if (dt < 0.6) return null;

      const da = alt - STATE.gps.lastAltM;
      STATE.gps.lastAltM = alt;
      STATE.gps.lastAltTs = ts;
      return da / dt;
    }

    function updateWindHud() {
      const box = document.getElementById("windHud");
      const list = document.getElementById("windHudList");
      if (!box || !list) return;

      box.classList.toggle("hidden", !STATE.ui.windHudOpen);

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM).slice(0, 10);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Winddaten.</div>`;
        return;
      }

      list.innerHTML = items.map(w => {
        const to = windToDegFrom(w.fromDeg);
        return `
          <div class="flex items-center justify-between rounded-2xl bg-slate-900/60 border border-slate-800 px-3 py-2">
            <div class="min-w-0">
              <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
              <div class="text-xs text-slate-400 truncate">${escapeXml(w.source || "manual")} • ${new Date(w.ts).toLocaleTimeString()}</div>
            </div>
            <div class="text-right">
              <div class="font-extrabold mono">${Math.round(w.fromDeg)}° <span class="text-xs text-slate-400">FROM</span></div>
              <div class="text-xs text-slate-300 mono">${fmtNum(w.speedKmh,1)} km/h → ${Math.round(to)}°</div>
            </div>
          </div>
        `;
      }).join("");
    }

    function updateWindPanel() {
      const list = document.getElementById("windList");
      if (!list) return;

      const items = [...STATE.wind.layers].sort((a,b)=>a.altM-b.altM);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Keine Schichten vorhanden.</div>`;
        return;
      }

      list.innerHTML = items.map((w, idx) => `
        <div class="flex items-center gap-2 rounded-2xl bg-slate-950/60 border border-slate-800 px-3 py-2">
          <div class="flex-1">
            <div class="font-extrabold mono">${Math.round(w.altM)} m</div>
            <div class="text-xs text-slate-400 mono">${Math.round(w.fromDeg)}° FROM • ${fmtNum(w.speedKmh,1)} km/h</div>
          </div>
          <button data-widx="${idx}" class="btn-touch btnDelWind h-9 w-9 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800">
            <i class="fa-solid fa-trash"></i>
          </button>
        </div>
      `).join("");

      list.querySelectorAll(".btnDelWind").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const idx = parseInt(e.currentTarget.getAttribute("data-widx"), 10);
          if (!Number.isFinite(idx)) return;
          STATE.wind.layers.splice(idx, 1);
          persistAll();
          updateWindPanel();
          updateWindHud();
          updateNavToast();
          rebuildTrajectory();
        });
      });
    }

    function updateArchivePanel() {
      const list = document.getElementById("archiveList");
      if (!list) return;

      const items = [...STATE.flight.archive].sort((a,b)=>b.startedTs-a.startedTs);
      if (!items.length) {
        list.innerHTML = `<div class="text-sm text-slate-400">Noch keine Fahrten im Archiv.</div>`;
        return;
      }

      list.innerHTML = items.map((f) => {
        const dt = new Date(f.startedTs);
        const durMin = f.endedTs ? Math.round((f.endedTs - f.startedTs)/60000) : 0;
        const mCount = (f.markers||[]).length;
        const tCount = (f.track||[]).length;
        return `
          <div class="rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div class="flex items-center gap-2">
              <div class="flex-1 min-w-0">
                <div class="font-extrabold truncate">${escapeXml(f.title || "Fahrt")}</div>
                <div class="text-xs text-slate-400">${dt.toLocaleString()} • ${durMin} min • ${tCount} pts • ${mCount} marks</div>
              </div>
              <button data-fid="${f.id}" class="btn-touch btnExport h-10 px-3 rounded-xl bg-emerald-400 hover:bg-emerald-300 active:bg-emerald-500 text-slate-950 font-extrabold text-sm">
                <i class="fa-solid fa-file-arrow-down mr-2"></i>KML
              </button>
            </div>
          </div>
        `;
      }).join("");

      list.querySelectorAll(".btnExport").forEach(btn => {
        btn.addEventListener("click", (e) => {
          const fid = e.currentTarget.getAttribute("data-fid");
          const f = STATE.flight.archive.find(x => x.id === fid);
          if (!f) return;
          exportFlightToKml(f);
        });
      });
    }

    function setMarkerButtonColor(key) {
      const btn = document.getElementById("btnMarker");
      if (!btn) return;
      const idx = Math.abs(hashStr(key || "x")) % MARKER_COLORS.length;
      const c = MARKER_COLORS[idx];
      btn.style.background = COLOR_HEX[c];
      btn.style.color = "#0b1220";
    }

    function updateNavToast() {
      const toast = document.getElementById("navToast");
      const icon  = document.getElementById("navIcon");
      const title = document.getElementById("navTitle");
      const l1    = document.getElementById("navLine1");
      const l2    = document.getElementById("navLine2");
      if (!toast || !icon || !title || !l1 || !l2) return;

      const pos = getCurrentPos();
      const gsMps = getGroundSpeedMps();

      // Prefer task
      if (STATE.task.active) {
        icon.className = "fa-solid fa-route mr-2 text-emerald-300";
        const t = STATE.task.active;
        title.textContent = `${t.code} — ${t.title || t.typeTitle}`;

        const target = getPrimaryTarget(t);
        if (!pos || !target) {
          l1.textContent = "–";
          l2.textContent = !pos ? "Keine Position" : "Kein Ziel";
          return;
        }

        const d = haversineM(pos, target);
        l1.textContent = `Dist: ${fmtDist(d)}`;

        const rec = recommendLayerText(t, pos, target);
        l2.textContent = rec || "–";
        return;
      }

      // Waypoint
      if (STATE.waypoint.active) {
        icon.className = "fa-solid fa-location-crosshairs mr-2 text-amber-300";
        title.textContent = "Waypoint";

        if (!pos) {
          l1.textContent = "–";
          l2.textContent = "Keine Position";
          return;
        }

        const wp = { lat: STATE.waypoint.active.lat, lon: STATE.waypoint.active.lon };
        const d = haversineM(pos, wp);
        const brg = bearingDeg(pos, wp);

        const course = getCourseDeg();
        const proj = projectOntoHeadingRay(pos, course, wp);
        const ete = (gsMps > 0.6) ? (proj.alongM / gsMps) : null;

        l1.textContent = `Dist: ${fmtDist(d)} • Brg: ${Math.round(brg)}°`;
        l2.textContent = `ETE: ${fmtTime(ete)} • DCA: ${fmtDist(proj.dcaM)}`;
        return;
      }

      // none
      toast.classList.add("hidden");
    }

    function setMapPickHint(which, on) {
      const hint = document.getElementById("mapPickHint");
      if (!hint) return;
      hint.textContent = `Tippe auf die Karte, um Punkt ${which} zu setzen (Briefing).`;
      hint.classList.toggle("hidden", !on);
    }

    function openDrawer(open=true) {
      STATE.ui.drawerOpen = open;
      const wrap = document.getElementById("drawerWrap");
      if (!wrap) return;
      wrap.classList.toggle("hidden", !open);
      if (open) updateDrawerTabUi();
    }

    function openMapModal(open=true) {
      const modal = document.getElementById("mapModal");
      if (!modal) return;
      modal.classList.toggle("hidden", !open);
      updateFollowToggleUi();
    }

    function updateDrawerTabUi() {
      document.querySelectorAll(".tabBtn").forEach(b => {
        const tab = b.getAttribute("data-tab");
        const on = tab === STATE.ui.drawerTab;
        b.classList.toggle("bg-sky-400", on);
        b.classList.toggle("text-slate-950", on);
        b.classList.toggle("border-sky-300", on);
      });
      ["task","wind","setup","archive"].forEach(t => {
        const el = document.getElementById(`tab_${t}`);
        if (el) el.classList.toggle("hidden", t !== STATE.ui.drawerTab);
      });
    }

    function updateFollowToggleUi() {
      const tgl = document.getElementById("tglFollow");
      const knob = document.getElementById("tglFollowKnob");
      if (tgl && knob) setToggleUI(tgl, knob, STATE.ui.followGps);
    }

    /********************************************************************
     * 5) KERN-LOGIK (GPS, Map, Simulation, Tasks, Waypoint)
     ********************************************************************/
    function initManifestAndSW() {
      // Inline manifest via data URL (best effort)
      try {
        const manifest = {
          name: "CompNavAir",
          short_name: "CompNavAir",
          start_url: ".",
          display: "standalone",
          background_color: "#020617",
          theme_color: "#020617",
          icons: []
        };
        const href = "data:application/manifest+json," + encodeURIComponent(JSON.stringify(manifest));
        const link = document.createElement("link");
        link.rel = "manifest";
        link.href = href;
        document.head.appendChild(link);
      } catch {}

      // Minimal SW via Blob (best effort)
      try {
        if (!("serviceWorker" in navigator)) return;
        const swCode = `
          self.addEventListener('install', (e)=>self.skipWaiting());
          self.addEventListener('activate', (e)=>self.clients.claim());
          self.addEventListener('fetch', (e)=>{});
        `;
        const blob = new Blob([swCode], { type: "text/javascript" });
        const url = URL.createObjectURL(blob);
        navigator.serviceWorker.register(url).catch(()=>{});
      } catch {}
    }

    function initMap() {
      const map = L.map("map", {
        zoomControl: true,
        attributionControl: true,
        zoomSnap: 0.25,
        preferCanvas: true,
      });
      STATE.map = map;

      STATE.layers.baseOSM = L.tileLayer(TILE.osm.url, { maxZoom: 19, attribution: TILE.osm.attr });
      STATE.layers.baseSAT = L.tileLayer(TILE.esri.url, { maxZoom: 19, attribution: TILE.esri.attr });
      STATE.layers.baseOSM.addTo(map);

      STATE.layers.tasksLayer = L.layerGroup().addTo(map);
      STATE.layers.trackLayer = L.layerGroup().addTo(map);
      STATE.layers.markersLayer = L.layerGroup().addTo(map);
      STATE.layers.pickLayer = L.layerGroup().addTo(map);
      STATE.layers.waypointLayer = L.layerGroup().addTo(map);
      STATE.layers.trajectoryLayer = L.layerGroup().addTo(map);

      STATE.layers.trackLine = L.polyline([], {
        color: "#ef4444",
        weight: 4,
        opacity: 0.9,
        interactive: false
      }).addTo(STATE.layers.trackLayer);

      map.setView([APP.defaultCenter.lat, APP.defaultCenter.lon], APP.defaultZoom);

      // User interaction disables follow
      map.on("dragstart", () => {
        STATE.ui.mapUserInteracting = true;
        STATE.ui.followGps = false;
        updateFollowToggleUi();
        cancelLongPress();
      });
      map.on("dragend", () => setTimeout(()=>STATE.ui.mapUserInteracting = false, 120));
      map.on("zoomstart", cancelLongPress);

      // Tap for picking task points
      map.on("click", (e) => {
        if (!STATE.ui.mapPickMode) return;
        const lat = e.latlng.lat;
        const lon = e.latlng.lng;
        const which = STATE.ui.mapPickWhich || "A";

        setPointFromMap(which, lat, lon);

        const next = pickNextPoint(which);
        if (next) {
          STATE.ui.mapPickWhich = next;
          setMapPickHint(next, true);
          showSnackbar(`Punkt ${which} gesetzt. Jetzt Punkt ${next}.`, 1800);
        } else {
          stopMapPick();
          showSnackbar(`Punkt ${which} gesetzt.`, 1600);
        }
      });

      // Long press for free waypoint
      installLongPress(map);

      ensureBalloonMarker();
    }

    function setBaseLayer(which) {
      if (!STATE.map) return;
      STATE.ui.base = which === "sat" ? "sat" : "osm";
      try {
        if (STATE.ui.base === "sat") {
          STATE.map.removeLayer(STATE.layers.baseOSM);
          STATE.layers.baseSAT.addTo(STATE.map);
        } else {
          STATE.map.removeLayer(STATE.layers.baseSAT);
          STATE.layers.baseOSM.addTo(STATE.map);
        }
      } catch {}
    }

    function ensureBalloonMarker() {
      if (!STATE.map) return;

      if (STATE.balloon.marker) {
        if (!STATE.balloon.el) {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        }
        return;
      }

      const icon = L.divIcon({
        className: "",
        iconSize: [34, 34],
        iconAnchor: [17, 17],
        html: `
          <div class="balloon-rot" style="width:34px;height:34px;display:grid;place-items:center;transform:rotate(0deg);">
            <svg width="26" height="26" viewBox="0 0 24 24" aria-hidden="true">
              <path d="M12 2l7 19-7-4-7 4 7-19z" fill="#38bdf8" stroke="#0b1220" stroke-width="1.5" />
            </svg>
          </div>
        `
      });

      const p = getCurrentPos() || APP.defaultCenter;
      STATE.balloon.marker = L.marker([p.lat, p.lon], {
        icon,
        interactive: false,
        zIndexOffset: 1000
      }).addTo(STATE.map);

      setTimeout(() => {
        try {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        } catch {}
      }, 0);
    }

    function setBalloonPose(lat, lon, headingDegVal) {
      if (!STATE.map) return;
      if (!STATE.balloon.marker) ensureBalloonMarker();

      try { STATE.balloon.marker.setLatLng([lat, lon]); } catch {}

      if (!STATE.balloon.el) {
        try {
          const el = STATE.balloon.marker.getElement?.();
          STATE.balloon.el = el ? el.querySelector(".balloon-rot") : null;
        } catch {}
      }
      if (STATE.balloon.el) {
        STATE.balloon.el.style.transform = `rotate(${headingDegVal || 0}deg)`;
      }
    }

    function installLongPress(map) {
      const container = map.getContainer();
      if (!container) return;

      // Use pointer events
      container.addEventListener("pointerdown", (ev) => {
        try {
          if (ev.button != null && ev.button !== 0) return; // only left / primary
          if (STATE.ui.mapPickMode) return; // picking task points has priority
          if (STATE.ui.longPress.pointerId != null) return; // already tracking one
          if (ev.pointerType === "mouse" && (ev.ctrlKey || ev.metaKey)) return;

          const rect = container.getBoundingClientRect();
          const x = ev.clientX - rect.left;
          const y = ev.clientY - rect.top;

          STATE.ui.longPress.pointerId = ev.pointerId;
          STATE.ui.longPress.startX = x;
          STATE.ui.longPress.startY = y;
          STATE.ui.longPress.active = true;
          STATE.ui.longPress.startLatLng = map.containerPointToLatLng(L.point(x, y));

          // start timer
          STATE.ui.longPress.timer = setTimeout(() => {
            if (!STATE.ui.longPress.active) return;
            // If user is dragging map, do not trigger
            if (STATE.ui.mapUserInteracting) return;

            const ll = STATE.ui.longPress.startLatLng;
            if (!ll) return;

            setWaypoint(ll.lat, ll.lng);
            // prevent click creating something else
            cancelLongPress(true);
          }, APP.longPressMs);

          // capture pointer to keep receiving events
          try { container.setPointerCapture(ev.pointerId); } catch {}
        } catch {}
      }, { passive: true });

      container.addEventListener("pointermove", (ev) => {
        if (!STATE.ui.longPress.active) return;
        if (STATE.ui.longPress.pointerId !== ev.pointerId) return;

        const container = map.getContainer();
        const rect = container.getBoundingClientRect();
        const x = ev.clientX - rect.left;
        const y = ev.clientY - rect.top;

        const dx = x - STATE.ui.longPress.startX;
        const dy = y - STATE.ui.longPress.startY;
        if (Math.hypot(dx, dy) > APP.longPressMovePx) {
          cancelLongPress();
        }
      }, { passive: true });

      const end = (ev) => {
        if (!STATE.ui.longPress.active) return;
        if (STATE.ui.longPress.pointerId !== ev.pointerId) return;
        cancelLongPress();
      };

      container.addEventListener("pointerup", end, { passive: true });
      container.addEventListener("pointercancel", end, { passive: true });
      container.addEventListener("pointerleave", () => cancelLongPress(), { passive: true });
    }

    function cancelLongPress(fired=false) {
      STATE.ui.longPress.active = false;
      try { clearTimeout(STATE.ui.longPress.timer); } catch {}
      STATE.ui.longPress.timer = null;
      STATE.ui.longPress.pointerId = null;
      STATE.ui.longPress.startLatLng = null;
      // if fired, keep map interaction normal
    }

    function setWaypoint(lat, lon) {
      // create/replace free waypoint
      STATE.waypoint.active = { lat, lon, ts: now() };
      drawWaypoint();
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Waypoint gesetzt (long press).", 1800);
    }

    function clearWaypoint() {
      STATE.waypoint.active = null;
      removeWaypointGraphics();
      updateButtons();
      updateNavToast();
      persistAll();
      showSnackbar("Waypoint entfernt.", 1600);
    }

    function removeWaypointGraphics() {
      try { STATE.layers.waypointLayer?.clearLayers(); } catch {}
      STATE.waypoint.marker = null;
      STATE.waypoint.lineToWp = null;
      STATE.waypoint.headingLine = null;
      STATE.waypoint.closestX = null;
    }

    function drawWaypoint() {
      if (!STATE.map || !STATE.layers.waypointLayer) return;
      removeWaypointGraphics();
      if (!STATE.waypoint.active) return;

      const wp = STATE.waypoint.active;
      const latlng = [wp.lat, wp.lon];

      // marker interactive for removing (tap)
      const mk = L.circleMarker(latlng, {
        radius: 10,
        color: "#fbbf24",
        weight: 3,
        fillColor: "#fbbf24",
        fillOpacity: 0.20,
        interactive: true
      }).addTo(STATE.layers.waypointLayer);

      mk.on("click", () => clearWaypoint());

      // label "WP"
      L.marker(latlng, {
        icon: L.divIcon({
          className: "",
          iconSize: [1,1],
          html: `<div class="mono text-xs font-extrabold" style="color:#fbbf24;text-shadow:0 6px 16px rgba(0,0,0,.45)">WP</div>`
        }),
        interactive: false
      }).addTo(STATE.layers.waypointLayer);

      STATE.waypoint.marker = mk;

      // lines + X are computed in updateWaypointGuidance()
      updateWaypointGuidance();
    }

    function updateWaypointGuidance() {
      if (!STATE.map || !STATE.layers.waypointLayer) return;
      if (!STATE.waypoint.active) return;

      const pos = getCurrentPos();
      if (!pos) return;

      const wp = { lat: STATE.waypoint.active.lat, lon: STATE.waypoint.active.lon };
      const course = getCourseDeg();

      // heading line length: min 1500m, max 6000m, based on GS*5min
      const gsMps = getGroundSpeedMps();
      const len = clamp(gsMps * 300, 1500, 6000);
      const end = destPoint(pos, course, len);

      const NI = { interactive: false };

      // clear old guidance (keep marker)
      try {
        // remove everything except marker-ish by just clearing and re-adding marker would be annoying;
        // instead: clear and recreate all quickly
        const saved = STATE.waypoint.marker;
        removeWaypointGraphics();
        // redraw marker
        STATE.waypoint.active = { ...STATE.waypoint.active };
        const wpLatLng = [wp.lat, wp.lon];
        const mk = L.circleMarker(wpLatLng, {
          radius: 10, color: "#fbbf24", weight: 3, fillColor: "#fbbf24", fillOpacity: 0.20, interactive: true
        }).addTo(STATE.layers.waypointLayer);
        mk.on("click", () => clearWaypoint());
        L.marker(wpLatLng, { icon: L.divIcon({ className:"", iconSize:[1,1], html:`<div class="mono text-xs font-extrabold" style="color:#fbbf24;text-shadow:0 6px 16px rgba(0,0,0,.45)">WP</div>` }), interactive:false }).addTo(STATE.layers.waypointLayer);
        STATE.waypoint.marker = mk;
      } catch {
        // fallback: if something fails, just rebuild marker + guidance from scratch
      }

      // Direct line to waypoint
      STATE.waypoint.lineToWp = L.polyline([[pos.lat,pos.lon],[wp.lat,wp.lon]], {
        color: "#fbbf24", weight: 3, opacity: 0.85, dashArray: "10 8", ...NI
      }).addTo(STATE.layers.waypointLayer);

      // Heading line (flight direction)
      STATE.waypoint.headingLine = L.polyline([[pos.lat,pos.lon],[end.lat,end.lon]], {
        color: "#22c55e", weight: 4, opacity: 0.75, dashArray: "6 10", ...NI
      }).addTo(STATE.layers.waypointLayer);

      // Closest point X on heading line
      const proj = projectOntoHeadingRay(pos, course, wp);
      const c = proj.closest;

      STATE.waypoint.closestX = L.marker([c.lat, c.lon], {
        icon: L.divIcon({
          className: "",
          iconSize: [22,22],
          iconAnchor: [11,11],
          html: `<div class="wp-x">X</div>`
        }),
        interactive: false,
        zIndexOffset: 900
      }).addTo(STATE.layers.waypointLayer);
    }

    function renderTaskTypeOptions() {
      const sel = document.getElementById("taskType");
      if (!sel) return;
      sel.innerHTML = CIA_TASKS.map(t => `<option value="${t.code}">${t.num} ${t.code} — ${escapeXml(t.title)}</option>`).join("");
    }

    function renderTaskFieldsForCode(code) {
      const wrap = document.getElementById("taskFields");
      if (!wrap) return;

      const is3DT = code === "3DT";
      const isANG = code === "ANG";
      const isLRN = code === "LRN";

      const pointCard = (label, which) => `
        <div class="rounded-2xl bg-slate-950/40 border border-slate-800 p-3">
          <div class="flex items-center justify-between mb-2">
            <div class="font-extrabold">${escapeXml(label)}</div>
            <button type="button" data-pick="${which}" class="btn-touch h-9 px-3 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 font-bold text-sm">
              <i class="fa-solid fa-crosshairs mr-2"></i>auf Karte
            </button>
          </div>
          <div class="grid grid-cols-2 gap-2">
            <div>
              <div class="text-xs text-slate-400 mb-1">Lat</div>
              <input id="task${which}Lat" type="number" step="0.000001" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="49.123456" />
            </div>
            <div>
              <div class="text-xs text-slate-400 mb-1">Lon</div>
              <input id="task${which}Lon" type="number" step="0.000001" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="8.123456" />
            </div>
          </div>
        </div>
      `;

      const radiusFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Innenradius (m)" : "Radius 1 (m)"}</div>
            <input id="taskR1" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 50" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">${is3DT ? "Außenradius (m)" : "Radius 2 (m)"}</div>
            <input id="taskR2" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="z.B. 200" />
          </div>
        </div>
      `;

      const altFields = `
        <div class="grid grid-cols-2 gap-2">
          <div>
            <div class="text-xs text-slate-400 mb-1">Min Höhe (m)</div>
            <input id="taskMinAlt" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
          <div>
            <div class="text-xs text-slate-400 mb-1">Max Höhe (m)</div>
            <input id="taskMaxAlt" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="optional" />
          </div>
        </div>
      `;

      const angFields = isANG ? `
        <div>
          <div class="text-xs text-slate-400 mb-1">Vorgegebene Richtung (°)</div>
          <input id="taskSetDir" type="number" class="h-11 w-full rounded-xl bg-slate-950 border border-slate-700 px-3 mono" placeholder="0..359" />
        </div>
      ` : "";

      let coordsHtml = "";
      if (isANG || isLRN) {
        coordsHtml = `
          ${pointCard("Punkt A", "A")}
          ${pointCard("Punkt B", "B")}
          ${isLRN ? pointCard("Punkt C", "C") : ""}
        `;
      } else {
        coordsHtml = `${pointCard("Ziel", "A")}`;
      }

      wrap.innerHTML = `
        <div class="text-xs text-slate-400 mb-1">Koordinaten</div>
        <div class="space-y-3">${coordsHtml}</div>
        <div class="mt-3">${radiusFields}</div>
        <div class="mt-3">${angFields}</div>
        <div class="mt-3">${altFields}</div>
      `;

      // wire pick buttons
      wrap.querySelectorAll("[data-pick]").forEach(btn => {
        btn.addEventListener("click", () => startMapPick(btn.getAttribute("data-pick")));
      });

      // keep preview markers in sync
      wrap.querySelectorAll('input[id^="task"][id$="Lat"], input[id^="task"][id$="Lon"]').forEach(inp => {
        inp.addEventListener("change", syncPickMarkersFromInputs);
        inp.addEventListener("input", () => { /* lightweight: don't spam map */ });
      });

      syncPickMarkersFromInputs();
    }

    function startMapPick(which) {
      STATE.ui.mapPickMode = true;
      STATE.ui.mapPickWhich = which || "A";
      openDrawer(false);
      setMapPickHint(STATE.ui.mapPickWhich, true);
      showSnackbar(`Karte tippen: Punkt ${STATE.ui.mapPickWhich} setzen.`, 1800);
    }

    function stopMapPick() {
      STATE.ui.mapPickMode = false;
      setMapPickHint("A", false);
    }

    function updatePickMarker(which, lat, lon) {
      if (!STATE.layers.pickLayer || !STATE.map) return;

      const prev = STATE.ui.pickMarkers[which];
      if (prev) {
        try { STATE.layers.pickLayer.removeLayer(prev); } catch {}
        STATE.ui.pickMarkers[which] = null;
      }

      const color = which === "A" ? "#60a5fa" : (which === "B" ? "#22d3ee" : "#a78bfa");
      const g = L.layerGroup();

      L.circleMarker([lat, lon], {
        radius: 10,
        color,
        weight: 3,
        fillColor: color,
        fillOpacity: 0.25,
        interactive: false
      }).addTo(g);

      L.marker([lat, lon], {
        icon: L.divIcon({
          className: "",
          iconSize: [1,1],
          html: `<div class="mono text-xs font-extrabold" style="color:${color};text-shadow:0 6px 16px rgba(0,0,0,.45)">${which}</div>`
        }),
        interactive: false
      }).addTo(g);

      STATE.layers.pickLayer.addLayer(g);
      STATE.ui.pickMarkers[which] = g;
    }

    function setPointFromMap(which, lat, lon) {
      const latEl = document.getElementById(`task${which}Lat`);
      const lonEl = document.getElementById(`task${which}Lon`);
      if (latEl) latEl.value = lat.toFixed(6);
      if (lonEl) lonEl.value = lon.toFixed(6);
      updatePickMarker(which, lat, lon);
    }

    function pickNextPoint(which) {
      const order = ["A", "B", "C"];
      const idx = order.indexOf(which);
      for (let i = idx + 1; i < order.length; i++) {
        const w = order[i];
        const latEl = document.getElementById(`task${w}Lat`);
        const lonEl = document.getElementById(`task${w}Lon`);
        if (!latEl || !lonEl) continue;

        const latVal = safeFloat(latEl.value, null);
        const lonVal = safeFloat(lonEl.value, null);
        if (latVal == null || lonVal == null) return w;
      }
      return null;
    }

    function syncPickMarkersFromInputs() {
      ["A","B","C"].forEach(which => {
        const latEl = document.getElementById(`task${which}Lat`);
        const lonEl = document.getElementById(`task${which}Lon`);

        if (!latEl || !lonEl) {
          const prev = STATE.ui.pickMarkers[which];
          if (prev && STATE.layers.pickLayer) {
            try { STATE.layers.pickLayer.removeLayer(prev); } catch {}
          }
          STATE.ui.pickMarkers[which] = null;
          return;
        }

        const lat = safeFloat(latEl.value, null);
        const lon = safeFloat(lonEl.value, null);
        if (lat != null && lon != null) updatePickMarker(which, lat, lon);
      });
    }

    function initGPS() {
      if (!("geolocation" in navigator)) {
        showSnackbar("Geolocation nicht verfügbar.");
        return;
      }

      stopGPS();
      const opts = { enableHighAccuracy: true, maximumAge: 1000, timeout: 10000 };

      STATE.gps.watchId = navigator.geolocation.watchPosition(
        (pos) => { try { onGpsPosition(pos); } catch (e) { console.error(e); } },
        (err) => {
          console.warn(err);
          STATE.gps.hasFix = false;
          updateGpsBadge();
        },
        opts
      );
    }

    function stopGPS() {
      try {
        if (STATE.gps.watchId != null) navigator.geolocation.clearWatch(STATE.gps.watchId);
      } catch {}
      STATE.gps.watchId = null;
    }

    function onGpsPosition(pos) {
      if (STATE.sim.enabled) return;

      const c = pos.coords;
      const lat = c.latitude;
      const lon = c.longitude;
      const alt = Number.isFinite(c.altitude) ? c.altitude : null;
      const spdKmh = Number.isFinite(c.speed) ? (c.speed * 3.6) : 0;
      const head = Number.isFinite(c.heading) ? c.heading : null;
      const acc = Number.isFinite(c.accuracy) ? c.accuracy : null;

      // Jump guard
      if (STATE.gps.smoothLat != null && STATE.gps.smoothLon != null) {
        const d = haversineM({ lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon }, { lat, lon });
        const dyn = clamp((spdKmh/3.6) * 3 + 60, 80, 220);
        if (d > Math.max(APP.maxGpsJumpM, dyn)) {
          return;
        }
      }

      // smoothing
      STATE.gps.smoothLat = smooth(STATE.gps.smoothLat, lat, APP.gpsSmoothingAlpha);
      STATE.gps.smoothLon = smooth(STATE.gps.smoothLon, lon, APP.gpsSmoothingAlpha);

      // derive course when possible
      let course = head;
      if (course == null) {
        // compute from previous smoothed point
        if (STATE.gps.lat != null && STATE.gps.lon != null) {
          const d = haversineM({ lat: STATE.gps.lat, lon: STATE.gps.lon }, { lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon });
          if (d > 4) course = bearingDeg({ lat: STATE.gps.lat, lon: STATE.gps.lon }, { lat: STATE.gps.smoothLat, lon: STATE.gps.smoothLon });
        }
      }
      if (course != null && isFinite(course)) STATE.gps.lastCourseDeg = ((course%360)+360)%360;

      STATE.gps.lat = STATE.gps.smoothLat;
      STATE.gps.lon = STATE.gps.smoothLon;
      STATE.gps.altM = alt;
      STATE.gps.speedKmh = spdKmh;
      STATE.gps.headingDeg = head;
      STATE.gps.accuracyM = acc;
      STATE.gps.hasFix = true;
      STATE.gps.fixTs = now();

      ensureBalloonMarker();
      setBalloonPose(STATE.gps.lat, STATE.gps.lon, getCourseDeg());

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.gps.lat, STATE.gps.lon], { animate: true, duration: 0.35 });
        }
      }

      // Log track/wind ONLY if flight active
      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.gps.lat, lon: STATE.gps.lon, altM: alt, ts: now() });
        maybeAutoRecordWind({ altM: alt, courseDeg: getCourseDeg(), speedKmh: spdKmh, ts: now() });
      }

      // Waypoint guidance updates even without flight
      if (STATE.waypoint.active) {
        updateWaypointGuidance();
      }

      updateGpsBadge();
      updateInstruments();
      updateButtons();
      updateNavToast();
      updateWindHud();
      rebuildTrajectory();
      persistAllThrottled();
    }

    function beginFlight(title) {
      if (STATE.flight.active) return;

      STATE.flight.active = true;
      STATE.flight.title = title || (STATE.task.active ? `${STATE.task.active.code} — ${STATE.task.active.title||STATE.task.active.typeTitle}` : "Fahrt");
      STATE.flight.startedTs = now();
      STATE.flight.track = [];
      STATE.flight.markers = [];

      try { STATE.layers.trackLine?.setLatLngs([]); } catch {}
      try { STATE.layers.markersLayer?.clearLayers(); } catch {}

      STATE.gps.lastAltM = null;
      STATE.gps.lastAltTs = null;
      STATE.wind.lastAuto = { altM: null, courseDeg: null, ts: 0 };
      STATE.task.apt.startTs = null;

      updateButtons();
      showSnackbar("Fahrt gestartet.");
      persistAll();
    }

    function finishFlight() {
      if (!STATE.flight.active) return;

      const endedTs = now();
      const flight = {
        id: uid(),
        title: STATE.flight.title || "Fahrt",
        startedTs: STATE.flight.startedTs,
        endedTs,
        track: STATE.flight.track.slice(0),
        markers: STATE.flight.markers.slice(0),
      };

      STATE.flight.archive.push(flight);
      STATE.flight.active = false;
      STATE.flight.title = "";
      STATE.flight.startedTs = 0;
      STATE.task.apt.startTs = null;

      updateButtons();
      updateArchivePanel();
      showSnackbar("Fahrt beendet & archiviert.");
      persistAll();
    }

    function maybeAddTrackPoint(p) {
      if (!STATE.flight.active) return;
      if (!p || p.lat == null || p.lon == null) return;

      const track = STATE.flight.track;
      if (track.length) {
        const last = track[track.length-1];
        const d = haversineM({ lat:last.lat, lon:last.lon }, { lat:p.lat, lon:p.lon });
        if (d < APP.trackMinDistM) return;
      }

      track.push({ lat:p.lat, lon:p.lon, altM:p.altM, ts:p.ts });
      if (track.length > APP.maxTrackPoints) track.shift();

      try { STATE.layers.trackLine?.setLatLngs(track.map(x => [x.lat, x.lon])); } catch {}
    }

    function maybeAutoRecordWind({ altM, courseDeg, speedKmh, ts }) {
      if (!STATE.flight.active) return;
      if (speedKmh == null || speedKmh < 10) return;
      if (altM == null || !isFinite(altM)) return;

      const last = STATE.wind.lastAuto;
      const dAlt = last.altM == null ? 9999 : Math.abs(altM - last.altM);
      const dCrs = last.courseDeg == null ? 9999 : angDiffDeg(courseDeg, last.courseDeg);

      if (dAlt > 50 || dCrs > 5) {
        const fromDeg = (courseDeg + 180) % 360;
        addWindLayer({ altM, fromDeg, speedKmh, ts, source: "auto" });
        STATE.wind.lastAuto = { altM, courseDeg, ts };
      }
    }

    function addWindLayer(w) {
      const alt = Math.round(w.altM);
      const from = ((Math.round(w.fromDeg)%360)+360)%360;
      const spd = Math.max(0, safeFloat(w.speedKmh, 0));
      const ts = w.ts || now();

      const idx = STATE.wind.layers.findIndex(x => Math.abs(x.altM - alt) <= 15);
      const item = { altM: alt, fromDeg: from, speedKmh: spd, ts, source: w.source || "manual" };
      if (idx >= 0) STATE.wind.layers[idx] = item;
      else STATE.wind.layers.push(item);

      STATE.wind.layers.sort((a,b)=>a.altM-b.altM);
      persistAll();
      updateWindPanel();
      updateWindHud();
      updateNavToast();
      rebuildTrajectory();
    }

    function windAtAltitude(altM) {
      if (!STATE.wind.layers.length || altM == null) return null;
      let best = null, bestD = Infinity;
      for (const w of STATE.wind.layers) {
        const d = Math.abs(w.altM - altM);
        if (d < bestD) { bestD = d; best = w; }
      }
      return best;
    }

    function rebuildTrajectory() {
      if (!STATE.map || !STATE.layers.trajectoryLayer) return;
      try { STATE.layers.trajectoryLayer.clearLayers(); } catch {}

      const pos = getCurrentPos();
      const alt = getCurrentAltM();
      if (!pos || alt == null) return;

      const w = windAtAltitude(alt);
      if (!w) return;

      const driftTo = windToDegFrom(w.fromDeg);
      const spdMps = Math.max(0, (w.speedKmh||0) / 3.6);
      if (spdMps < 0.1) return;

      const mins = [5,10,15];
      const NI = { interactive:false };

      mins.forEach((m, idx) => {
        const dist = spdMps * (m*60);
        const q = destPoint(pos, driftTo, dist);
        L.polyline([[pos.lat,pos.lon],[q.lat,q.lon]], {
          color: "#22c55e",
          weight: 4,
          opacity: 0.75,
          dashArray: idx === 0 ? null : (idx === 1 ? "8 8" : "3 10"),
          ...NI
        }).addTo(STATE.layers.trajectoryLayer);
      });
    }

    function getPrimaryTarget(task) {
      if (!task) return null;
      if (task.code === "3DT" && task.center) return task.center;
      if (task.points && task.points.length) return { lat: task.points[0].lat, lon: task.points[0].lon };
      return null;
    }

    function recommendLayerText(task, pos, target) {
      if (task && task.code === "3DT" && task.center && task.r1M && task.r2M) {
        const dC = haversineM(pos, task.center);
        if (dC < task.r1M) return "Ungültig (im inneren Kreis)";
        if (dC <= task.r2M) return "Im Ring: Distanz maximieren";
        return "Außerhalb: Ziel = Zentrum";
      }

      if (!STATE.wind.layers.length) return "Kein Windprofil";

      const brg = bearingDeg(pos, target);

      let best = null, bestScore = Infinity;
      for (const w of STATE.wind.layers) {
        const driftTo = windToDegFrom(w.fromDeg);
        const score = angDiffDeg(driftTo, brg);
        if (score < bestScore) { bestScore = score; best = w; }
      }
      if (!best) return "Kein Layer";

      const curAlt = getCurrentAltM();
      const need = Math.round(best.altM);
      if (curAlt == null) return `Layer: ${need}m`;
      const dAlt = need - curAlt;
      if (Math.abs(dAlt) < 25) return `Halten ~${need}m`;
      return dAlt > 0 ? `Steigen auf ${need}m` : `Sinken auf ${need}m`;
    }

    function clearTaskOverlays() {
      try { STATE.layers.tasksLayer?.clearLayers(); } catch {}
    }

    function drawTaskOnMap(task) {
      clearTaskOverlays();
      if (!task || !STATE.map) return;

      const NI = { interactive:false };

      // points
      if (task.points && task.points.length) {
        task.points.forEach((p, idx) => {
          const color = idx === 0 ? "#60a5fa" : "#93c5fd";
          L.circleMarker([p.lat, p.lon], {
            radius: 9,
            color,
            weight: 3,
            fillColor: color,
            fillOpacity: 0.25,
            ...NI
          }).addTo(STATE.layers.tasksLayer);

          L.marker([p.lat, p.lon], {
            icon: L.divIcon({
              className: "",
              iconSize: [1,1],
              html: `<div class="mono text-xs font-extrabold" style="color:${color};text-shadow:0 6px 16px rgba(0,0,0,.45)">${escapeXml(p.name||String.fromCharCode(65+idx))}</div>`
            }),
            interactive:false
          }).addTo(STATE.layers.tasksLayer);
        });
      }

      const center = task.center || (task.points && task.points[0] ? { lat: task.points[0].lat, lon: task.points[0].lon } : null);
      if (center && (task.r2M || task.r1M)) {
        if (task.r2M) {
          L.circle([center.lat, center.lon], {
            radius: task.r2M,
            color: "#60a5fa",
            weight: 3,
            opacity: 0.9,
            fillOpacity: 0.05,
            ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
        if (task.r1M) {
          L.circle([center.lat, center.lon], {
            radius: task.r1M,
            color: "#93c5fd",
            weight: 2,
            opacity: 0.8,
            dashArray: "6 8",
            fillOpacity: 0.01,
            ...NI
          }).addTo(STATE.layers.tasksLayer);
        }
      }

      if (task.code === "ANG" && task.points && task.points.length >= 2) {
        L.polyline(task.points.slice(0,2).map(p => [p.lat,p.lon]), {
          color:"#38bdf8", weight:3, opacity:0.9, dashArray:"8 8", ...NI
        }).addTo(STATE.layers.tasksLayer);
      }
      if (task.code === "LRN" && task.points && task.points.length >= 3) {
        const pts = task.points.slice(0,3).map(p => [p.lat,p.lon]);
        pts.push([task.points[0].lat, task.points[0].lon]);
        L.polyline(pts, { color:"#38bdf8", weight:3, opacity:0.9, ...NI }).addTo(STATE.layers.tasksLayer);
      }
    }

    function buildTaskFromForm() {
      const code = document.getElementById("taskType")?.value;
      const meta = CIA_TASKS.find(x => x.code === code);
      if (!code || !meta) return null;

      const title = document.getElementById("taskTitle")?.value?.trim() || "";
      const r1 = safeFloat(document.getElementById("taskR1")?.value, null);
      const r2 = safeFloat(document.getElementById("taskR2")?.value, null);
      const minAlt = safeFloat(document.getElementById("taskMinAlt")?.value, null);
      const maxAlt = safeFloat(document.getElementById("taskMaxAlt")?.value, null);
      const setDir = safeFloat(document.getElementById("taskSetDir")?.value, null);

      const points = [];
      const aLat = safeFloat(document.getElementById("taskALat")?.value, null);
      const aLon = safeFloat(document.getElementById("taskALon")?.value, null);
      if (aLat != null && aLon != null) points.push({ name:"A", lat:aLat, lon:aLon });

      const bLat = safeFloat(document.getElementById("taskBLat")?.value, null);
      const bLon = safeFloat(document.getElementById("taskBLon")?.value, null);
      if (bLat != null && bLon != null) points.push({ name:"B", lat:bLat, lon:bLon });

      const cLat = safeFloat(document.getElementById("taskCLat")?.value, null);
      const cLon = safeFloat(document.getElementById("taskCLon")?.value, null);
      if (cLat != null && cLon != null) points.push({ name:"C", lat:cLat, lon:cLon });

      const task = {
        id: uid(),
        code,
        typeTitle: meta.title,
        title,
        points,
        r1M: r1 != null ? Math.max(0, r1) : null,
        r2M: r2 != null ? Math.max(0, r2) : null,
        minAltM: minAlt,
        maxAltM: maxAlt,
        setDirDeg: setDir != null ? ((setDir%360)+360)%360 : null,
        center: null,
      };

      if (task.code === "3DT") {
        if (points[0]) task.center = { lat: points[0].lat, lon: points[0].lon };
      }

      return task;
    }

    function applyTask() {
      const task = buildTaskFromForm();
      if (!task) { showSnackbar("Task unvollständig."); return; }

      if (!task.points || !task.points.length) {
        showSnackbar("Bitte Koordinaten eingeben (mind. Punkt A).");
        return;
      }

      STATE.task.active = task;
      drawTaskOnMap(task);
      updateButtons();
      updateNavToast();
      setMarkerButtonColor(task.code);

      try {
        const latlngs = [];
        if (task.points) task.points.forEach(p => latlngs.push([p.lat,p.lon]));
        if (task.center) latlngs.push([task.center.lat, task.center.lon]);
        if (latlngs.length) STATE.map.fitBounds(L.latLngBounds(latlngs).pad(0.35), { animate:true, duration:0.4 });
      } catch {}

      showSnackbar("Task aktiv.");
      persistAll();
    }

    function clearTask() {
      STATE.task.active = null;
      clearTaskOverlays();
      updateButtons();
      updateNavToast();
      setMarkerButtonColor("x");
      showSnackbar("Task gelöscht.");
      persistAll();
    }

    function dropMarker() {
      if (!STATE.flight.active) { showSnackbar("Bitte zuerst die Fahrt starten."); return; }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }

      const alt = getCurrentAltM();
      const t = STATE.task.active;
      const colorKey = t ? MARKER_COLORS[Math.abs(hashStr(t.code)) % MARKER_COLORS.length] : "pink";
      const color = COLOR_HEX[colorKey];

      const m = { lat: pos.lat, lon: pos.lon, altM: alt, ts: now(), color: colorKey, label: t ? t.code : "MARK" };
      STATE.flight.markers.push(m);

      L.circleMarker([m.lat, m.lon], {
        radius: 8,
        color,
        weight: 3,
        fillColor: color,
        fillOpacity: 0.25,
        interactive: false
      }).addTo(STATE.layers.markersLayer);

      showSnackbar("Marker gesetzt.");
      persistAll();
    }

    function setHelperPoint(which) {
      if (!STATE.flight.active) { showSnackbar("Nur während aktiver Fahrt."); return; }
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position."); return; }
      STATE.task.pointsABC[which] = { ...pos };
      showSnackbar(`Punkt ${which} gesetzt.`);
      updateElbowResult();
    }

    function updateElbowResult() {
      const out = document.getElementById("elbowResult");
      if (!out) return;
      const A = STATE.task.pointsABC.A;
      const B = STATE.task.pointsABC.B;
      const C = STATE.task.pointsABC.C;
      if (!A || !B || !C) { out.textContent = "–"; return; }
      const brgBA = bearingDeg(B, A);
      const brgBC = bearingDeg(B, C);
      const ang = angDiffDeg(brgBA, brgBC);
      out.textContent = fmtNum(180 - ang, 1);
    }

    async function fetchWindFromOpenMeteo() {
      const pos = getCurrentPos();
      if (!pos) { showSnackbar("Keine Position für Online-Wind."); return; }

      const lat = pos.lat.toFixed(4);
      const lon = pos.lon.toFixed(4);

      const hourly = [
        "windspeed_10m","winddirection_10m",
        "windspeed_80m","winddirection_80m",
        "windspeed_120m","winddirection_120m",
        "windspeed_180m","winddirection_180m"
      ].join(",");

      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&hourly=${hourly}&forecast_days=1&timezone=auto`;

      try {
        showSnackbar("Lade Wind…", 1200);
        const r = await fetch(url, { cache: "no-store" });
        if (!r.ok) throw new Error("HTTP " + r.status);
        const j = await r.json();

        const h = j.hourly;
        if (!h || !h.time || !h.time.length) throw new Error("no hourly data");

        const tNow = now();
        let bestI = 0, bestD = Infinity;
        for (let i=0;i<h.time.length;i++) {
          const t = Date.parse(h.time[i]);
          const d = Math.abs(t - tNow);
          if (d < bestD) { bestD = d; bestI = i; }
        }

        const mapping = [
          { altM: 10,  spd: h.windspeed_10m?.[bestI],  dir: h.winddirection_10m?.[bestI] },
          { altM: 80,  spd: h.windspeed_80m?.[bestI],  dir: h.winddirection_80m?.[bestI] },
          { altM: 120, spd: h.windspeed_120m?.[bestI], dir: h.winddirection_120m?.[bestI] },
          { altM: 180, spd: h.windspeed_180m?.[bestI], dir: h.winddirection_180m?.[bestI] },
        ];

        let added = 0;
        for (const m of mapping) {
          if (m.spd == null || m.dir == null) continue;
          addWindLayer({ altM: m.altM, fromDeg: m.dir, speedKmh: m.spd, ts: now(), source: "open-meteo" });
          added++;
        }
        showSnackbar(added ? `Wind geladen (${added} Schichten).` : "Keine Windschichten gefunden.");
      } catch (e) {
        console.error(e);
        showSnackbar("Online-Wind fehlgeschlagen.");
      }
    }

    function initSimulationToggle(enabled) {
      STATE.sim.enabled = !!enabled;
      updateButtons();
      updateGpsBadge();

      if (STATE.sim.enabled) {
        stopGPS();
        const p = getCurrentPos() || APP.defaultCenter;
        STATE.sim.lat = p.lat;
        STATE.sim.lon = p.lon;
        STATE.sim.altM = getCurrentAltM() || 180;
        STATE.sim.vRateMps = 0;
        STATE.sim.speedKmh = 0;
        STATE.sim.headingDeg = getCourseDeg() || 0;

        ensureBalloonMarker();
        setBalloonPose(STATE.sim.lat, STATE.sim.lon, STATE.sim.headingDeg);
        STATE.map?.panTo([STATE.sim.lat, STATE.sim.lon], { animate:true, duration:0.35 });

        startSimLoop();
        showSnackbar("Simulation an.");
      } else {
        stopSimLoop();
        initGPS();
        showSnackbar("Simulation aus.");
      }
      persistAll();
    }

    function startSimLoop() {
      if (STATE.sim.timer) return;
      STATE.sim.running = true;
      STATE.sim.lastTickTs = now();
      STATE.sim.timer = setInterval(() => { try { simTick(); } catch (e) { console.error(e); } }, 1000);
    }

    function stopSimLoop() {
      STATE.sim.running = false;
      try { clearInterval(STATE.sim.timer); } catch {}
      STATE.sim.timer = null;
      STATE.sim.vRateMps = 0;
    }

    function simTick() {
      if (!STATE.sim.enabled) return;
      const t = now();
      const dt = Math.min(2.5, Math.max(0.4, (t - STATE.sim.lastTickTs)/1000));
      STATE.sim.lastTickTs = t;

      // Vertical
      STATE.sim.altM = Math.max(0, (STATE.sim.altM || 0) + (STATE.sim.vRateMps || 0) * dt);

      // Horizontal drift from wind at altitude
      const w = windAtAltitude(STATE.sim.altM);
      let driftTo = STATE.sim.headingDeg || 0;
      let spd = 0;
      if (w) {
        driftTo = windToDegFrom(w.fromDeg);
        spd = Math.max(0, w.speedKmh || 0);
      }
      const distM = (spd/3.6) * dt;
      const p = destPoint({ lat: STATE.sim.lat, lon: STATE.sim.lon }, driftTo, distM);
      STATE.sim.lat = p.lat;
      STATE.sim.lon = p.lon;
      STATE.sim.headingDeg = driftTo;
      STATE.sim.speedKmh = spd;

      ensureBalloonMarker();
      setBalloonPose(STATE.sim.lat, STATE.sim.lon, STATE.sim.headingDeg);

      if (STATE.ui.followGps && !STATE.ui.mapUserInteracting) {
        const ts = now();
        if (ts - STATE.gps.lastPanTs > APP.followPanMinMs) {
          STATE.gps.lastPanTs = ts;
          STATE.map?.panTo([STATE.sim.lat, STATE.sim.lon], { animate:true, duration:0.35 });
        }
      }

      if (STATE.flight.active) {
        maybeAddTrackPoint({ lat: STATE.sim.lat, lon: STATE.sim.lon, altM: STATE.sim.altM, ts: now() });
      }

      if (STATE.waypoint.active) updateWaypointGuidance();

      updateInstruments();
      updateNavToast();
      updateWindHud();
      rebuildTrajectory();
      persistAllThrottled();
    }

    function handleBurner(pressed) { if (STATE.sim.enabled) STATE.sim.vRateMps = pressed ? 2.5 : 0; }
    function handleVent(pressed) { if (STATE.sim.enabled) STATE.sim.vRateMps = pressed ? -2.0 : 0; }

    function centerOnPos() {
      const p = getCurrentPos();
      if (!p || !STATE.map) return;
      STATE.ui.followGps = true;
      updateFollowToggleUi();
      STATE.map.panTo([p.lat, p.lon], { animate:true, duration:0.35 });
      showSnackbar("Zentriert.");
    }

    function exportFlightToKml(f) {
      try {
        const name = escapeXml(f.title || "CompNavAir");
        const trackCoords = (f.track || []).map(p => `${p.lon},${p.lat},${p.altM||0}`).join(" ");
        const markerPlacemarks = (f.markers || []).map(m => {
          const when = new Date(m.ts).toISOString();
          return `
            <Placemark>
              <name>${escapeXml(m.label || "MARK")}</name>
              <TimeStamp><when>${when}</when></TimeStamp>
              <Point><coordinates>${m.lon},${m.lat},${m.altM||0}</coordinates></Point>
            </Placemark>
          `;
        }).join("\n");

        const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Style id="trackStyle"><LineStyle><color>ff4f46e5</color><width>4</width></LineStyle></Style>
    <Placemark>
      <name>Track</name>
      <styleUrl>#trackStyle</styleUrl>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>${trackCoords}</coordinates>
      </LineString>
    </Placemark>
    ${markerPlacemarks}
  </Document>
</kml>`;

        const blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
        const a = document.createElement("a");
        a.href = URL.createObjectURL(blob);
        const ts = new Date(f.startedTs).toISOString().slice(0,19).replaceAll(":","-");
        a.download = `CompNavAir_${ts}.kml`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        setTimeout(()=>URL.revokeObjectURL(a.href), 1500);
      } catch (e) {
        console.error(e);
        showSnackbar("KML Export fehlgeschlagen.");
      }
    }

    function importKmlFile(file) {
      if (!file) return;
      const reader = new FileReader();
      reader.onload = () => {
        try {
          const txt = String(reader.result || "");
          if (STATE.layers.kmlLayer) {
            try { STATE.map.removeLayer(STATE.layers.kmlLayer); } catch {}
            STATE.layers.kmlLayer = null;
          }
          const layer = omnivore.kml.parse(txt);
          layer.eachLayer(l => { if (l?.options) l.options.interactive = false; });
          layer.addTo(STATE.map);
          STATE.layers.kmlLayer = layer;
          showSnackbar("KML importiert.");
        } catch (e) {
          console.error(e);
          showSnackbar("KML Import fehlgeschlagen.");
        }
      };
      reader.readAsText(file);
    }

    async function requestWakeLock() {
      try {
        if (!("wakeLock" in navigator)) { showSnackbar("Wake Lock nicht unterstützt."); return; }
        STATE.ui.wakeLock = await navigator.wakeLock.request("screen");
        showSnackbar("Wake Lock aktiv.");
        STATE.ui.wakeLock.addEventListener("release", () => {});
      } catch (e) {
        console.warn(e);
        showSnackbar("Wake Lock fehlgeschlagen.");
      }
    }

    /********************************************************************
     * Persistenz
     ********************************************************************/
    let _persistT = 0;
    function persistAllThrottled() {
      const t = now();
      if (t - _persistT < 1500) return;
      _persistT = t;
      persistAll();
    }

    function persistAll() {
      try {
        const payload = {
          version: APP.version,
          ui: { followGps: STATE.ui.followGps, base: STATE.ui.base },
          wind: { layers: STATE.wind.layers },
          task: { active: STATE.task.active },
          flight: {
            active: STATE.flight.active,
            title: STATE.flight.title,
            startedTs: STATE.flight.startedTs,
            track: STATE.flight.track,
            markers: STATE.flight.markers,
            archive: STATE.flight.archive,
          },
          sim: { enabled: STATE.sim.enabled },
          waypoint: { active: STATE.waypoint.active },
        };
        localStorage.setItem(APP.storageKey, JSON.stringify(payload));
      } catch {}
    }

    function restoreAll() {
      try {
        const raw = localStorage.getItem(APP.storageKey);
        if (!raw) return;
        const j = JSON.parse(raw);

        if (j.ui) {
          STATE.ui.followGps = !!j.ui.followGps;
          STATE.ui.base = j.ui.base === "sat" ? "sat" : "osm";
        }
        if (j.wind && Array.isArray(j.wind.layers)) {
          STATE.wind.layers = j.wind.layers.filter(x => x && isFinite(x.altM));
        }
        if (j.task) {
          STATE.task.active = j.task.active || null;
        }
        if (j.flight) {
          STATE.flight.active = !!j.flight.active;
          STATE.flight.title = j.flight.title || "";
          STATE.flight.startedTs = j.flight.startedTs || 0;
          STATE.flight.track = Array.isArray(j.flight.track) ? j.flight.track : [];
          STATE.flight.markers = Array.isArray(j.flight.markers) ? j.flight.markers : [];
          STATE.flight.archive = Array.isArray(j.flight.archive) ? j.flight.archive : [];
        }
        if (j.sim) STATE.sim.enabled = !!j.sim.enabled;
        if (j.waypoint) STATE.waypoint.active = j.waypoint.active || null;
      } catch {}
    }

    function restoreFormFromTask(task) {
      if (!task) return;
      const typeSel = document.getElementById("taskType");
      const titleIn = document.getElementById("taskTitle");
      if (typeSel) typeSel.value = task.code;
      if (titleIn) titleIn.value = task.title || "";

      renderTaskFieldsForCode(task.code);

      const setVal = (id, val) => { const el = document.getElementById(id); if (el && val != null) el.value = val; };

      if (task.points && task.points[0]) { setVal("taskALat", task.points[0].lat); setVal("taskALon", task.points[0].lon); }
      if (task.points && task.points[1]) { setVal("taskBLat", task.points[1].lat); setVal("taskBLon", task.points[1].lon); }
      if (task.points && task.points[2]) { setVal("taskCLat", task.points[2].lat); setVal("taskCLon", task.points[2].lon); }

      setVal("taskR1", task.r1M);
      setVal("taskR2", task.r2M);
      setVal("taskMinAlt", task.minAltM);
      setVal("taskMaxAlt", task.maxAltM);
      setVal("taskSetDir", task.setDirDeg);

      syncPickMarkersFromInputs();
    }

    /********************************************************************
     * 6) EVENT-LISTENER & INITIALISIERUNG (window.onload am Ende)
     ********************************************************************/
    window.onload = () => {
      initManifestAndSW();
      restoreAll();

      initMap();
      setBaseLayer(STATE.ui.base);

      renderTaskTypeOptions();
      renderTaskFieldsForCode(document.getElementById("taskType")?.value || "JDG");

      // Restore task
      if (STATE.task.active) {
        restoreFormFromTask(STATE.task.active);
        drawTaskOnMap(STATE.task.active);
        setMarkerButtonColor(STATE.task.active.code);
      } else {
        setMarkerButtonColor("x");
      }

      // Restore flight visuals if active
      if (STATE.flight.active) {
        try { STATE.layers.trackLine?.setLatLngs((STATE.flight.track||[]).map(p => [p.lat,p.lon])); } catch {}
        try {
          (STATE.flight.markers||[]).forEach(m => {
            const color = COLOR_HEX[m.color] || COLOR_HEX.pink;
            L.circleMarker([m.lat,m.lon], { radius:8, color, weight:3, fillColor:color, fillOpacity:0.25, interactive:false })
              .addTo(STATE.layers.markersLayer);
          });
        } catch {}
      }

      // Restore waypoint
      if (STATE.waypoint.active) {
        drawWaypoint();
      }

      // Initial renders
      updateGpsBadge();
      updateButtons();
      updateInstruments();
      updateNavToast();
      updateWindHud();
      updateWindPanel();
      updateArchivePanel();
      updateElbowResult();
      updateFollowToggleUi();
      rebuildTrajectory();

      // Tabs
      document.querySelectorAll(".tabBtn").forEach(b => {
        b.addEventListener("click", () => {
          STATE.ui.drawerTab = b.getAttribute("data-tab");
          updateDrawerTabUi();
        });
      });

      // Drawer open/close
      document.getElementById("btnMenu")?.addEventListener("click", () => openDrawer(true));
      document.getElementById("btnDrawerClose")?.addEventListener("click", () => openDrawer(false));
      document.getElementById("drawerBg")?.addEventListener("click", () => openDrawer(false));

      // Header buttons
      document.getElementById("btnWindHud")?.addEventListener("click", () => { STATE.ui.windHudOpen = !STATE.ui.windHudOpen; updateWindHud(); });
      document.getElementById("btnWindClose")?.addEventListener("click", () => { STATE.ui.windHudOpen = false; updateWindHud(); });
      document.getElementById("btnWindFetch")?.addEventListener("click", fetchWindFromOpenMeteo);

      document.getElementById("btnMapSettings")?.addEventListener("click", () => openMapModal(true));
      document.getElementById("btnMapModalClose")?.addEventListener("click", () => openMapModal(false));
      document.getElementById("mapModalBg")?.addEventListener("click", () => openMapModal(false));

      document.getElementById("btnBaseOSM")?.addEventListener("click", () => { setBaseLayer("osm"); persistAll(); });
      document.getElementById("btnBaseSAT")?.addEventListener("click", () => { setBaseLayer("sat"); persistAll(); });

      document.getElementById("btnCenter")?.addEventListener("click", centerOnPos);

      document.getElementById("tglFollow")?.addEventListener("change", (e) => {
        STATE.ui.followGps = !!e.target.checked;
        updateFollowToggleUi();
        persistAll();
      });

      // Flight controls
      document.getElementById("btnStartFlight")?.addEventListener("click", () => {
        const t = STATE.task.active;
        const title = t ? `${t.code} — ${t.title || t.typeTitle}` : "Fahrt";
        beginFlight(title);
      });
      document.getElementById("btnFinish")?.addEventListener("click", finishFlight);

      // Marker
      document.getElementById("btnMarker")?.addEventListener("click", dropMarker);

      // Task
      document.getElementById("taskType")?.addEventListener("change", (e) => {
        const code = e.target.value;
        renderTaskFieldsForCode(code);
        setMarkerButtonColor(code);
        persistAll();
      });
      document.getElementById("btnApplyTask")?.addEventListener("click", applyTask);
      document.getElementById("btnClearTask")?.addEventListener("click", clearTask);

      // ELB helper
      document.getElementById("btnSetA")?.addEventListener("click", () => setHelperPoint("A"));
      document.getElementById("btnSetB")?.addEventListener("click", () => setHelperPoint("B"));
      document.getElementById("btnSetC")?.addEventListener("click", () => setHelperPoint("C"));

      // Wind panel
      document.getElementById("btnAddWind")?.addEventListener("click", () => {
        const alt = safeFloat(document.getElementById("windAlt")?.value, null);
        const dir = safeFloat(document.getElementById("windDirFrom")?.value, null);
        const spd = safeFloat(document.getElementById("windSpd")?.value, null);
        if (alt == null || dir == null || spd == null) { showSnackbar("Wind: Werte fehlen."); return; }
        addWindLayer({ altM: alt, fromDeg: dir, speedKmh: spd, ts: now(), source: "manual" });
      });
      document.getElementById("btnClearWind")?.addEventListener("click", () => {
        STATE.wind.layers = [];
        persistAll();
        updateWindPanel();
        updateWindHud();
        updateNavToast();
        rebuildTrajectory();
        showSnackbar("Wind gelöscht.");
      });

      // Setup
      const tglSim = document.getElementById("tglSim");
      const knobSim = document.getElementById("tglSimKnob");
      if (tglSim && knobSim) setToggleUI(tglSim, knobSim, STATE.sim.enabled);
      tglSim?.addEventListener("change", (e) => {
        if (tglSim && knobSim) setToggleUI(tglSim, knobSim, e.target.checked);
        initSimulationToggle(e.target.checked);
      });

      document.getElementById("btnWakeLock")?.addEventListener("click", requestWakeLock);
      document.getElementById("btnResetUi")?.addEventListener("click", () => {
        STATE.ui.followGps = true;
        STATE.ui.windHudOpen = false;
        updateFollowToggleUi();
        updateWindHud();
        showSnackbar("UI zurückgesetzt.");
        persistAll();
      });

      document.getElementById("btnClearWaypoint")?.addEventListener("click", clearWaypoint);

      document.getElementById("kmlFile")?.addEventListener("change", (e) => {
        const f = e.target.files?.[0];
        importKmlFile(f);
      });

      // Archive
      document.getElementById("btnClearArchive")?.addEventListener("click", () => {
        STATE.flight.archive = [];
        persistAll();
        updateArchivePanel();
        showSnackbar("Archiv gelöscht.");
      });

      // Sim controls press & hold
      const press = (el, onDown, onUp) => {
        if (!el) return;
        el.addEventListener("pointerdown", (e)=>{ e.preventDefault(); onDown(true); });
        el.addEventListener("pointerup",   (e)=>{ e.preventDefault(); onUp(false); });
        el.addEventListener("pointercancel",(e)=>{ e.preventDefault(); onUp(false); });
        el.addEventListener("pointerleave",()=>{ onUp(false); });
      };
      press(document.getElementById("btnBurner"), handleBurner, handleBurner);
      press(document.getElementById("btnVent"), handleVent, handleVent);

      // WakeLock reacquire
      document.addEventListener("visibilitychange", () => {
        if (document.visibilityState === "visible" && STATE.ui.wakeLock) requestWakeLock();
      });

      // Start GPS unless simulation
      if (STATE.sim.enabled) initSimulationToggle(true);
      else initGPS();

      // Final UI pass
      updateButtons();
      updateGpsBadge();
      updateNavToast();
      updateWindPanel();
      updateArchivePanel();
    };
  </script>
</body>
</html>
