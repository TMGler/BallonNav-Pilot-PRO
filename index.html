<!DOCTYPE html>
<html lang="de">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AeroNav Balloon Pilot</title>
    <meta name="theme-color" content="#000000">
    <link rel="manifest" href="manifest.json">
    
    <!-- External Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <style>
        /* Custom Glassmorphism & UI Tweaks */
        body { overscroll-behavior: none; user-select: none; }
        .glass-panel {
            background: rgba(15, 23, 42, 0.85);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.37);
        }
        .hud-value { font-variant-numeric: tabular-nums; letter-spacing: 0.05em; }
        
        /* Map Controls Override */
        .leaflet-control-zoom { display: none; } 
        
        /* Wind Layer Bar */
        .wind-bar-item.active { border-left: 4px solid #10b981; background: rgba(16, 185, 129, 0.2); }
        
        /* Physics Controls */
        .control-btn:active { transform: scale(0.95); }
        
        /* Utility */
        .hidden-ui { display: none !important; }

        /* KML Label Style */
        .airspace-label {
            background: transparent;
            border: none;
            box-shadow: none;
            color: rgba(255,255,255,0.7);
            font-weight: bold;
            font-size: 10px;
            text-shadow: 1px 1px 2px black;
        }

        /* Dark Mode Popups - FIX: Aggressive Overrides for Readability */
        .leaflet-popup-content-wrapper, .leaflet-popup-tip {
            background-color: #111827 !important; /* gray-900 */
            color: #f3f4f6 !important; /* gray-100 */
            border: 1px solid #374151; /* gray-700 */
            backdrop-filter: blur(4px);
        }
        
        /* Force text color for generic content */
        .leaflet-popup-content, 
        .leaflet-popup-content p, 
        .leaflet-popup-content div,
        .leaflet-popup-content span,
        .leaflet-popup-content li,
        .leaflet-popup-content font { 
            color: #f3f4f6 !important;
        }

        /* CRITICAL FIX FOR KML TABLES */
        .leaflet-popup-content table,
        .leaflet-popup-content tbody,
        .leaflet-popup-content tr,
        .leaflet-popup-content td, 
        .leaflet-popup-content th {
            background-color: transparent !important;
            background: transparent !important;
            color: #f3f4f6 !important;
            border-color: #4b5563 !important; /* gray-600 */
        }

        .leaflet-popup-content table {
            width: 100% !important;
            border-collapse: collapse !important;
            margin-top: 0.5rem;
        }

        .leaflet-popup-content td, 
        .leaflet-popup-content th {
            border: 1px solid #374151 !important; /* gray-700 */
            padding: 4px 8px !important;
            font-size: 0.8rem !important;
        }
        
        .leaflet-popup-content th {
            font-weight: bold !important;
            color: #93c5fd !important; /* blue-300 */
            background-color: rgba(255, 255, 255, 0.05) !important;
        }

        .leaflet-container a.leaflet-popup-close-button {
            color: #9ca3af !important;
            font-size: 18px !important;
            padding: 8px !important;
        }
        
        .leaflet-container a.leaflet-popup-close-button:hover {
            color: #ffffff !important;
        }
    </style>
</head>
<body class="bg-gray-900 text-white h-screen w-screen overflow-hidden font-sans">

    <!-- MAP CONTAINER -->
    <div id="map" class="absolute inset-0 z-0 bg-black"></div>

    <!-- LOADING OVERLAY -->
    <div id="loading-overlay" class="hidden absolute inset-0 z-50 bg-black/80 flex flex-col items-center justify-center">
        <i class="fas fa-circle-notch fa-spin text-4xl text-blue-500 mb-4"></i>
        <div id="loading-text">Verarbeite KML Daten...</div>
    </div>

    <!-- HUD (Head Up Display) -->
    <div id="hud-top" class="absolute top-0 left-0 right-0 p-2 z-20 flex justify-between items-start pointer-events-none">
        <!-- Main Flight Instruments -->
        <div class="glass-panel rounded-xl p-3 flex gap-4 pointer-events-auto">
            <div class="text-center w-20">
                <div class="text-xs text-gray-400">HÖHE (m)</div>
                <div id="hud-alt" class="text-3xl font-bold hud-value">0</div>
            </div>
            <div class="text-center w-20">
                <div class="text-xs text-gray-400">GS (km/h)</div>
                <div id="hud-speed" class="text-3xl font-bold hud-value">0</div>
            </div>
            <div class="text-center w-20">
                <div class="text-xs text-gray-400">VARIO (m/s)</div>
                <div id="hud-vario" class="text-3xl font-bold hud-value text-gray-300">0.0</div>
            </div>
            <div class="text-center w-16">
                <div class="text-xs text-gray-400">TRACK</div>
                <div id="hud-heading" class="text-2xl font-bold hud-value">0°</div>
            </div>
        </div>

        <!-- Status & Mode -->
        <div class="glass-panel rounded-xl p-2 px-4 flex flex-col gap-1 items-end pointer-events-auto">
            <div id="gps-status" class="text-xs text-blue-400 font-bold">SIMULATION</div>
            <div id="rec-status" class="hidden text-xs text-red-500 animate-pulse font-bold"><i class="fas fa-circle"></i> REC</div>
            <div class="text-xs text-blue-300 cursor-pointer hover:text-white" onclick="app.toggleSettings()"><i class="fas fa-cog"></i> SETUP</div>
        </div>
    </div>

    <!-- Wind Layer Sidebar (Right) -->
    <div class="absolute right-0 top-1/4 bottom-1/4 w-16 z-20 flex flex-col items-end pointer-events-none">
        <div id="wind-layers" class="glass-panel rounded-l-xl h-full w-full flex flex-col pointer-events-auto overflow-y-auto text-xs">
            <!-- Dynamic Wind Layers inserted here -->
        </div>
    </div>

    <!-- Simulation Controls (Bottom Center) -->
    <div id="sim-controls" class="absolute bottom-6 left-1/2 transform -translate-x-1/2 z-30 flex gap-6">
        <button id="btn-valve" class="control-btn glass-panel w-20 h-20 rounded-full flex flex-col items-center justify-center border-red-500/50 hover:bg-red-900/40 text-red-300 active:bg-red-700">
            <i class="fas fa-arrow-down text-2xl"></i>
            <span class="text-xs font-bold mt-1">VENTIL</span>
        </button>
        <button id="btn-burner" class="control-btn glass-panel w-20 h-20 rounded-full flex flex-col items-center justify-center border-green-500/50 hover:bg-green-900/40 text-green-300 active:bg-green-600">
            <i class="fas fa-fire text-2xl"></i>
            <span class="text-xs font-bold mt-1">BRENNER</span>
        </button>
    </div>

    <!-- Main Toolbar (Bottom) -->
    <div class="absolute bottom-6 left-6 z-30 flex flex-col gap-3">
        <!-- New Center/Follow Button -->
        <button id="btn-center" onclick="app.toggleFollow()" class="glass-panel p-3 rounded-full hover:bg-blue-900/50 w-12 h-12 flex items-center justify-center text-blue-400" title="Karte zentrieren">
            <i class="fas fa-crosshairs"></i>
        </button>
        
        <button id="btn-record" onclick="app.logbook.toggleRecording()" class="glass-panel p-3 rounded-full hover:bg-red-900/50 w-12 h-12 flex items-center justify-center hidden" title="Record Track">
            <i id="icon-record" class="fas fa-circle text-gray-400"></i>
        </button>
        
        <button onclick="app.ui.cycleMapLayer()" class="glass-panel p-3 rounded-full hover:bg-gray-700 w-12 h-12 flex items-center justify-center" title="Kartenstil wechseln">
            <i class="fas fa-layer-group"></i>
        </button>
        
         <button onclick="app.ai.openAssistant()" class="glass-panel p-3 rounded-full border-blue-400 border hover:bg-blue-900/50 w-12 h-12 flex items-center justify-center text-blue-300 shadow-[0_0_15px_rgba(59,130,246,0.5)]" title="AI Assistant">
            <i class="fas fa-sparkles"></i>
        </button>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settings-modal" class="hidden absolute inset-0 z-50 bg-black/80 backdrop-blur-sm flex items-center justify-center">
        <div class="glass-panel p-6 rounded-2xl w-full max-w-md m-4 max-h-[90vh] overflow-y-auto">
            <h2 class="text-2xl font-bold mb-4 border-b border-gray-700 pb-2">Einstellungen</h2>
            
            <div class="mb-4 flex justify-between items-center border-b border-gray-700 pb-4">
                <label class="block text-sm text-gray-200 font-bold">Simulations-Modus</label>
                <label class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="sim-toggle-check" class="sr-only peer" checked onchange="app.toggleSimulation()">
                    <div class="w-11 h-6 bg-gray-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-blue-600"></div>
                </label>
            </div>

            <div class="mb-4">
                <label class="block text-sm text-gray-400 mb-1">HUD Transparenz</label>
                <input type="range" min="0.0" max="0.95" step="0.05" value="0.85" class="w-full" oninput="app.ui.updateOpacity(this.value)">
            </div>

            <div class="mb-4">
                <label class="block text-sm text-gray-400 mb-1">Gemini API Key (Optional)</label>
                <input type="password" id="api-key" placeholder="AI Studio Key eingeben..." class="w-full bg-gray-800 border border-gray-600 rounded p-2 text-white text-sm">
            </div>

            <div class="mb-4">
                <label class="block text-sm text-gray-400 mb-1">Daten Import (KML/GPX)</label>
                <div class="flex items-center justify-center w-full">
                    <label for="dropzone-file" class="flex flex-col items-center justify-center w-full h-24 border-2 border-gray-600 border-dashed rounded-lg cursor-pointer bg-gray-800 hover:bg-gray-700">
                        <div class="flex flex-col items-center justify-center pt-5 pb-6">
                            <i class="fas fa-cloud-upload-alt text-2xl mb-2 text-gray-400"></i>
                            <p class="text-xs text-gray-400">Klicke zum Laden von KML (Lufträume/Plätze)</p>
                        </div>
                        <input id="dropzone-file" type="file" accept=".kml,.gpx,.xml" class="hidden" onchange="app.data.handleKML(this.files[0])" />
                    </label>
                </div>
            </div>

            <div class="mt-6 flex justify-end">
                <button onclick="app.toggleSettings()" class="bg-gray-700 hover:bg-gray-600 px-4 py-2 rounded">Schließen</button>
            </div>
        </div>
    </div>

    <!-- AI ASSISTANT PANEL -->
    <div id="ai-panel" class="hidden absolute right-4 bottom-24 z-40 w-80">
        <div class="glass-panel p-4 rounded-xl">
            <div class="flex justify-between items-center mb-2">
                <h3 class="font-bold text-blue-300"><i class="fas fa-robot mr-1"></i> Gemini Co-Pilot</h3>
                <button onclick="app.ai.close()" class="text-gray-400 hover:text-white"><i class="fas fa-times"></i></button>
            </div>
            <div id="ai-output" class="text-sm text-gray-200 mb-3 min-h-[50px] max-h-[200px] overflow-y-auto">
                Bereit für Anweisungen. Rechtsklick auf Karte setzt Ziel.
            </div>
            <div class="flex gap-2">
                <button onclick="app.ai.analyzeWind()" class="flex-1 bg-purple-700/50 hover:bg-purple-600/50 border border-purple-500 rounded px-2 py-1 text-xs">
                    Wind Analyse
                </button>
                <button onclick="app.ai.generateLogSummary()" class="flex-1 bg-green-700/50 hover:bg-green-600/50 border border-green-500 rounded px-2 py-1 text-xs">
                    Logbuch
                </button>
            </div>
        </div>
    </div>

    <!-- JAVASCRIPT LOGIC -->
    <script>
        // --- GLOBAL CONSTANTS & CONFIG ---
        const CONSTANTS = {
            GRAVITY: 9.81,
            AIR_DENSITY: 1.225,
            BALLOON_MASS: 450, // kg (basket + envelope + fuel)
            OSM_API: 'https://overpass-api.de/api/interpreter'
        };

        // --- APP STATE ---
        const state = {
            mode: 'simulation', // 'gps' or 'simulation'
            recording: false,
            gpsLocked: false,
            position: { lat: 50.1109, lng: 8.6821, alt: 0 }, // Default Frankfurt
            velocity: { h: 0, v: 0, heading: 0 },
            history: [],
            windLayers: [], // { minAlt, maxAlt, speed, dir }
            target: null,
            trackPoints: [],
            apiKey: localStorage.getItem('gemini_key') || '',
            autoFollow: true // NEW: Controls whether map follows balloon
        };

        // --- WIND MODEL ---
        class WindManager {
            constructor() {
                this.generateWindProfile(state.position.lat, state.position.lng, false);
            }

            generateWindProfile(lat, lng, updateUI = true) {
                const baseDir = (lat + lng) % 360; 
                state.windLayers = [
                    { min: 0, max: 200, speed: 5, dir: baseDir, label: 'Boden' },
                    { min: 200, max: 500, speed: 12, dir: (baseDir + 20) % 360, label: '500m' },
                    { min: 500, max: 1000, speed: 25, dir: (baseDir + 45) % 360, label: '1000m' },
                    { min: 1000, max: 2000, speed: 35, dir: (baseDir + 90) % 360, label: '2000m' },
                    { min: 2000, max: 9000, speed: 55, dir: (baseDir + 120) % 360, label: 'High' }
                ];
                
                if (updateUI && typeof app !== 'undefined' && app.ui) {
                    app.ui.renderWindSidebar();
                }
            }

            getCurrentWind(alt) {
                const layer = state.windLayers.find(l => alt >= l.min && alt < l.max) || state.windLayers[state.windLayers.length - 1];
                return layer;
            }
        }

        // --- PHYSICS ENGINE ---
        class Physics {
            constructor() {
                this.burnerOn = false;
                this.valveOpen = false;
                this.lastUpdate = Date.now();
                this.loop = this.loop.bind(this);
            }

            start() {
                this.lastUpdate = Date.now();
                requestAnimationFrame(this.loop);
            }

            setControls(burner, valve) {
                this.burnerOn = burner;
                this.valveOpen = valve;
            }

            loop() {
                const now = Date.now();
                const dt = (now - this.lastUpdate) / 1000;
                this.lastUpdate = now;

                if (state.mode === 'simulation') {
                    // Vertical Physics
                    let lift = 0;
                    if (this.burnerOn) lift = 2.5; 
                    else if (this.valveOpen) lift = -3.0; 
                    else lift = -0.15; 

                    state.velocity.v += (lift - state.velocity.v * 0.5) * dt; 
                    state.position.alt += state.velocity.v * dt;
                    if (state.position.alt < 0) { state.position.alt = 0; state.velocity.v = 0; }

                    // Horizontal Physics (Wind Drift)
                    if (state.position.alt > 10) { 
                        const wind = app.wind.getCurrentWind(state.position.alt);
                        state.velocity.h = wind.speed;
                        state.velocity.heading = wind.dir;

                        const dist = (state.velocity.h / 3.6) * dt; 
                        const R = 6378137; 
                        const dn = dist * Math.cos(wind.dir * Math.PI / 180);
                        const de = dist * Math.sin(wind.dir * Math.PI / 180);

                        state.position.lat += (dn / R) * (180 / Math.PI);
                        state.position.lng += (de / R) * (180 / Math.PI) / Math.cos(state.position.lat * Math.PI / 180);
                    } else {
                        state.velocity.h = 0;
                    }

                    app.updateLocation(state.position);
                }
                
                requestAnimationFrame(this.loop);
            }
        }

        // --- UI MANAGER ---
        class UIManager {
            constructor() {
                this.map = null;
                this.markers = {};
                this.baseLayers = {};
                this.currentLayerIndex = 0;
                this.layerKeys = ['dark', 'light', 'sat'];
            }

            initMap() {
                // Define Layers
                this.baseLayers.dark = L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
                    attribution: '&copy; CARTO', subdomains: 'abcd', maxZoom: 19
                });
                this.baseLayers.light = L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                     attribution: '&copy; OpenStreetMap'
                });
                this.baseLayers.sat = L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
                    attribution: '&copy; ESRI'
                });

                // Initialize Map
                this.map = L.map('map', { 
                    zoomControl: false,
                    layers: [this.baseLayers.dark] // Default
                }).setView([state.position.lat, state.position.lng], 13);

                // Balloon Marker
                const balloonIcon = L.divIcon({
                    html: '<div style="font-size: 24px; color: #ff4500; text-shadow: 0 0 10px #ff0000; transition: transform 0.5s;"><i class="fas fa-hotair-balloon"></i></div>',
                    className: 'balloon-marker',
                    iconSize: [24, 30],
                    iconAnchor: [12, 30]
                });

                this.markers.balloon = L.marker([state.position.lat, state.position.lng], {icon: balloonIcon}).addTo(this.map);
                this.markers.track = L.polyline([], {color: 'red', weight: 3}).addTo(this.map);
                this.markers.vector = L.polyline([], {color: 'deepskyblue', dashArray: '5, 10', weight: 2}).addTo(this.map);

                // KML Layer Group
                this.markers.kmlLayer = L.layerGroup().addTo(this.map);

                // Events
                this.map.on('contextmenu', (e) => {
                    this.setTarget(e.latlng);
                });
                
                // --- FIX: Detect Dragging to disable Auto-Follow ---
                this.map.on('dragstart', () => {
                    state.autoFollow = false;
                    app.ui.updateFollowButton();
                });
            }

            cycleMapLayer() {
                // Remove current
                const currentKey = this.layerKeys[this.currentLayerIndex];
                this.map.removeLayer(this.baseLayers[currentKey]);

                // Next index
                this.currentLayerIndex = (this.currentLayerIndex + 1) % this.layerKeys.length;
                const nextKey = this.layerKeys[this.currentLayerIndex];

                // Add next
                this.map.addLayer(this.baseLayers[nextKey]);
                
                console.log("Layer switched to:", nextKey);
            }

            updateHUD() {
                document.getElementById('hud-alt').innerText = Math.round(state.position.alt);
                document.getElementById('hud-speed').innerText = Math.round(state.velocity.h);
                document.getElementById('hud-heading').innerText = Math.round(state.velocity.heading) + '°';
                
                const varioEl = document.getElementById('hud-vario');
                const v = state.velocity.v.toFixed(1);
                varioEl.innerText = (state.velocity.v > 0 ? '+' : '') + v;
                
                if (state.velocity.v > 0.5) varioEl.className = 'text-3xl font-bold hud-value text-green-400';
                else if (state.velocity.v < -0.5) varioEl.className = 'text-3xl font-bold hud-value text-red-400';
                else varioEl.className = 'text-3xl font-bold hud-value text-gray-300';

                // Wind Highlight
                const activeWind = app.wind.getCurrentWind(state.position.alt);
                document.querySelectorAll('.wind-bar-item').forEach(el => el.classList.remove('active'));
                const activeEl = document.getElementById(`wind-${activeWind.min}`);
                if (activeEl) activeEl.classList.add('active');
            }

            renderWindSidebar() {
                const container = document.getElementById('wind-layers');
                container.innerHTML = '';
                [...state.windLayers].reverse().forEach(layer => {
                    const el = document.createElement('div');
                    el.id = `wind-${layer.min}`;
                    el.className = 'wind-bar-item p-2 border-b border-gray-700/50 flex flex-col justify-center h-16 transition-all';
                    el.innerHTML = `
                        <div class="text-[10px] text-gray-400">${layer.label}</div>
                        <div class="flex items-center justify-between">
                            <i class="fas fa-arrow-up transform rotate-[${layer.dir}deg] text-gray-200" style="transform: rotate(${layer.dir}deg)"></i>
                            <span class="font-bold text-gray-200">${layer.speed} <span class="text-[9px]">km/h</span></span>
                        </div>
                    `;
                    container.appendChild(el);
                });
            }

            updateMap(pos) {
                if (!this.markers.balloon) return;

                const latLng = [pos.lat, pos.lng];
                this.markers.balloon.setLatLng(latLng);
                
                if (state.recording) {
                    this.markers.track.addLatLng(latLng);
                }

                // Vector Projection
                const wind = app.wind.getCurrentWind(pos.alt);
                const dist5min = (wind.speed / 3.6) * 300; 
                const R = 6378137;
                const dn = dist5min * Math.cos(wind.dir * Math.PI / 180);
                const de = dist5min * Math.sin(wind.dir * Math.PI / 180);
                const pLat = pos.lat + (dn / R) * (180 / Math.PI);
                const pLng = pos.lng + (de / R) * (180 / Math.PI) / Math.cos(pos.lat * Math.PI / 180);
                
                this.markers.vector.setLatLngs([latLng, [pLat, pLng]]);
                
                // --- FIX: Only auto-pan if Auto-Follow is active ---
                if (state.mode === 'simulation' && state.autoFollow) {
                    this.map.panTo(latLng);
                }
            }

            updateFollowButton() {
                const btn = document.getElementById('btn-center');
                if (state.autoFollow) {
                    btn.classList.add('text-blue-400');
                    btn.classList.remove('text-gray-400');
                } else {
                    btn.classList.add('text-gray-400');
                    btn.classList.remove('text-blue-400');
                }
            }

            setTarget(latlng) {
                if (this.markers.target) this.map.removeLayer(this.markers.target);
                this.markers.target = L.marker(latlng, {
                    icon: L.divIcon({html: '<i class="fas fa-flag-checkered text-yellow-400 text-2xl"></i>', className: 'target-icon'})
                }).addTo(this.map);
                state.target = latlng;
                app.ai.suggestCourse();
            }

            updateOpacity(val) {
                const blur = Math.round(val * 12); 
                
                document.querySelectorAll('.glass-panel').forEach(el => {
                    el.style.backgroundColor = `rgba(15, 23, 42, ${val})`;
                    el.style.backdropFilter = `blur(${blur}px)`;
                    el.style.webkitBackdropFilter = `blur(${blur}px)`;
                    
                    const borderAlpha = Math.max(0.05, val * 0.2);
                    el.style.borderColor = `rgba(255, 255, 255, ${borderAlpha})`;
                    
                    if (val < 0.2) {
                        el.style.boxShadow = 'none';
                    } else {
                        el.style.boxShadow = '0 8px 32px 0 rgba(0, 0, 0, 0.37)';
                    }
                });
            }
        }

        // --- DATA & AI ---
        class DataManager {
            constructor() {}

            loadStoredKML() {
                const storedData = localStorage.getItem('aeronav_kml_data');
                if (storedData) {
                    console.log("Lade gespeicherte KML Daten...");
                    try {
                        const parser = new DOMParser();
                        const kml = parser.parseFromString(storedData, 'text/xml');
                        this.parseKML(kml, true); 
                    } catch (e) {
                        console.error("Fehler beim Laden der gespeicherten KML", e);
                        localStorage.removeItem('aeronav_kml_data');
                    }
                }
            }

            handleKML(file) {
                if (!file) return;
                
                document.getElementById('loading-overlay').classList.remove('hidden');

                const reader = new FileReader();
                reader.onload = (e) => {
                    try {
                        const text = e.target.result;
                        try {
                            localStorage.setItem('aeronav_kml_data', text);
                        } catch (quotaErr) {
                            console.warn("Storage Limit erreicht:", quotaErr);
                            alert("Hinweis: Datei ist zu groß für den permanenten Speicher. Sie wird nur für diese Sitzung geladen.");
                        }

                        const parser = new DOMParser();
                        const kml = parser.parseFromString(text, 'text/xml');
                        this.parseKML(kml, false); 
                    } catch(err) {
                        alert("Fehler beim Lesen der KML: " + err);
                    } finally {
                        document.getElementById('loading-overlay').classList.add('hidden');
                        app.toggleSettings(); 
                    }
                };
                reader.readAsText(file);
            }

            parseKML(xmlDoc, silent = false) {
                const placemarks = xmlDoc.getElementsByTagName('Placemark');
                const layerGroup = app.ui.markers.kmlLayer;
                layerGroup.clearLayers();

                let count = 0;

                for (let i = 0; i < placemarks.length; i++) {
                    const pm = placemarks[i];
                    const name = this.getNodeValue(pm, 'name') || 'Unbenannt';
                    const desc = this.getNodeValue(pm, 'description') || '';
                    
                    const popupContent = `
                        <div class="font-bold text-blue-400 mb-2 text-base border-b border-gray-600 pb-1 pr-4">${name}</div>
                        <div class="text-sm leading-relaxed max-h-60 overflow-y-auto text-gray-100 mt-1 space-y-1">
                            ${desc || '<span class="italic text-gray-400">Keine Details verfügbar.</span>'}
                        </div>
                    `;
                    
                    // 1. POINTS (Airfields)
                    const point = pm.getElementsByTagName('Point')[0];
                    if (point) {
                        const coords = this.getCoordinates(point);
                        if (coords) {
                            L.circleMarker([coords.lat, coords.lng], {
                                radius: 5,
                                color: '#ffffff',
                                fillColor: '#3b82f6',
                                fillOpacity: 0.9,
                                weight: 2
                            }).bindPopup(popupContent, {maxWidth: 300}).addTo(layerGroup);
                            count++;
                        }
                    }

                    // 2. POLYGONS (Airspaces)
                    const polygon = pm.getElementsByTagName('Polygon')[0];
                    if (polygon) {
                        const coords = this.getCoordinatesArray(polygon);
                        if (coords.length > 0) {
                            let color = '#3b82f6'; // Default Blue (TMZ/RMZ)
                            let weight = 1;
                            let dashArray = '5, 5';

                            const n = name.toUpperCase();
                            if (n.includes('CTR') || n.includes('ED-R') || n.includes('DANGER') || n.includes('PROHIBITED')) {
                                color = '#ef4444'; // Red (Danger)
                                weight = 2;
                                dashArray = null;
                            } else if (n.includes('C ') || n.includes('D ')) {
                                color = '#60a5fa'; // Light Blue (C/D)
                                weight = 1;
                            }

                            L.polygon(coords, {
                                color: color,
                                fillColor: color,
                                fillOpacity: 0.15,
                                weight: weight,
                                dashArray: dashArray
                            }).bindTooltip(name, {
                                permanent: true, 
                                direction: 'center', 
                                className: 'airspace-label'
                            }).bindPopup(popupContent, {maxWidth: 300}).addTo(layerGroup);
                            count++;
                        }
                    }
                }
                
                if (!silent) {
                    alert(`${count} Elemente importiert und gespeichert.`);
                }
            }

            getNodeValue(parent, tagName) {
                const node = parent.getElementsByTagName(tagName)[0];
                return node ? node.textContent : null;
            }

            getCoordinates(node) {
                const coordStr = node.getElementsByTagName('coordinates')[0]?.textContent;
                if (!coordStr) return null;
                const parts = coordStr.trim().split(',');
                return { lng: parseFloat(parts[0]), lat: parseFloat(parts[1]) };
            }

            getCoordinatesArray(node) {
                const coordStr = node.getElementsByTagName('coordinates')[0]?.textContent;
                if (!coordStr) return [];
                return coordStr.trim().split(/\s+/).map(pair => {
                    const parts = pair.split(',');
                    return [parseFloat(parts[1]), parseFloat(parts[0])]; 
                });
            }
        }

        class AIAssistant {
            openAssistant() {
                document.getElementById('ai-panel').classList.remove('hidden');
            }
            close() {
                document.getElementById('ai-panel').classList.add('hidden');
            }
            
            async suggestCourse() {
                if (!state.target) return;
                const msgEl = document.getElementById('ai-output');
                msgEl.innerHTML = '<i class="fas fa-spinner fa-spin"></i> Berechne optimalen Flugpfad...';

                const y = Math.sin(state.target.lng - state.position.lng) * Math.cos(state.target.lat);
                const x = Math.cos(state.position.lat) * Math.sin(state.target.lat) -
                        Math.sin(state.position.lat) * Math.cos(state.target.lat) * Math.cos(state.target.lng - state.position.lng);
                const bearing = (Math.atan2(y, x) * 180 / Math.PI + 360) % 360;

                let bestLayer = state.windLayers[0];
                let minDiff = 360;

                state.windLayers.forEach(layer => {
                    let diff = Math.abs(layer.dir - bearing);
                    if (diff > 180) diff = 360 - diff;
                    if (diff < minDiff) {
                        minDiff = diff;
                        bestLayer = layer;
                    }
                });

                setTimeout(() => {
                    const text = `Um Ziel (Kurs ${Math.round(bearing)}°) zu erreichen:<br>
                    <strong class="text-green-400">Steige/Sinke auf Schicht: ${bestLayer.label} (${bestLayer.min}-${bestLayer.max}m)</strong><br>
                    Dort Wind: ${bestLayer.dir}° mit ${bestLayer.speed} km/h.<br>
                    Abweichung: ${Math.round(minDiff)}°.`;
                    msgEl.innerHTML = text;
                }, 1000);
            }

            analyzeWind() {
                document.getElementById('ai-output').innerText = "Analysiere lokale Orographie... (Mock: Gute Thermik ab 14:00 erwartet).";
            }
            
            generateLogSummary() {
                 document.getElementById('ai-output').innerText = "Flugzusammenfassung: Ruhige Fahrt, maximale Höhe 1200m. Landung sicher.";
            }
        }

        class Logbook {
            toggleRecording() {
                state.recording = !state.recording;
                const btn = document.getElementById('rec-status');
                const btnUi = document.getElementById('btn-record');
                const icon = document.getElementById('icon-record');
                
                if (state.recording) {
                    btn.classList.remove('hidden');
                    icon.classList.remove('text-gray-400');
                    icon.classList.add('text-red-500');
                    btnUi.classList.add('bg-red-900/50'); // Active state UI
                    state.trackPoints = [];
                    app.ui.markers.track.setLatLngs([]);
                } else {
                    btn.classList.add('hidden');
                    icon.classList.add('text-gray-400');
                    icon.classList.remove('text-red-500');
                    btnUi.classList.remove('bg-red-900/50');
                }
            }
        }

        // --- MAIN APP CONTROLLER ---
        class App {
            constructor() {
                this.wind = new WindManager();
                this.physics = new Physics();
                this.ui = new UIManager();
                this.data = new DataManager();
                this.ai = new AIAssistant();
                this.logbook = new Logbook();
            }

            init() {
                this.ui.initMap();
                this.ui.renderWindSidebar();
                this.physics.start();
                this.data.loadStoredKML();
                
                // Controls
                const btnBurner = document.getElementById('btn-burner');
                const btnValve = document.getElementById('btn-valve');

                const startBurn = () => this.physics.setControls(true, false);
                const stopBurn = () => this.physics.setControls(false, false);
                const startValve = () => this.physics.setControls(false, true);
                const stopValve = () => this.physics.setControls(false, false);

                btnBurner.addEventListener('mousedown', startBurn);
                btnBurner.addEventListener('mouseup', stopBurn);
                btnBurner.addEventListener('touchstart', (e) => { e.preventDefault(); startBurn(); });
                btnBurner.addEventListener('touchend', stopBurn);

                btnValve.addEventListener('mousedown', startValve);
                btnValve.addEventListener('mouseup', stopValve);
                btnValve.addEventListener('touchstart', (e) => { e.preventDefault(); startValve(); });
                btnValve.addEventListener('touchend', stopValve);

                // Geolocation
                if ("geolocation" in navigator) {
                    navigator.geolocation.watchPosition((pos) => {
                        if (state.mode === 'gps') {
                            state.gpsLocked = true;
                            document.getElementById('gps-status').innerText = "GPS OK";
                            document.getElementById('gps-status').className = "text-xs text-green-400 font-bold";
                            
                            state.position.lat = pos.coords.latitude;
                            state.position.lng = pos.coords.longitude;
                            if (pos.coords.altitude) state.position.alt = pos.coords.altitude;
                            if (pos.coords.speed) state.velocity.h = pos.coords.speed * 3.6;
                            if (pos.coords.heading) state.velocity.heading = pos.coords.heading;
                            
                            this.updateLocation(state.position);
                        }
                    }, (err) => {
                        console.warn("GPS Error");
                    }, { enableHighAccuracy: true });
                }

                if ('serviceWorker' in navigator && (location.protocol === 'https:' || location.hostname === 'localhost')) {
                    navigator.serviceWorker.register('./sw.js').catch(console.log);
                }
            }

            updateLocation(pos) {
                this.ui.updateMap(pos);
                this.ui.updateHUD();
            }

            toggleSimulation() {
                const isSim = document.getElementById('sim-toggle-check').checked;
                state.mode = isSim ? 'simulation' : 'gps';
                
                const simControls = document.getElementById('sim-controls');
                const recBtn = document.getElementById('btn-record');
                
                if (state.mode === 'simulation') {
                    simControls.classList.remove('hidden'); 
                    recBtn.classList.add('hidden'); 
                    
                    document.getElementById('gps-status').innerText = "SIMULATION";
                    document.getElementById('gps-status').className = "text-xs text-blue-400 font-bold";
                    
                    if(state.recording) this.logbook.toggleRecording();

                } else {
                    simControls.classList.add('hidden'); 
                    recBtn.classList.remove('hidden'); 
                    
                    document.getElementById('gps-status').innerText = "WAITING GPS...";
                    document.getElementById('gps-status').className = "text-xs text-red-400 font-bold";
                }
            }

            toggleSettings() {
                const modal = document.getElementById('settings-modal');
                modal.classList.toggle('hidden');
                
                if (!modal.classList.contains('hidden')) {
                   document.getElementById('api-key').value = state.apiKey;
                   document.getElementById('sim-toggle-check').checked = (state.mode === 'simulation');
                } else {
                   state.apiKey = document.getElementById('api-key').value;
                   localStorage.setItem('gemini_key', state.apiKey);
                }
            }

            // NEW: Toggle Auto-Follow logic
            toggleFollow() {
                state.autoFollow = !state.autoFollow;
                this.ui.updateFollowButton();
                
                // If activated, immediately center map
                if (state.autoFollow) {
                    this.ui.map.panTo([state.position.lat, state.position.lng]);
                }
            }
        }

        const app = new App();
        window.addEventListener('load', () => app.init());

    </script>
</body>
</html>
