<!doctype html>
<html lang="de" class="h-full">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover" />
  <meta name="theme-color" content="#0b1220" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <meta name="mobile-web-app-capable" content="yes" />
  <title>CompNavAir</title>

  <!-- Single-file PWA manifest -->
  <link rel="manifest" href='data:application/manifest%2Bjson,%7B%22name%22%3A%22CompNavAir%22%2C%22short_name%22%3A%22CompNavAir%22%2C%22start_url%22%3A%22.%2F%22%2C%22scope%22%3A%22.%2F%22%2C%22display%22%3A%22standalone%22%2C%22background_color%22%3A%22%230b1220%22%2C%22theme_color%22%3A%22%230b1220%22%2C%22icons%22%3A%5B%7B%22src%22%3A%22data%3Aimage%2Fsvg%2Bxml%2C%253Csvg%2520xmlns%253D%2527http%253A%252F%252Fwww.w3.org%252F2000%252Fsvg%2527%2520viewBox%253D%25270%25200%2520200%2520200%2527%253E%253Crect%2520width%253D%2527200%2527%2520height%253D%2527200%2527%2520rx%253D%252740%2527%2520fill%253D%2527%230b1220%2527%252F%253E%253Cpath%2520d%253D%2527M100%252020c-28%25200-50%252022-50%252050%25200%252019%252010%252036%252026%252045l-4%252031h56h56l-4-31c16-9%252026-26%252026-45%25200-28-22-50-50-50z%2527%2520fill%253D%2527%2338bdf8%2527%252F%253E%253Crect%2520x%253D%252775%2527%2520y%253D%2527132%2527%2520width%253D%252750%2527%2520height%253D%252740%2527%2520rx%253D%25278%2527%2520fill%253D%2527%23f59e0b%2527%252F%253E%253C%252Fsvg%253E%22%2C%22sizes%22%3A%22192x192%22%2C%22type%22%3A%22image%2Fsvg%2Bxml%22%7D%5D%7D' />

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" crossorigin="" />
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js" crossorigin=""></script>

  <!-- Leaflet Omnivore (KML) -->
  <script src="https://unpkg.com/leaflet-omnivore@0.3.4/leaflet-omnivore.min.js"></script>

  <!-- Font Awesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

  <style>
    html, body { height: 100%; }
    body {
      margin: 0;
      background: #0b1220;
      color: #e5e7eb;
      overscroll-behavior: none;
      -webkit-tap-highlight-color: transparent;
      touch-action: manipulation;
    }
    #app { height: 100dvh; }
    .safe-top { padding-top: env(safe-area-inset-top); }
    .safe-bottom { padding-bottom: env(safe-area-inset-bottom); }

    .leaflet-control-attribution { display: none; }
    .leaflet-container { background: #0b1220; }

    .glass { backdrop-filter: blur(12px); -webkit-backdrop-filter: blur(12px); }

    /* Wind */
    .wind-arrow {
      width: 34px; height: 34px;
      border-radius: 9999px;
      display: grid; place-items: center;
      border: 1px solid rgba(148,163,184,.35);
      background: rgba(2,6,23,.55);
    }
    .wind-arrow i { font-size: 14px; }

    /* Bottom sheet states */
    #sheet { transition: transform .18s ease, height .18s ease; }
    .sheet-collapsed { height: 68px !important; }
    .sheet-expanded { height: min(62vh, 560px) !important; }
    .sheet-hidden { transform: translateY(120%); }

    /* KML popup styling */
    .kml-popup .leaflet-popup-content-wrapper {
      background: rgba(2, 6, 23, .92);
      color: #e5e7eb;
      border: 1px solid rgba(148,163,184,.25);
      border-radius: 14px;
    }
    .kml-popup .leaflet-popup-tip { background: rgba(2, 6, 23, .92); }
  </style>
</head>

<body class="h-full">
  <div id="app" class="flex flex-col h-full w-full">

    <!-- TOP BAR -->
    <header class="safe-top z-30 shrink-0">
      <div class="px-3 pt-2">
        <div class="glass bg-slate-950/60 border border-slate-700/30 rounded-2xl shadow-xl">
          <div class="h-14 px-3 flex items-center gap-2">
            <button id="btnPanel" class="w-10 h-10 rounded-xl bg-slate-900/50 border border-slate-700/30 active:scale-[0.98]" title="Panel">
              <i class="fa-solid fa-sliders"></i>
            </button>

            <div class="flex-1 min-w-0">
              <div class="flex items-center gap-2">
                <div class="font-semibold truncate">CompNavAir</div>
                <span id="gpsPill" class="text-[11px] px-2 py-0.5 rounded-full border border-slate-700/40 bg-slate-900/40 text-slate-200">
                  GPS: —
                </span>
              </div>
              <div id="statusLine" class="text-[11px] text-slate-200/80 truncate">
                Briefing planen → Start drücken, wenn du willst (kein Auto-Start).
              </div>
            </div>

            <button id="btnFollow" class="w-10 h-10 rounded-xl bg-slate-900/50 border border-slate-700/30 active:scale-[0.98]" title="Zentrieren/Folgen">
              <i class="fa-solid fa-location-crosshairs"></i>
            </button>

            <button id="btnLayer" class="w-10 h-10 rounded-xl bg-slate-900/50 border border-slate-700/30 active:scale-[0.98]" title="Kartenlayer">
              <i class="fa-solid fa-layer-group"></i>
            </button>

            <button id="btnFinish" class="hidden w-10 h-10 rounded-xl bg-emerald-500/20 border border-emerald-400/30 text-emerald-100 active:scale-[0.98]" title="Fahrt beenden">
              <i class="fa-solid fa-flag-checkered"></i>
            </button>
          </div>
        </div>
      </div>
    </header>

    <!-- MAP -->
    <main class="relative flex-1 min-h-0">
      <div id="map" class="absolute inset-0 z-0"></div>

      <!-- WIND PANEL (left edge, collapsible) -->
      <div id="windPanel" class="absolute z-20 left-2 top-20 safe-top">
        <div id="windPanelExpanded" class="glass bg-slate-950/55 border border-slate-700/30 rounded-2xl shadow-xl w-[210px]">
          <div class="px-2 pt-2 pb-1 flex items-center gap-2">
            <button id="btnWindCollapse" class="w-9 h-9 rounded-xl bg-slate-900/40 border border-slate-700/30">
              <i class="fa-solid fa-chevron-left"></i>
            </button>

            <div class="flex-1 min-w-0">
              <div class="text-[12px] font-semibold flex items-center gap-2">
                <span>Wind</span>
                <span id="windSrc" class="text-[10px] px-2 py-0.5 rounded-full border border-slate-700/30 bg-slate-900/30 text-slate-200/90">—</span>
              </div>
              <div class="text-[11px] text-slate-200/80 truncate" id="windMeta">—</div>
            </div>

            <button id="btnWindFetch" class="w-9 h-9 rounded-xl bg-sky-500/15 border border-sky-400/25 text-sky-100" title="Wind online abrufen (Open-Meteo)">
              <i class="fa-solid fa-cloud-arrow-down"></i>
            </button>
          </div>

          <div class="px-2 pb-2">
            <div class="flex items-center gap-2 p-2 rounded-xl bg-slate-900/25 border border-slate-700/20">
              <div class="wind-arrow">
                <i id="windArrowIcon" class="fa-solid fa-location-arrow"></i>
              </div>
              <div class="flex-1 min-w-0">
                <div class="text-[12px] font-semibold" id="windKeyLine">—</div>
                <div class="text-[11px] text-slate-200/75" id="windRecLine">—</div>
              </div>
            </div>

            <div class="mt-2 rounded-xl border border-slate-700/20 overflow-hidden">
              <div class="px-2 py-1 text-[11px] bg-slate-900/30 text-slate-200/80 flex justify-between">
                <span>Höhe</span><span>Richtung / Speed</span>
              </div>
              <div id="windRows" class="divide-y divide-slate-700/20"></div>
            </div>

            <div class="mt-2 p-2 rounded-xl bg-slate-900/25 border border-slate-700/20">
              <div class="text-[11px] text-slate-200/80">Navigation</div>
              <div class="text-[12px] font-semibold truncate" id="navInsideTitle">—</div>
              <div class="text-[12px] text-slate-100/90" id="navInsideLine">—</div>
            </div>
          </div>
        </div>

        <div id="windPanelCollapsed" class="hidden">
          <button id="btnWindExpand" class="glass w-12 h-12 rounded-2xl bg-slate-950/55 border border-slate-700/30 shadow-xl">
            <i class="fa-solid fa-wind"></i>
          </button>
        </div>
      </div>

      <!-- SIM CONTROLS (left) -->
      <div id="simControls" class="hidden absolute z-20 left-2 bottom-[118px] safe-bottom">
        <div class="glass bg-slate-950/55 border border-slate-700/30 rounded-2xl shadow-xl p-2 flex flex-col gap-2">
          <button id="btnBurn" class="w-24 h-14 rounded-2xl bg-amber-500/15 border border-amber-400/25 text-amber-100 font-semibold active:scale-[0.98]">
            <div class="text-[12px]"><i class="fa-solid fa-fire-flame-curved mr-2"></i>Burner</div>
            <div class="text-[11px] text-amber-100/80">Auf</div>
          </button>
          <button id="btnVent" class="w-24 h-14 rounded-2xl bg-sky-500/15 border border-sky-400/25 text-sky-100 font-semibold active:scale-[0.98]">
            <div class="text-[12px]"><i class="fa-solid fa-arrow-down mr-2"></i>Vent</div>
            <div class="text-[11px] text-sky-100/80">Ab</div>
          </button>
        </div>
      </div>

      <!-- BOTTOM SHEET PANEL (planning + live + setup + archive) -->
      <div id="sheet" class="absolute z-40 left-3 right-3 bottom-[94px] sheet-expanded">
        <div class="glass bg-slate-950/65 border border-slate-700/30 rounded-3xl shadow-2xl h-full overflow-hidden flex flex-col">
          <div class="px-3 pt-2 pb-1">
            <div class="flex items-center justify-between">
              <button id="btnSheetToggle" class="w-full flex items-center justify-center gap-2 py-1">
                <span class="w-10 h-1.5 rounded-full bg-slate-300/30"></span>
              </button>
            </div>

            <div class="mt-1 flex gap-2">
              <button class="tabBtn flex-1 h-10 rounded-2xl bg-indigo-500/15 border border-indigo-400/25 text-indigo-100 text-[12px] font-semibold" data-tab="briefing">
                <i class="fa-solid fa-clipboard-list mr-2"></i>Briefing
              </button>
              <button class="tabBtn flex-1 h-10 rounded-2xl bg-slate-900/30 border border-slate-700/25 text-slate-100 text-[12px] font-semibold" data-tab="live">
                <i class="fa-solid fa-plane-up mr-2"></i>Live
              </button>
              <button class="tabBtn flex-1 h-10 rounded-2xl bg-slate-900/30 border border-slate-700/25 text-slate-100 text-[12px] font-semibold" data-tab="setup">
                <i class="fa-solid fa-gear mr-2"></i>Setup
              </button>
              <button class="tabBtn flex-1 h-10 rounded-2xl bg-slate-900/30 border border-slate-700/25 text-slate-100 text-[12px] font-semibold" data-tab="archiv">
                <i class="fa-solid fa-box-archive mr-2"></i>Archiv
              </button>
            </div>
          </div>

          <div class="flex-1 overflow-auto px-3 pb-3">
            <div id="tab_briefing" class="tabPane"></div>
            <div id="tab_live" class="tabPane hidden"></div>
            <div id="tab_setup" class="tabPane hidden"></div>
            <div id="tab_archiv" class="tabPane hidden"></div>
          </div>
        </div>
      </div>

    </main>

    <!-- COCKPIT -->
    <footer class="safe-bottom z-30 shrink-0">
      <div class="px-3 pb-2">
        <div class="glass bg-slate-950/60 border border-slate-700/30 rounded-2xl shadow-xl">
          <div class="h-20 px-3 flex items-center gap-3">
            <div class="flex-1 grid grid-cols-3 gap-2">
              <div class="p-2 rounded-xl bg-slate-900/25 border border-slate-700/20">
                <div class="text-[11px] text-slate-200/75">GS</div>
                <div class="text-[18px] font-semibold" id="instGS">—</div>
              </div>
              <div class="p-2 rounded-xl bg-slate-900/25 border border-slate-700/20">
                <div class="text-[11px] text-slate-200/75">ALT</div>
                <div class="text-[18px] font-semibold" id="instALT">—</div>
              </div>
              <div class="p-2 rounded-xl bg-slate-900/25 border border-slate-700/20">
                <div class="text-[11px] text-slate-200/75">Vario</div>
                <div class="text-[18px] font-semibold" id="instVAR">—</div>
              </div>
            </div>

            <button id="btnMarker" class="w-20 h-20 rounded-2xl border text-white font-extrabold text-[12px] active:scale-[0.98]">
              <div><i class="fa-solid fa-location-dot mr-1"></i>MARK</div>
              <div class="text-[10px] opacity-90" id="markerHint">—</div>
            </button>
          </div>
        </div>
      </div>
    </footer>

  </div>

  <script>
  // ============================================================
  // 1) Konstanten & Konfiguration
  // ============================================================
  const APP = {
    name: "CompNavAir",
    version: "2.1.0",
    defaultCenter: { lat: 49.302, lon: 8.451 }, // Speyer/EDRY
    defaultZoom: 12,
    gps: { enableHighAccuracy: true, maximumAge: 800, timeout: 12000 },
    smoothing: {
      minAlpha: 0.08,
      maxAlpha: 0.35,
      maxJumpM: 350,
      maxSpeedKmh: 220
    },
    track: { minDtMs: 900, minDistM: 6 },
    sim: { tickMs: 250, climbRateMps: 2.0, sinkRateMps: 1.4 },
    ui: {
      statusAutoClearMs: 4200
    }
  };

  const STORAGE_KEYS = {
    briefings: "cna_briefings_v2",
    archive: "cna_archive_v2",
    settings: "cna_settings_v2"
  };

  const OSM = {
    name: "OSM",
    url: "https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png",
    options: { maxZoom: 19, attribution: "" }
  };
  const ESRI = {
    name: "Satellit",
    url: "https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
    options: { maxZoom: 19, attribution: "" }
  };

  const OPEN_METEO = {
    endpoint: "https://api.open-meteo.com/v1/forecast",
    levels: [
      { key: "1000hPa", altM: 110 },
      { key: "975hPa",  altM: 320 },
      { key: "950hPa",  altM: 500 },
      { key: "925hPa",  altM: 800 },
      { key: "900hPa",  altM: 1000 },
      { key: "850hPa",  altM: 1500 },
      { key: "800hPa",  altM: 1900 },
      { key: "700hPa",  altM: 3000 }
    ]
  };

  const TASK_LIBRARY = [
    { cia: "15.1", short: "PDG", title: "Selbst gewähltes Ziel", points: [{ id: "T", label: "Ziel" }], fields: [] },
    { cia: "15.2", short: "JDG", title: "Vorgegebenes Ziel", points: [{ id: "T", label: "Ziel" }], fields: [] },
    { cia: "15.3", short: "HWZ", title: "Qual der Wahl", points: [{ id: "T1", label: "Ziel 1" }], fields: [{ key: "multiTargets", type: "targets", label: "Weitere Ziele", hint: "Füge mehrere Ziele hinzu." }] },
    { cia: "15.4", short: "FIN", title: "Fly In", points: [{ id: "T", label: "Ziel" }], fields: [{ key: "oneAttempt", type: "bool", label: "Nur 1 Versuch", fixed: true }] },
    { cia: "15.5", short: "FON", title: "Fly On", points: [{ id: "T", label: "Ziel" }], fields: [] },
    { cia: "15.6", short: "HNH", title: "Fuchsjagd", points: [{ id: "X", label: "Fuchs-Zielkreuz" }], fields: [] },
    { cia: "15.7", short: "WSD", title: "Fuchsjagd mit Anlauf", points: [{ id: "S", label: "Fuchs-Start" }, { id: "X", label: "Fuchs-Zielkreuz" }], fields: [{ key: "foxStartTime", type: "time", label: "Fuchs Startzeit", hint: "Optional" }] },
    { cia: "15.8", short: "GBM", title: "Gordon Bennett Memorial", points: [{ id: "T", label: "Ziel" }], fields: [{ key: "scoringAreaNote", type: "note", label: "Wertungsgebiet", hint: "Optional über KML-Overlay visualisieren." }] },
    { cia: "15.9", short: "CRT", title: "Zielfahrt mit Zeitfenster", points: [{ id: "T", label: "Ziel" }], fields: [{ key: "timeWindows", type: "text", label: "Zeitfenster (Notiz)", hint: "Optional" }] },
    { cia: "15.10", short: "RTA", title: "Rennen zum Wertungsgebiet", points: [], fields: [{ key: "scoringAreaNote", type: "note", label: "Wertungsgebiet", hint: "Optional über KML-Overlay." }] },
    { cia: "15.11", short: "ELB", title: "Ellenbogen", points: [], fields: [{ key: "trackBased", type: "bool", label: "Track-basierte Auswertung", fixed: true }] },
    { cia: "15.12", short: "LRN", title: "Dreiecksfläche", points: [{ id: "A", label: "Punkt A" }, { id: "B", label: "Punkt B" }, { id: "C", label: "Punkt C" }], fields: [] },
    { cia: "15.13", short: "MDT", title: "Minimum Distance mit Zeitvorgabe", points: [{ id: "R", label: "Referenzpunkt" }], fields: [{ key: "minTimeOrDist", type: "text", label: "Mindestzeit/-strecke", hint: "z.B. 20min oder 5km" }] },
    { cia: "15.14", short: "SFL", title: "Minimum Distance mit Wertungsgebiet", points: [{ id: "R", label: "Referenzpunkt" }], fields: [{ key: "scoringAreaNote", type: "note", label: "Wertungsgebiet", hint: "Optional über KML-Overlay." }] },
    { cia: "15.15", short: "MDD", title: "Minimum Distance zwei Marker", points: [], fields: [{ key: "zonesNote", type: "note", label: "Zwei Wertungsgebiete", hint: "Optional über KML-Overlay." }] },
    { cia: "15.16", short: "XDT", title: "Maximum Distance mit Zeitvorgabe", points: [{ id: "R", label: "Referenzpunkt" }], fields: [{ key: "timeLimit", type: "text", label: "Zeitspanne", hint: "z.B. 30min" }] },
    { cia: "15.17", short: "XDI", title: "Maximum Distance mit Wertungsgebiet", points: [{ id: "R", label: "Referenzpunkt" }], fields: [{ key: "scoringAreaNote", type: "note", label: "Wertungsgebiet", hint: "Optional über KML-Overlay." }] },
    { cia: "15.18", short: "XDD", title: "Maximum Distance zwei Marker", points: [], fields: [{ key: "zonesNote", type: "note", label: "Wertungsgebiete", hint: "Optional über KML-Overlay." }] },
    { cia: "15.19", short: "ANG", title: "Winkel", points: [{ id: "A", label: "Punkt A" }, { id: "B", label: "Punkt B" }], fields: [{ key: "refDirDeg", type: "number", label: "Vorgegebene Richtung (°)", hint: "0–360" }, { key: "minMaxAB", type: "text", label: "Min/Max Distanz A–B", hint: "Optional" }] },
    { cia: "15.20", short: "3DT", title: "3D-Aufgabe (Donut/Luftraum)", points: [{ id: "C", label: "Zentrum" }], fields: [
      { key: "innerRadiusM", type: "number", label: "Innenradius (m)", hint: "Donut – innen ungültig", default: 200 },
      { key: "outerRadiusM", type: "number", label: "Außenradius (m)", hint: "Donut – Ring gültig", default: 800 },
      { key: "minAltM", type: "number", label: "Min Höhe (m)", hint: "Optional", default: 0 },
      { key: "maxAltM", type: "number", label: "Max Höhe (m)", hint: "Optional", default: 9999 }
    ] }
  ];

  const MARKER_COLORS = {
    yellow: { name: "Gelb", hex: "#f59e0b" },
    red:    { name: "Rot",  hex: "#ef4444" },
    blue:   { name: "Blau", hex: "#3b82f6" },
    white:  { name: "Weiß", hex: "#e5e7eb" },
    black:  { name: "Schwarz", hex: "#111827" },
    green:  { name: "Grün", hex: "#22c55e" }
  };

  // ============================================================
  // 2) Globale Variablen (State)
  // ============================================================
  let map = null;
  let baseLayers = {};
  let activeBase = "OSM";

  const STATE = {
    ui: {
      activeTab: "briefing",
      follow: true,
      // picking: { briefingId, taskId, pointKey, label }
      picking: null,
      windCollapsed: false,
      sheet: "expanded", // expanded | collapsed | hidden
      statusClearTimer: null
    },
    settings: {
      simEnabled: false
    },
    gps: {
      ok: false,
      lastRaw: null,
      lastSmooth: null,
      lastForVario: null,
      fixCount: 0,
      err: null
    },
    sim: {
      active: false,
      lat: APP.defaultCenter.lat,
      lon: APP.defaultCenter.lon,
      altM: 180,
      hdgDeg: 0,
      spdKmh: 0,
      varioMps: 0,
      burnerHeld: false,
      ventHeld: false,
      lastTickTs: 0
    },
    wind: {
      profile: [],
      lastSource: "—",
      lastUpdatedTs: null,
      lastError: null
    },
    briefings: {
      list: [],
      selectedId: null
    },
    flight: {
      active: false,
      startedTs: null,
      endedTs: null,
      briefingSnapshot: null,
      track: [],
      markers: []
    },
    kml: {
      overlays: []
    },
    archive: []
  };

  let balloonMarker = null;
  let trackLine = null;
  let trajLine = null;
  let taskLayerGroup = null;
  let kmlLayerGroup = null;

  let wakeLock = null;
  let simTimer = null;

  // ============================================================
  // 3) Helfer-Funktionen (Math, Formatting)
  // ============================================================
  function uid(prefix = "id") {
    return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
  }
  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
  function fmtNum(v, d = 0) {
    if (v === null || v === undefined || Number.isNaN(v) || !isFinite(v)) return "—";
    return Number(v).toFixed(d);
  }
  function fmtLatLon(lat, lon) {
    if (!isFinite(lat) || !isFinite(lon)) return "—";
    return `${lat.toFixed(6)}, ${lon.toFixed(6)}`;
  }
  function fmtTime(ts) {
    try {
      const d = new Date(ts);
      return d.toLocaleTimeString([], { hour: "2-digit", minute: "2-digit", second: "2-digit" });
    } catch { return "—"; }
  }
  function degNormalize(d) {
    let x = d % 360;
    if (x < 0) x += 360;
    return x;
  }
  function degDiff(a, b) {
    const d = Math.abs(degNormalize(a) - degNormalize(b));
    return Math.min(d, 360 - d);
  }
  function metersToKm(m) { return m / 1000; }
  function kmhToMps(kmh) { return kmh / 3.6; }
  function mpsToKmh(mps) { return mps * 3.6; }

  function distM(a, b) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI / 180;
    const dLat = toRad(b.lat - a.lat);
    const dLon = toRad(b.lon - a.lon);
    const lat1 = toRad(a.lat);
    const lat2 = toRad(b.lat);
    const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
    return 2 * R * Math.asin(Math.sqrt(s));
  }

  function bearingDeg(a, b) {
    const toRad = (x) => x * Math.PI / 180;
    const toDeg = (x) => x * 180 / Math.PI;
    const lat1 = toRad(a.lat), lat2 = toRad(b.lat);
    const dLon = toRad(b.lon - a.lon);
    const y = Math.sin(dLon) * Math.cos(lat2);
    const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
    return degNormalize(toDeg(Math.atan2(y, x)));
  }

  function projectLatLon(lat, lon, bearing, distanceM) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI/180;
    const toDeg = (x) => x * 180/Math.PI;

    const br = toRad(bearing);
    const φ1 = toRad(lat);
    const λ1 = toRad(lon);
    const δ = distanceM / R;

    const φ2 = Math.asin(Math.sin(φ1)*Math.cos(δ) + Math.cos(φ1)*Math.sin(δ)*Math.cos(br));
    const λ2 = λ1 + Math.atan2(Math.sin(br)*Math.sin(δ)*Math.cos(φ1), Math.cos(δ)-Math.sin(φ1)*Math.sin(φ2));
    return { lat: toDeg(φ2), lon: toDeg(λ2) };
  }

  function safeJsonParse(txt, fallback) {
    try { return JSON.parse(txt); } catch { return fallback; }
  }
  function escHtml(str) {
    return String(str ?? "")
      .replaceAll("&", "&amp;")
      .replaceAll("<", "&lt;")
      .replaceAll(">", "&gt;")
      .replaceAll('"', "&quot;")
      .replaceAll("'", "&#039;");
  }

  function getTaskDefByShort(short) {
    return TASK_LIBRARY.find(t => t.short === short) || null;
  }
  function getBriefingById(id) {
    return STATE.briefings.list.find(b => b.id === id) || null;
  }
  function getSelectedBriefing() {
    return getBriefingById(STATE.briefings.selectedId);
  }

  function structuredCloneSafe(obj) {
    try { if ("structuredClone" in window) return structuredClone(obj); } catch {}
    return JSON.parse(JSON.stringify(obj));
  }

  function saveToStorage() {
    try {
      localStorage.setItem(STORAGE_KEYS.briefings, JSON.stringify(STATE.briefings.list));
      localStorage.setItem(STORAGE_KEYS.archive, JSON.stringify(STATE.archive));
      localStorage.setItem(STORAGE_KEYS.settings, JSON.stringify(STATE.settings));
    } catch (e) {
      console.warn("Storage save failed:", e);
    }
  }
  function loadFromStorage() {
    const b = safeJsonParse(localStorage.getItem(STORAGE_KEYS.briefings) || "[]", []);
    const a = safeJsonParse(localStorage.getItem(STORAGE_KEYS.archive) || "[]", []);
    const s = safeJsonParse(localStorage.getItem(STORAGE_KEYS.settings) || "{}", {});
    if (Array.isArray(b)) STATE.briefings.list = b;
    if (Array.isArray(a)) STATE.archive = a;
    if (s && typeof s === "object") STATE.settings = { ...STATE.settings, ...s };
    if (!STATE.briefings.selectedId && STATE.briefings.list.length) STATE.briefings.selectedId = STATE.briefings.list[0].id;
  }

  function setGpsPill(text, ok) {
    const pill = document.getElementById("gpsPill");
    pill.textContent = text;
    pill.classList.toggle("border-emerald-400/40", !!ok);
    pill.classList.toggle("bg-emerald-500/15", !!ok);
    pill.classList.toggle("border-rose-400/40", !ok);
    pill.classList.toggle("bg-rose-500/10", !ok);
  }

  // Replaces "toast": status messages live in header line (not on the map)
  function setStatus(message, type = "info", autoClear = true) {
    const el = document.getElementById("statusLine");
    if (!el) return;

    const base = "text-[11px] truncate ";
    const cls =
      type === "error" ? "text-rose-200/90" :
      type === "ok" ? "text-emerald-200/90" :
      type === "hint" ? "text-sky-200/85" :
      "text-slate-200/80";

    el.className = base + cls;
    el.textContent = message || "";

    if (STATE.ui.statusClearTimer) clearTimeout(STATE.ui.statusClearTimer);
    if (autoClear) {
      STATE.ui.statusClearTimer = setTimeout(() => {
        // keep a sensible default line depending on state
        el.className = base + "text-slate-200/80";
        el.textContent = STATE.flight.active
          ? `Fahrt aktiv: ${(STATE.flight.briefingSnapshot?.title || "—")} · Marker & Track werden aufgezeichnet.`
          : `Briefing planen → Start drücken, wenn du willst (kein Auto-Start).`;
      }, APP.ui.statusAutoClearMs);
    }
  }

  function isRestrictedAirspaceName(name) {
    const s = (name || "").toUpperCase().replace(/\s+/g, "");
    return /^EDR\d+$/.test(s) || /^ED-R\d+$/.test(s) || /EDR\d+/.test(s) || /ED-R\d+/.test(s);
  }

  function getCurrentPosition() {
    if (STATE.settings.simEnabled && STATE.sim.active) {
      return { lat: STATE.sim.lat, lon: STATE.sim.lon, altM: STATE.sim.altM, spdKmh: STATE.sim.spdKmh, hdgDeg: STATE.sim.hdgDeg, accM: 0, ts: Date.now(), source: "SIM" };
    }
    return STATE.gps.lastRaw ? { ...STATE.gps.lastRaw, source: "GPS" } : null;
  }

  function computeVarioMps(pos) {
    if (!pos || !isFinite(pos.altM)) return 0;
    const prev = STATE.gps.lastForVario;
    const now = { altM: pos.altM, ts: pos.ts || Date.now() };
    if (!prev) { STATE.gps.lastForVario = now; return 0; }
    const dt = Math.max(1, (now.ts - prev.ts) / 1000);
    const v = (now.altM - prev.altM) / dt;
    STATE.gps.lastForVario = now;
    return clamp(v, -8, 8);
  }

  function inferMarkerCount(def) {
    if (!def) return "—";
    if (["MDD","XDD"].includes(def.short)) return 2;
    if (["ELB","RTA"].includes(def.short)) return 0;
    if (["HWZ"].includes(def.short)) return "1+";
    return 1;
  }

  function getExpectedMarkerColor() {
    const briefing = STATE.flight.active ? STATE.flight.briefingSnapshot : getSelectedBriefing();
    const t = briefing?.tasks?.[0];
    if (t?.markerColor && MARKER_COLORS[t.markerColor]) return MARKER_COLORS[t.markerColor];
    const def = getTaskDefByShort(t?.short);
    if (!def) return MARKER_COLORS.green;
    if (def.short === "JDG") return MARKER_COLORS.yellow;
    if (def.short === "FIN") return MARKER_COLORS.red;
    if (def.short === "3DT") return MARKER_COLORS.blue;
    return MARKER_COLORS.green;
  }

  // ============================================================
  // 4) UI-Render-Funktionen
  // ============================================================
  function renderAll() {
    renderTopbar();
    renderWindPanel();
    renderCockpit();
    renderSheet();
    renderMapTasks();
    renderSimControls();
  }

  function renderTopbar() {
    const btnFinish = document.getElementById("btnFinish");
    btnFinish.classList.toggle("hidden", !STATE.flight.active);

    if (STATE.ui.picking) {
      setStatus(`Punkt setzen: ${STATE.ui.picking.label} · Tippe in die Karte (Panel klappt automatisch klein).`, "hint", false);
    } else if (STATE.flight.active) {
      setStatus(`Fahrt aktiv: ${(STATE.flight.briefingSnapshot?.title || "—")} · Marker & Track werden aufgezeichnet.`, "ok", false);
    } else {
      setStatus(`Briefing planen → Start drücken, wenn du willst (kein Auto-Start).`, "info", false);
    }
  }

  function renderCockpit() {
    const pos = getCurrentPosition();
    const gsEl = document.getElementById("instGS");
    const altEl = document.getElementById("instALT");
    const varEl = document.getElementById("instVAR");

    if (!pos) {
      gsEl.textContent = "—";
      altEl.textContent = "—";
      varEl.textContent = "—";
    } else {
      gsEl.textContent = `${fmtNum(pos.spdKmh, 0)} km/h`;
      altEl.textContent = `${fmtNum(pos.altM, 0)} m`;
      varEl.textContent = `${fmtNum(computeVarioMps(pos), 1)} m/s`;
    }

    const btn = document.getElementById("btnMarker");
    const hint = document.getElementById("markerHint");
    const color = getExpectedMarkerColor();
    const hex = color?.hex || "#22c55e";
    btn.style.background = hex + "22";
    btn.style.borderColor = hex + "66";
    btn.style.color = "#ffffff";
    hint.textContent = color ? color.name : "—";
  }

  function renderWindPanel() {
    const windRows = document.getElementById("windRows");
    windRows.innerHTML = "";

    document.getElementById("windSrc").textContent = STATE.wind.lastSource || "—";
    document.getElementById("windMeta").textContent =
      STATE.wind.lastUpdatedTs ? `Update ${fmtTime(STATE.wind.lastUpdatedTs)}` :
      (STATE.wind.lastError ? `Fehler: ${STATE.wind.lastError}` : "—");

    const prof = [...STATE.wind.profile].sort((a,b)=>a.altM-b.altM).slice(0, 6);

    const nav = computeNav();
    const best = nav?.bestLayer || null;
    const shown = best || (prof.length ? prof[0] : null);

    if (!shown) {
      document.getElementById("windKeyLine").textContent = "Kein Windprofil";
      document.getElementById("windRecLine").textContent = "Online abrufen oder manuell ergänzen.";
      document.getElementById("windArrowIcon").style.transform = "rotate(0deg)";
    } else {
      const drift = degNormalize((shown.dirFromDeg ?? 0) + 180);
      document.getElementById("windKeyLine").textContent = `${shown.altM} m · ${fmtNum(shown.speedKmh,0)} km/h · Drift ${fmtNum(drift,0)}°`;
      document.getElementById("windRecLine").textContent = nav?.recText || "—";
      document.getElementById("windArrowIcon").style.transform = `rotate(${drift}deg)`;
    }

    if (!prof.length) {
      windRows.innerHTML = `<div class="px-2 py-2 text-[12px] text-slate-200/70">Keine Winddaten.</div>`;
    } else {
      for (const w of prof) {
        const drift = degNormalize(w.dirFromDeg + 180);
        const row = document.createElement("div");
        row.className = "px-2 py-2 text-[12px] flex items-center justify-between bg-slate-950/0";
        row.innerHTML = `
          <div class="font-semibold text-slate-100">${escHtml(w.altM)} m</div>
          <div class="text-slate-100/90">${escHtml(fmtNum(drift,0))}° · ${escHtml(fmtNum(w.speedKmh,0))} km/h</div>
        `;
        windRows.appendChild(row);
      }
    }

    const navTitle = document.getElementById("navInsideTitle");
    const navLine = document.getElementById("navInsideLine");
    if (!nav) {
      navTitle.textContent = "—";
      navLine.textContent = "—";
    } else {
      navTitle.textContent = nav.title;
      navLine.textContent = nav.line;
    }
  }

  function renderSimControls() {
    document.getElementById("simControls").classList.toggle("hidden", !(STATE.settings.simEnabled));
  }

  function setWindCollapsed(collapsed) {
    STATE.ui.windCollapsed = collapsed;
    document.getElementById("windPanelExpanded").classList.toggle("hidden", collapsed);
    document.getElementById("windPanelCollapsed").classList.toggle("hidden", !collapsed);
  }

  function setSheetState(state) {
    STATE.ui.sheet = state;
    const sheet = document.getElementById("sheet");
    sheet.classList.toggle("sheet-expanded", state === "expanded");
    sheet.classList.toggle("sheet-collapsed", state === "collapsed");
    sheet.classList.toggle("sheet-hidden", state === "hidden");
  }

  function renderSheet() {
    // Tabs styling
    document.querySelectorAll(".tabBtn").forEach(btn => {
      const is = btn.dataset.tab === STATE.ui.activeTab;
      btn.classList.toggle("bg-indigo-500/15", is);
      btn.classList.toggle("border-indigo-400/25", is);
      btn.classList.toggle("text-indigo-100", is);
      btn.classList.toggle("bg-slate-900/30", !is);
      btn.classList.toggle("border-slate-700/25", !is);
      btn.classList.toggle("text-slate-100", !is);
    });

    document.querySelectorAll(".tabPane").forEach(p => p.classList.add("hidden"));
    document.getElementById(`tab_${STATE.ui.activeTab}`).classList.remove("hidden");

    renderTabBriefing();
    renderTabLive();
    renderTabSetup();
    renderTabArchiv();
  }

  function renderTabBriefing() {
    const el = document.getElementById("tab_briefing");
    const bList = STATE.briefings.list;
    const sel = getSelectedBriefing();

    const steps = `
      <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
        <div class="text-[12px] font-semibold">Planungs-Flow</div>
        <div class="mt-1 text-[11px] text-slate-200/75">
          1) Briefing wählen · 2) Aufgaben hinzufügen · 3) „Setzen“ → Karte tippen (Panel klappt klein) · 4) Start drücken
        </div>
      </div>
    `;

    el.innerHTML = `
      <div class="space-y-2">
        ${steps}

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="flex items-center gap-2">
            <div class="text-[12px] font-semibold flex-1">Briefings</div>

            <button id="btnBriefingExport" class="h-9 px-3 rounded-xl bg-sky-500/15 border border-sky-400/25 text-sky-100 text-[12px] font-semibold">
              <i class="fa-solid fa-file-export mr-2"></i>Export
            </button>
            <label class="h-9 px-3 rounded-xl bg-slate-900/35 border border-slate-700/25 text-slate-100 text-[12px] font-semibold flex items-center gap-2 cursor-pointer">
              <i class="fa-solid fa-file-import"></i>Import
              <input id="briefingImportFile" type="file" accept="application/json,.json" class="hidden" />
            </label>
          </div>

          <div class="mt-2 grid grid-cols-[1fr_auto_auto_auto] gap-2 items-center">
            <select id="selBriefing" class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]">
              ${bList.map(b => `<option value="${escHtml(b.id)}" ${b.id===STATE.briefings.selectedId?"selected":""}>${escHtml(b.title)}</option>`).join("") || `<option value="">(keins)</option>`}
            </select>
            <button id="btnBriefingNew" class="h-10 w-10 rounded-xl bg-emerald-500/15 border border-emerald-400/25 text-emerald-100" title="Neu">
              <i class="fa-solid fa-plus"></i>
            </button>
            <button id="btnBriefingRename" class="h-10 w-10 rounded-xl bg-slate-900/35 border border-slate-700/25" title="Umbenennen">
              <i class="fa-solid fa-pen"></i>
            </button>
            <button id="btnBriefingDelete" class="h-10 w-10 rounded-xl bg-rose-500/15 border border-rose-400/25 text-rose-100" title="Löschen">
              <i class="fa-solid fa-trash"></i>
            </button>
          </div>

          <div class="mt-2 grid grid-cols-2 gap-2">
            <button id="btnAddTask" class="h-11 rounded-2xl bg-indigo-500/15 border border-indigo-400/25 text-indigo-100 text-[12px] font-semibold">
              <i class="fa-solid fa-plus mr-2"></i>Aufgabe hinzufügen
            </button>
            <button id="btnStartFlight" class="h-11 rounded-2xl bg-emerald-500/20 border border-emerald-400/30 text-emerald-100 text-[13px] font-extrabold">
              <i class="fa-solid fa-play mr-2"></i>Fahrt starten
            </button>
          </div>

          <div class="mt-2 text-[11px] text-slate-200/70">
            Tipp: Aufgaben-Marker im Briefing sind drag&drop verschiebbar. „Setzen“ klappt das Panel klein, damit du die Karte frei hast.
          </div>
        </div>

        ${sel ? renderBriefingTaskList(sel) : `<div class="p-3 rounded-2xl bg-slate-900/25 border border-slate-700/20 text-[12px] text-slate-200/75">Noch kein Briefing. Erstelle eins.</div>`}
      </div>
    `;
  }

  function renderBriefingTaskList(briefing) {
    const tasks = briefing.tasks || [];
    const cards = tasks.map((t, idx) => renderTaskCard(briefing, t, idx)).join("");
    return `
      <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
        <div class="text-[12px] font-semibold">Aufgaben im Briefing</div>
        <div class="mt-2 space-y-2">
          ${cards || `<div class="text-[12px] text-slate-200/70">Keine Aufgaben. „Aufgabe hinzufügen“.</div>`}
        </div>
      </div>
    `;
  }

  function renderTaskCard(briefing, task, idx) {
    const def = getTaskDefByShort(task.short) || null;
    const title = def ? `${def.cia} ${def.short} – ${def.title}` : (task.short || "Aufgabe");
    const markerCount = inferMarkerCount(def);

    const pointRows = renderTaskPointsCompact(briefing, task, def);
    const fieldRows = renderTaskFieldsCompact(briefing, task, def);

    return `
      <div class="p-2 rounded-2xl bg-slate-950/35 border border-slate-700/25">
        <div class="flex items-center gap-2">
          <div class="text-[12px] font-semibold flex-1 truncate">${escHtml(title)}</div>
          <div class="text-[10px] px-2 py-0.5 rounded-full bg-slate-900/40 border border-slate-700/25 text-slate-200/80">
            Marker: ${markerCount}
          </div>
          <button data-action="delTask" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}"
            class="h-9 w-9 rounded-xl bg-rose-500/15 border border-rose-400/25 text-rose-100" title="Aufgabe löschen">
            <i class="fa-solid fa-xmark"></i>
          </button>
        </div>

        <div class="mt-2 grid grid-cols-2 gap-2">
          <select data-action="taskType" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}"
            class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]">
            ${TASK_LIBRARY.map(d => `<option value="${escHtml(d.short)}" ${d.short===task.short?"selected":""}>${escHtml(d.cia)} ${escHtml(d.short)} – ${escHtml(d.title)}</option>`).join("")}
          </select>

          <select data-action="taskMarkerColor" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}"
            class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]">
            <option value="">Markerfarbe (auto)</option>
            ${Object.entries(MARKER_COLORS).map(([k,v]) => `<option value="${escHtml(k)}" ${task.markerColor===k?"selected":""}>${escHtml(v.name)}</option>`).join("")}
          </select>
        </div>

        ${pointRows}
        ${fieldRows}
      </div>
    `;
  }

  function renderTaskPointsCompact(briefing, task, def) {
    if (!def) return "";
    // HWZ: multiple targets
    if (def.short === "HWZ") {
      const targets = Array.isArray(task.targets) ? task.targets : [];
      const rows = targets.map((p, i) => {
        const ll = (p?.lat!=null && p?.lon!=null) ? fmtLatLon(p.lat, p.lon) : "—";
        return `
          <div class="flex items-center justify-between gap-2 p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
            <div class="min-w-0">
              <div class="text-[12px] font-semibold">Ziel ${i+1}</div>
              <div class="text-[11px] text-slate-200/75 truncate">${escHtml(ll)}</div>
            </div>
            <div class="flex items-center gap-2 shrink-0">
              <button data-action="pickHWZ" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-i="${i}"
                class="h-9 px-3 rounded-xl bg-indigo-500/15 border border-indigo-400/25 text-indigo-100 text-[12px] font-semibold">
                Setzen
              </button>
              <button data-action="delHWZ" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-i="${i}"
                class="h-9 w-9 rounded-xl bg-rose-500/15 border border-rose-400/25 text-rose-100" title="Löschen">
                <i class="fa-solid fa-trash"></i>
              </button>
            </div>
          </div>
        `;
      }).join("");

      return `
        <div class="mt-2 p-2 rounded-2xl bg-slate-900/10 border border-slate-700/20">
          <div class="flex items-center gap-2">
            <div class="text-[12px] font-semibold flex-1">Ziele</div>
            <button data-action="addHWZ" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}"
              class="h-9 px-3 rounded-xl bg-emerald-500/15 border border-emerald-400/25 text-emerald-100 text-[12px] font-semibold">
              <i class="fa-solid fa-plus mr-2"></i>Ziel
            </button>
          </div>
          <div class="mt-2 space-y-2">
            ${rows || `<div class="text-[12px] text-slate-200/70">Noch keine Ziele. „Ziel“ hinzufügen.</div>`}
          </div>
        </div>
      `;
    }

    const pts = def.points || [];
    if (!pts.length) return "";

    const taskPoints = task.points || {};
    const rows = pts.map(p => {
      const cur = taskPoints[p.id] || null;
      const ll = (cur?.lat!=null && cur?.lon!=null) ? fmtLatLon(cur.lat, cur.lon) : "—";
      return `
        <div class="flex items-center justify-between gap-2 p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
          <div class="min-w-0">
            <div class="text-[12px] font-semibold">${escHtml(p.label)}</div>
            <div class="text-[11px] text-slate-200/75 truncate">${escHtml(ll)}</div>
          </div>
          <button data-action="pickPoint" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-k="${escHtml(p.id)}" data-l="${escHtml(p.label)}"
            class="h-9 px-3 rounded-xl bg-indigo-500/15 border border-indigo-400/25 text-indigo-100 text-[12px] font-semibold shrink-0">
            Setzen
          </button>
        </div>
      `;
    }).join("");

    return `
      <div class="mt-2 p-2 rounded-2xl bg-slate-900/10 border border-slate-700/20">
        <div class="text-[12px] font-semibold">Punkte</div>
        <div class="mt-2 space-y-2">${rows}</div>
      </div>
    `;
  }

  function renderTaskFieldsCompact(briefing, task, def) {
    const fields = def?.fields || [];
    if (!fields.length) return "";

    const blocks = fields.map(f => {
      const val = task.fields?.[f.key];
      const fixed = !!f.fixed;

      if (f.type === "bool") {
        const checked = fixed ? true : !!val;
        return `
          <div class="flex items-center justify-between gap-2 p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
            <div class="min-w-0">
              <div class="text-[12px] font-semibold">${escHtml(f.label)}</div>
              <div class="text-[11px] text-slate-200/70 truncate">${escHtml(f.hint || "")}</div>
            </div>
            <input data-action="fieldBool" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-k="${escHtml(f.key)}"
              type="checkbox" class="w-5 h-5" ${checked ? "checked" : ""} ${fixed ? "disabled" : ""} />
          </div>
        `;
      }

      if (f.type === "number") {
        const v = (val != null) ? val : (f.default != null ? f.default : "");
        return `
          <div class="p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
            <div class="text-[12px] font-semibold">${escHtml(f.label)}</div>
            <div class="text-[11px] text-slate-200/70">${escHtml(f.hint || "")}</div>
            <input data-action="fieldNum" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-k="${escHtml(f.key)}"
              value="${escHtml(v)}" inputmode="decimal"
              class="mt-2 w-full h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]" />
          </div>
        `;
      }

      const v = (val != null) ? val : "";
      const isTextArea = f.type === "note";
      if (isTextArea) {
        return `
          <div class="p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
            <div class="text-[12px] font-semibold">${escHtml(f.label)}</div>
            <div class="text-[11px] text-slate-200/70">${escHtml(f.hint || "")}</div>
            <textarea data-action="fieldText" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-k="${escHtml(f.key)}"
              class="mt-2 w-full min-h-[72px] rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 py-2 text-[12px]"
              placeholder="Optional…">${escHtml(v)}</textarea>
          </div>
        `;
      }

      return `
        <div class="p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
          <div class="text-[12px] font-semibold">${escHtml(f.label)}</div>
          <div class="text-[11px] text-slate-200/70">${escHtml(f.hint || "")}</div>
          <input data-action="fieldText" data-b="${escHtml(briefing.id)}" data-t="${escHtml(task.id)}" data-k="${escHtml(f.key)}"
            value="${escHtml(v)}" placeholder="Optional…"
            class="mt-2 w-full h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]" />
        </div>
      `;
    }).join("");

    return `
      <div class="mt-2 p-2 rounded-2xl bg-slate-900/10 border border-slate-700/20 space-y-2">
        <div class="text-[12px] font-semibold">Parameter</div>
        ${blocks}
      </div>
    `;
  }

  function renderTabLive() {
    const el = document.getElementById("tab_live");
    const flight = STATE.flight;

    const activeBrief = flight.briefingSnapshot;
    const title = activeBrief?.title || "—";
    const nav = computeNav();
    const navLine = nav ? `${nav.title} · ${nav.line}` : "—";

    const markerList = flight.markers.slice().reverse().slice(0, 10).map(m => {
      const c = MARKER_COLORS[m.color]?.hex || "#22c55e";
      return `
        <div class="flex items-center justify-between text-[12px] p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
          <div class="flex items-center gap-2">
            <span class="inline-block w-3 h-3 rounded-full" style="background:${c}"></span>
            <span class="text-slate-100">${escHtml(fmtTime(m.ts))}</span>
          </div>
          <span class="text-slate-200/80">${escHtml(fmtLatLon(m.lat, m.lon))}</span>
        </div>
      `;
    }).join("");

    el.innerHTML = `
      <div class="space-y-2">
        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">Status</div>
          <div class="mt-1 text-[12px] text-slate-100/90">Briefing: <span class="font-semibold">${escHtml(title)}</span></div>
          <div class="mt-1 text-[12px] text-slate-200/80">Navigation: ${escHtml(navLine)}</div>
          <div class="mt-2 grid grid-cols-2 gap-2">
            <button id="btnLiveCenter" class="h-11 rounded-2xl bg-slate-900/35 border border-slate-700/25 text-[12px] font-semibold">
              <i class="fa-solid fa-location-crosshairs mr-2"></i>Zentrieren
            </button>
            <button id="btnLiveToggleFollow" class="h-11 rounded-2xl bg-slate-900/35 border border-slate-700/25 text-[12px] font-semibold">
              <i class="fa-solid fa-route mr-2"></i>Follow: ${STATE.ui.follow ? "An" : "Aus"}
            </button>
          </div>
        </div>

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="flex items-center gap-2">
            <div class="text-[12px] font-semibold flex-1">Marker (letzte)</div>
            <div class="text-[11px] text-slate-200/70">${flight.markers.length} gesamt</div>
          </div>
          <div class="mt-2 space-y-2">
            ${markerList || `<div class="text-[12px] text-slate-200/70">Noch keine Marker.</div>`}
          </div>
        </div>

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">Fahrt</div>
          <div class="mt-2 grid grid-cols-2 gap-2">
            <button id="btnLiveStop" class="h-11 rounded-2xl bg-rose-500/15 border border-rose-400/25 text-rose-100 text-[12px] font-extrabold" ${!flight.active ? "disabled" : ""}>
              <i class="fa-solid fa-flag-checkered mr-2"></i>Beenden
            </button>
            <button id="btnLiveKmlNow" class="h-11 rounded-2xl bg-sky-500/15 border border-sky-400/25 text-sky-100 text-[12px] font-extrabold" ${!flight.active ? "disabled" : ""}>
              <i class="fa-solid fa-file-arrow-down mr-2"></i>KML Export
            </button>
          </div>
        </div>
      </div>
    `;
  }

  function renderTabSetup() {
    const el = document.getElementById("tab_setup");
    const simOn = !!STATE.settings.simEnabled;

    const kmlList = STATE.kml.overlays.map(o => `
      <div class="p-2 rounded-xl bg-slate-900/15 border border-slate-700/20">
        <div class="flex items-center gap-2">
          <div class="text-[12px] font-semibold flex-1 truncate">${escHtml(o.name || "KML")}</div>
          <button data-action="kmlToggle" data-id="${escHtml(o.id)}"
            class="h-9 px-3 rounded-xl ${o.visible ? "bg-emerald-500/15 border-emerald-400/25 text-emerald-100" : "bg-slate-900/35 border-slate-700/25 text-slate-100"} border text-[12px] font-semibold">
            ${o.visible ? "An" : "Aus"}
          </button>
          <button data-action="kmlRemove" data-id="${escHtml(o.id)}"
            class="h-9 w-9 rounded-xl bg-rose-500/15 border border-rose-400/25 text-rose-100" title="Entfernen">
            <i class="fa-solid fa-trash"></i>
          </button>
        </div>
        <div class="mt-1 text-[11px] text-slate-200/70">Klick auf Luftraum → Info. EDRxxx/ED-Rxxx wird rot.</div>
      </div>
    `).join("");

    el.innerHTML = `
      <div class="space-y-2">
        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="flex items-center justify-between">
            <div>
              <div class="text-[12px] font-semibold">Simulation</div>
              <div class="text-[11px] text-slate-200/70">SIM steuert Position (Burner/Vent). Startet niemals automatisch die Fahrt.</div>
            </div>
            <label class="inline-flex items-center gap-2">
              <input id="tglSim" type="checkbox" class="w-5 h-5" ${simOn ? "checked" : ""} />
            </label>
          </div>
          <div class="mt-2 grid grid-cols-2 gap-2">
            <button id="btnSimUseGps" class="h-11 rounded-2xl bg-slate-900/35 border border-slate-700/25 text-[12px] font-semibold">
              <i class="fa-solid fa-map-pin mr-2"></i>SIM auf GPS
            </button>
            <button id="btnSimToggleActive" class="h-11 rounded-2xl bg-slate-900/35 border border-slate-700/25 text-[12px] font-semibold">
              <i class="fa-solid fa-gamepad mr-2"></i>SIM: ${STATE.sim.active ? "Aktiv" : "Inaktiv"}
            </button>
          </div>
        </div>

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">Wind (manuell)</div>
          <div class="text-[11px] text-slate-200/70">Alt, Richtung FROM, Speed. (Online über Wind-Panel links.)</div>

          <div class="mt-2 grid grid-cols-3 gap-2">
            <input id="windAlt" class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]" placeholder="Alt m" inputmode="numeric" />
            <input id="windDir" class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]" placeholder="Dir FROM °" inputmode="numeric" />
            <input id="windSpd" class="h-10 rounded-xl bg-slate-950/40 border border-slate-700/25 px-3 text-[12px]" placeholder="km/h" inputmode="numeric" />
          </div>
          <div class="mt-2 flex gap-2">
            <button id="btnWindAddManual" class="flex-1 h-11 rounded-2xl bg-indigo-500/15 border border-indigo-400/25 text-indigo-100 text-[12px] font-semibold">
              <i class="fa-solid fa-plus mr-2"></i>Hinzufügen
            </button>
            <button id="btnWindClear" class="h-11 px-3 rounded-2xl bg-rose-500/15 border border-rose-400/25 text-rose-100 text-[12px] font-semibold">
              <i class="fa-solid fa-trash mr-2"></i>Leeren
            </button>
          </div>
        </div>

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">KML Overlays</div>
          <div class="text-[11px] text-slate-200/70">Importiere KML (Lufträume). Klick zeigt Infobox.</div>
          <div class="mt-2">
            <label class="h-11 px-3 rounded-2xl bg-slate-900/35 border border-slate-700/25 text-slate-100 text-[12px] font-semibold flex items-center justify-center gap-2 cursor-pointer">
              <i class="fa-solid fa-file-arrow-up"></i>KML Import
              <input id="kmlFile" type="file" accept=".kml,application/vnd.google-earth.kml+xml,application/xml,text/xml" class="hidden" />
            </label>
          </div>
          <div class="mt-2 space-y-2">
            ${kmlList || `<div class="text-[12px] text-slate-200/70">Keine KML geladen.</div>`}
          </div>
        </div>

        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">PWA / „Wie App“</div>
          <div class="text-[11px] text-slate-200/70">
            Für „ohne Browser-UI“: auf Android über Chrome-Menü → „Zum Startbildschirm hinzufügen“ installieren (dann startet sie als Standalone).
          </div>
        </div>
      </div>
    `;
  }

  function renderTabArchiv() {
    const el = document.getElementById("tab_archiv");
    const items = STATE.archive.slice().reverse().slice(0, 20).map(a => `
      <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
        <div class="flex items-center gap-2">
          <div class="text-[12px] font-semibold flex-1 truncate">${escHtml(a.title || "Fahrt")}</div>
          <button data-action="archShow" data-id="${escHtml(a.id)}" class="h-9 px-3 rounded-xl bg-slate-900/35 border border-slate-700/25 text-[12px] font-semibold">
            <i class="fa-solid fa-eye mr-2"></i>Anzeigen
          </button>
        </div>
        <div class="mt-1 text-[11px] text-slate-200/70">${escHtml(fmtTime(a.startedTs))} – ${escHtml(fmtTime(a.endedTs))} · Track: ${a.track?.length||0} · Marker: ${a.markers?.length||0}</div>
        <div class="mt-2 grid grid-cols-2 gap-2">
          <button data-action="archKml" data-id="${escHtml(a.id)}" class="h-10 rounded-2xl bg-sky-500/15 border border-sky-400/25 text-sky-100 text-[12px] font-semibold">
            <i class="fa-solid fa-file-arrow-down mr-2"></i>KML Export
          </button>
          <button data-action="archDel" data-id="${escHtml(a.id)}" class="h-10 rounded-2xl bg-rose-500/15 border border-rose-400/25 text-rose-100 text-[12px] font-semibold">
            <i class="fa-solid fa-trash mr-2"></i>Löschen
          </button>
        </div>
      </div>
    `).join("");

    el.innerHTML = `
      <div class="space-y-2">
        <div class="p-2 rounded-2xl bg-slate-900/25 border border-slate-700/20">
          <div class="text-[12px] font-semibold">Archiv</div>
          <div class="text-[11px] text-slate-200/70">Beendete Fahrten – Export enthält Track (mit Höhe) + Marker.</div>
        </div>
        ${items || `<div class="p-3 rounded-2xl bg-slate-900/25 border border-slate-700/20 text-[12px] text-slate-200/70">Noch keine Fahrten im Archiv.</div>`}
      </div>
    `;
  }

  // ============================================================
  // 5) Kern-Logik (GPS, Map, Wind, Tasks, Simulation, Export)
  // ============================================================
  function initMap() {
    map = L.map("map", { zoomControl: false, preferCanvas: true });
    baseLayers = { OSM: L.tileLayer(OSM.url, OSM.options), ESRI: L.tileLayer(ESRI.url, ESRI.options) };
    activeBase = "OSM";
    baseLayers[activeBase].addTo(map);
    map.setView([APP.defaultCenter.lat, APP.defaultCenter.lon], APP.defaultZoom);

    taskLayerGroup = L.layerGroup().addTo(map);
    kmlLayerGroup = L.layerGroup().addTo(map);

    trackLine = L.polyline([], { color: "#ef4444", weight: 3, opacity: 0.9 }).addTo(map);
    trajLine = L.polyline([], { color: "#22c55e", weight: 3, opacity: 0.8, dashArray: "6 8" }).addTo(map);

    const balloonHtml = `
      <div class="relative">
        <div class="w-8 h-8 rounded-full bg-rose-500/25 border border-rose-400/50 grid place-items-center">
          <i class="fa-solid fa-balloon text-rose-100"></i>
        </div>
      </div>
    `;
    balloonMarker = L.marker([APP.defaultCenter.lat, APP.defaultCenter.lon], {
      icon: L.divIcon({ className: "", html: balloonHtml, iconSize: [32, 32], iconAnchor: [16, 16] }),
      interactive: false
    }).addTo(map);

    map.on("dragstart", () => { STATE.ui.follow = false; renderAll(); });

    map.on("click", (e) => {
      if (!STATE.ui.picking) return;
      handlePickedPoint(e.latlng.lat, e.latlng.lng);
    });
  }

  function switchBaseLayer() {
    const next = (activeBase === "OSM") ? "ESRI" : "OSM";
    try {
      map.removeLayer(baseLayers[activeBase]);
      activeBase = next;
      baseLayers[activeBase].addTo(map);
      setStatus(`Layer: ${activeBase === "OSM" ? "OSM" : "Satellit"}`, "ok");
    } catch (e) {
      console.warn(e);
      setStatus("Layerwechsel fehlgeschlagen.", "error");
    }
  }

  function updateBalloonOnMap(pos) {
    if (!pos || !balloonMarker) return;
    balloonMarker.setLatLng([pos.lat, pos.lon]);
    if (STATE.ui.follow) map.panTo([pos.lat, pos.lon], { animate: true, duration: 0.25 });
  }

  function maybeAddTrackPoint(pos) {
    if (!STATE.flight.active || !pos) return;
    const now = pos.ts || Date.now();
    const tr = STATE.flight.track;
    const last = tr.length ? tr[tr.length - 1] : null;
    if (!last) { tr.push({ lat: pos.lat, lon: pos.lon, altM: pos.altM || 0, ts: now }); return; }
    const dt = now - last.ts;
    if (dt < APP.track.minDtMs) return;
    const d = distM({ lat: last.lat, lon: last.lon }, { lat: pos.lat, lon: pos.lon });
    if (d < APP.track.minDistM) return;
    tr.push({ lat: pos.lat, lon: pos.lon, altM: pos.altM || 0, ts: now });
  }

  function updateTrackLine() {
    trackLine.setLatLngs(STATE.flight.track.map(p => [p.lat, p.lon]));
  }

  function windAtAlt(altM) {
    const prof = STATE.wind.profile || [];
    if (!prof.length) return null;
    let best = prof[0], bestD = Math.abs(prof[0].altM - altM);
    for (const w of prof) {
      const d = Math.abs(w.altM - altM);
      if (d < bestD) { bestD = d; best = w; }
    }
    return best;
  }

  function computeTrajectory(pos) {
    if (!pos) return [];
    const nav = computeNav();
    const best = nav?.bestLayer;
    if (!best) return [];
    const driftDeg = degNormalize(best.dirFromDeg + 180);
    const speedMps = kmhToMps(best.speedKmh || 0);
    if (speedMps <= 0.1) return [];
    const minutes = [5, 10, 15];
    const out = [[pos.lat, pos.lon]];
    const start = { lat: pos.lat, lon: pos.lon };
    for (const m of minutes) {
      const d = speedMps * (m * 60);
      const dest = projectLatLon(start.lat, start.lon, driftDeg, d);
      out.push([dest.lat, dest.lon]);
    }
    return out;
  }

  function updateTrajectoryLine() {
    const pos = getCurrentPosition();
    trajLine.setLatLngs(computeTrajectory(pos));
  }

  function renderMapTasks() {
    if (!taskLayerGroup) return;
    taskLayerGroup.clearLayers();

    const briefing = STATE.flight.active ? STATE.flight.briefingSnapshot : getSelectedBriefing();
    if (!briefing) return;

    for (const task of (briefing.tasks || [])) drawTask(task, briefing.id);

    updateTrackLine();
    updateTrajectoryLine();
  }

  function drawTask(task, briefingId) {
    const def = getTaskDefByShort(task.short);
    if (!def) return;

    if (def.short === "HWZ") {
      const targets = Array.isArray(task.targets) ? task.targets : [];
      targets.forEach((p, i) => {
        if (!p || p.lat==null || p.lon==null) return;
        const mk = createDraggableTaskMarker([p.lat, p.lon], `${def.short} Ziel ${i+1}`, briefingId, task.id, `HWZ_${i}`);
        taskLayerGroup.addLayer(mk);
      });
      return;
    }

    const pts = task.points || {};
    for (const pd of (def.points || [])) {
      const p = pts[pd.id];
      if (!p || p.lat==null || p.lon==null) continue;
      const mk = createDraggableTaskMarker([p.lat, p.lon], `${def.short} ${pd.label}`, briefingId, task.id, pd.id);
      taskLayerGroup.addLayer(mk);
    }

    // 3DT donut
    if (def.short === "3DT") {
      const c = pts["C"];
      if (c?.lat!=null && c?.lon!=null) {
        const inner = Number(task.fields?.innerRadiusM ?? 0);
        const outer = Number(task.fields?.outerRadiusM ?? 0);
        if (outer > 0) {
          if (inner > 0) {
            taskLayerGroup.addLayer(L.circle([c.lat, c.lon], {
              radius: inner, color: "#f97316", weight: 2,
              fillColor: "#f97316", fillOpacity: 0.08
            }));
          }
          taskLayerGroup.addLayer(L.circle([c.lat, c.lon], {
            radius: outer, color: "#38bdf8", weight: 2,
            fillColor: "#38bdf8", fillOpacity: 0.08
          }));
        }
      }
    }

    // ANG A->B line, LRN polygon
    if (def.short === "ANG") {
      const A = pts["A"], B = pts["B"];
      if (A?.lat!=null && B?.lat!=null) {
        taskLayerGroup.addLayer(L.polyline([[A.lat, A.lon],[B.lat,B.lon]], { color:"#60a5fa", weight:3, opacity:0.9 }));
      }
    }
    if (def.short === "LRN") {
      const A = pts["A"], B = pts["B"], C = pts["C"];
      if (A?.lat!=null && B?.lat!=null && C?.lat!=null) {
        taskLayerGroup.addLayer(L.polygon([[A.lat,A.lon],[B.lat,B.lon],[C.lat,C.lon]], { color:"#a78bfa", weight:2, fillColor:"#a78bfa", fillOpacity:0.06 }));
      }
    }
  }

  function createDraggableTaskMarker(latlng, label, briefingId, taskId, pointKey) {
    const isEditable = !STATE.flight.active;
    const html = `
      <div class="relative">
        <div class="w-9 h-9 rounded-2xl bg-indigo-500/15 border border-indigo-400/30 grid place-items-center shadow-lg">
          <i class="fa-solid fa-location-dot text-indigo-100"></i>
        </div>
        <div class="absolute -bottom-6 left-1/2 -translate-x-1/2 whitespace-nowrap text-[10px] px-2 py-0.5 rounded-full bg-slate-950/70 border border-slate-700/30 text-slate-100">
          ${escHtml(label)}
        </div>
      </div>
    `;
    const mk = L.marker(latlng, {
      icon: L.divIcon({ className:"", html, iconSize:[36,36], iconAnchor:[18,18] }),
      draggable: isEditable
    });

    mk.on("dragend", (e) => {
      const ll = e.target.getLatLng();
      applyPointToTask(briefingId, taskId, pointKey, ll.lat, ll.lng);
      setStatus(`Punkt verschoben: ${label} → ${fmtLatLon(ll.lat, ll.lng)}`, "ok");
      renderAll();
    });

    return mk;
  }

  function applyPointToTask(briefingId, taskId, pointKey, lat, lon) {
    const b = getBriefingById(briefingId);
    if (!b) return;
    const t = (b.tasks || []).find(x => x.id === taskId);
    if (!t) return;

    if (String(pointKey).startsWith("HWZ_")) {
      const idx = Number(String(pointKey).split("_")[1]);
      if (!Array.isArray(t.targets)) t.targets = [];
      if (!t.targets[idx]) t.targets[idx] = {};
      t.targets[idx].lat = lat;
      t.targets[idx].lon = lon;
    } else {
      t.points = t.points || {};
      t.points[pointKey] = t.points[pointKey] || {};
      t.points[pointKey].lat = lat;
      t.points[pointKey].lon = lon;
    }

    t.updatedTs = Date.now();
    b.updatedTs = Date.now();
    saveToStorage();
  }

  function startPickMode(briefingId, taskId, pointKey, label) {
    STATE.ui.picking = { briefingId, taskId, pointKey, label };
    // Make planning intuitive: collapse panel so map is free
    setSheetState("collapsed");
    setStatus(`Punkt setzen: ${label} · Tippe in die Karte.`, "hint", false);
  }

  function handlePickedPoint(lat, lon) {
    const pick = STATE.ui.picking;
    if (!pick) return;

    applyPointToTask(pick.briefingId, pick.taskId, pick.pointKey, lat, lon);
    STATE.ui.picking = null;

    setStatus(`Punkt gesetzt: ${pick.label} → ${fmtLatLon(lat, lon)}`, "ok");
    // Expand back to continue editing
    setSheetState("expanded");
    renderAll();
  }

  function computeNav() {
    const pos = getCurrentPosition();
    if (!pos) return null;

    const briefing = STATE.flight.active ? STATE.flight.briefingSnapshot : getSelectedBriefing();
    if (!briefing || !briefing.tasks?.length) return null;

    const task = briefing.tasks[0];
    const def = getTaskDefByShort(task.short);
    if (!def) return null;

    let target = null;
    let title = `${def.short} – ${def.title}`;

    if (def.short === "HWZ") {
      const targets = Array.isArray(task.targets) ? task.targets : [];
      const valid = targets.filter(p => p?.lat!=null && p?.lon!=null).map(p => ({ lat:p.lat, lon:p.lon }));
      if (!valid.length) return { title, line: "Keine Ziele gesetzt.", bestLayer: null, recText: "—" };
      let best = valid[0], bestD = Infinity;
      for (const t of valid) {
        const d = distM({lat:pos.lat,lon:pos.lon}, t);
        if (d < bestD) { bestD = d; best = t; }
      }
      target = best;
      title += " (nächstes Ziel)";
    } else if (def.points?.length) {
      const key = def.points[0].id;
      const p = task.points?.[key];
      if (p?.lat!=null && p?.lon!=null) target = { lat:p.lat, lon:p.lon };
      else return { title, line: "Zielpunkt fehlt.", bestLayer: null, recText: "—" };
    } else {
      return { title, line: "Keine Nav-Ziele.", bestLayer: null, recText: "—" };
    }

    const dM = distM({lat:pos.lat,lon:pos.lon}, target);
    const brg = bearingDeg({lat:pos.lat,lon:pos.lon}, target);

    const bestLayer = pickBestWindLayer(brg);
    const recText = bestLayer ? buildAltRecommendation(bestLayer.altM, pos.altM || 0) : "Windprofil fehlt.";

    let extra = "";
    if (def.short === "3DT") {
      const c = task.points?.C;
      const inner = Number(task.fields?.innerRadiusM ?? 0);
      const outer = Number(task.fields?.outerRadiusM ?? 0);
      if (c?.lat!=null && outer > 0) {
        const r = distM({lat:pos.lat,lon:pos.lon}, {lat:c.lat, lon:c.lon});
        if (inner > 0 && r < inner) extra = " · Innen: ungültig";
        else if (r <= outer) extra = " · Im Ring: Distanz maximieren";
        else extra = " · Außen: Richtung Zentrum";
      }
    }

    const line = `${fmtNum(metersToKm(dM), 2)} km · Kurs ${fmtNum(brg, 0)}°${extra}`;
    return { title, line, bestLayer, recText };
  }

  function pickBestWindLayer(desiredBearingDeg) {
    const prof = STATE.wind.profile || [];
    if (!prof.length) return null;

    let best = null;
    let bestScore = Infinity;

    for (const w of prof) {
      if (!isFinite(w.speedKmh) || !isFinite(w.dirFromDeg)) continue;
      const drift = degNormalize(w.dirFromDeg + 180);
      const a = degDiff(drift, desiredBearingDeg);
      const speedPenalty = (w.speedKmh < 6) ? (6 - w.speedKmh) * 2.5 : 0;
      const score = a + speedPenalty;
      if (score < bestScore) { bestScore = score; best = w; }
    }
    return best;
  }

  function buildAltRecommendation(targetAltM, currentAltM) {
    const delta = targetAltM - currentAltM;
    if (!isFinite(delta)) return "—";
    if (Math.abs(delta) < 25) return `Layer passt: ~${Math.round(targetAltM)} m halten`;
    if (delta > 0) return `Steigen auf ~${Math.round(targetAltM)} m (+${Math.round(delta)} m)`;
    return `Sinken auf ~${Math.round(targetAltM)} m (${Math.round(delta)} m)`;
  }

  // GPS
  function startGps() {
    if (!("geolocation" in navigator)) {
      STATE.gps.err = "Geolocation nicht verfügbar";
      setGpsPill("GPS: nicht verfügbar", false);
      setStatus("GPS nicht verfügbar.", "error");
      return;
    }
    setGpsPill("GPS: Suche…", false);
    navigator.geolocation.watchPosition(onGpsFix, onGpsErr, APP.gps);
  }

  function onGpsFix(p) {
    try {
      const c = p.coords;
      const ts = p.timestamp || Date.now();
      const raw = {
        lat: c.latitude,
        lon: c.longitude,
        altM: isFinite(c.altitude) ? c.altitude : (STATE.gps.lastRaw?.altM ?? 0),
        spdKmh: isFinite(c.speed) ? mpsToKmh(c.speed) : (STATE.gps.lastRaw?.spdKmh ?? 0),
        hdgDeg: isFinite(c.heading) ? c.heading : (STATE.gps.lastRaw?.hdgDeg ?? 0),
        accM: isFinite(c.accuracy) ? c.accuracy : 999,
        ts
      };

      const last = STATE.gps.lastRaw;
      if (last) {
        const dtS = Math.max(0.2, (raw.ts - last.ts) / 1000);
        const d = distM({lat:last.lat,lon:last.lon}, {lat:raw.lat,lon:raw.lon});
        const spdKmhEst = mpsToKmh(d / dtS);
        if (spdKmhEst > APP.smoothing.maxSpeedKmh) return;
        if ((raw.spdKmh < 4) && (d > APP.smoothing.maxJumpM) && (raw.accM > 20)) return;
      }

      STATE.gps.ok = true;
      STATE.gps.err = null;
      STATE.gps.fixCount++;
      STATE.gps.lastRaw = raw;

      const acc = clamp(raw.accM || 50, 5, 100);
      const alpha = clamp(0.5 * (1 / (acc / 10)), APP.smoothing.minAlpha, APP.smoothing.maxAlpha);

      if (!STATE.gps.lastSmooth) {
        STATE.gps.lastSmooth = { lat: raw.lat, lon: raw.lon };
      } else {
        STATE.gps.lastSmooth.lat = STATE.gps.lastSmooth.lat + alpha * (raw.lat - STATE.gps.lastSmooth.lat);
        STATE.gps.lastSmooth.lon = STATE.gps.lastSmooth.lon + alpha * (raw.lon - STATE.gps.lastSmooth.lon);
      }

      const disp = { ...raw, lat: STATE.gps.lastSmooth.lat, lon: STATE.gps.lastSmooth.lon };
      setGpsPill(`GPS: ${fmtNum(raw.accM,0)}m`, true);

      if (!STATE.settings.simEnabled || !STATE.sim.active) updateBalloonOnMap(disp);

      maybeAddTrackPoint(disp);
      updateTrackLine();
      updateTrajectoryLine();

      renderCockpit();
      renderWindPanel();
    } catch (e) {
      console.warn("GPS fix error:", e);
    }
  }

  function onGpsErr(e) {
    STATE.gps.ok = false;
    STATE.gps.err = e?.message || "GPS Fehler";
    setGpsPill("GPS: Fehler", false);
    setStatus(`GPS Fehler: ${STATE.gps.err}`, "error");
  }

  // Wind online
  async function fetchWindOnline() {
    const pos = getCurrentPosition();
    if (!pos) { STATE.wind.lastError = "Keine Position"; renderWindPanel(); setStatus("Wind: keine Position.", "error"); return; }

    try {
      STATE.wind.lastError = null;
      const params = new URLSearchParams();
      params.set("latitude", String(pos.lat));
      params.set("longitude", String(pos.lon));
      params.set("timezone", "auto");
      params.set("wind_speed_unit", "kmh");
      params.set("past_hours", "1");
      params.set("forecast_hours", "6");

      // Try both naming variants used by Open-Meteo over time
      const hourlyVars = [];
      for (const lvl of OPEN_METEO.levels) {
        hourlyVars.push(`wind_speed_${lvl.key}`);
        hourlyVars.push(`wind_direction_${lvl.key}`);
        hourlyVars.push(`windspeed_${lvl.key}`);
        hourlyVars.push(`winddirection_${lvl.key}`);
      }
      // de-dupe
      params.set("hourly", Array.from(new Set(hourlyVars)).join(","));

      const url = `${OPEN_METEO.endpoint}?${params.toString()}`;
      const res = await fetch(url, { method: "GET" });
      if (!res.ok) {
        const txt = await res.text().catch(()=> "");
        throw new Error(`HTTP ${res.status} ${res.statusText}${txt ? " · " + txt.slice(0,120) : ""}`);
      }
      const data = await res.json();

      const times = data?.hourly?.time;
      if (!Array.isArray(times) || !times.length) throw new Error("Antwort ohne hourly.time");

      const now = Date.now();
      let bestI = 0, bestDt = Infinity;
      for (let i=0;i<times.length;i++) {
        const t = Date.parse(times[i]);
        const dt = Math.abs(t - now);
        if (dt < bestDt) { bestDt = dt; bestI = i; }
      }

      const prof = [];
      for (const lvl of OPEN_METEO.levels) {
        const spdArrA = data?.hourly?.[`wind_speed_${lvl.key}`];
        const dirArrA = data?.hourly?.[`wind_direction_${lvl.key}`];
        const spdArrB = data?.hourly?.[`windspeed_${lvl.key}`];
        const dirArrB = data?.hourly?.[`winddirection_${lvl.key}`];

        const spd = Array.isArray(spdArrA) ? spdArrA[bestI] : (Array.isArray(spdArrB) ? spdArrB[bestI] : null);
        const dir = Array.isArray(dirArrA) ? dirArrA[bestI] : (Array.isArray(dirArrB) ? dirArrB[bestI] : null);

        if (!isFinite(spd) || !isFinite(dir)) continue;
        prof.push({ altM: lvl.altM, speedKmh: Number(spd), dirFromDeg: degNormalize(Number(dir)), ts: Date.now(), source: "Open-Meteo" });
      }

      if (!prof.length) throw new Error("Keine Windwerte gefunden (API/Variablen evtl. geändert).");

      STATE.wind.profile = prof.sort((a,b)=>a.altM-b.altM);
      STATE.wind.lastSource = "Open-Meteo";
      STATE.wind.lastUpdatedTs = Date.now();
      STATE.wind.lastError = null;

      saveToStorage();
      renderWindPanel();
      setStatus("Windprofil aktualisiert (Open-Meteo).", "ok");
    } catch (e) {
      STATE.wind.lastError = e?.message || String(e);
      renderWindPanel();
      setStatus(`Wind Fehler: ${STATE.wind.lastError}`, "error");
    }
  }

  // Flight
  function startFlight() {
    if (STATE.flight.active) return;
    const sel = getSelectedBriefing();
    if (!sel) { setStatus("Start: Kein Briefing gewählt.", "error"); return; }

    STATE.flight.active = true;
    STATE.flight.startedTs = Date.now();
    STATE.flight.endedTs = null;
    STATE.flight.briefingSnapshot = structuredCloneSafe(sel);
    STATE.flight.track = [];
    STATE.flight.markers = [];
    STATE.ui.follow = true;

    requestWakeLock();
    setStatus(`Fahrt gestartet: ${sel.title}`, "ok");
    renderAll();
  }

  function stopFlight() {
    if (!STATE.flight.active) return;

    STATE.flight.active = false;
    STATE.flight.endedTs = Date.now();
    releaseWakeLock();

    const title = STATE.flight.briefingSnapshot?.title || "Fahrt";
    const entry = {
      id: uid("arch"),
      title,
      startedTs: STATE.flight.startedTs,
      endedTs: STATE.flight.endedTs,
      track: STATE.flight.track.slice(),
      markers: STATE.flight.markers.slice(),
      briefingSnapshot: STATE.flight.briefingSnapshot
    };
    STATE.archive.push(entry);
    saveToStorage();

    STATE.flight.briefingSnapshot = null;
    STATE.flight.track = [];
    STATE.flight.markers = [];
    STATE.flight.startedTs = null;

    setStatus("Fahrt beendet und im Archiv gespeichert.", "ok");
    renderAll();
  }

  function dropMarker() {
    const pos = getCurrentPosition();
    if (!pos) { setStatus("Marker: Keine Position.", "error"); return; }
    if (!STATE.flight.active) { setStatus("Marker: Fahrt ist nicht aktiv (kein Auto-Start).", "hint"); return; }

    const expected = getExpectedMarkerColor();
    const key = Object.entries(MARKER_COLORS).find(([k,v]) => v.hex === expected.hex)?.[0] || "green";

    STATE.flight.markers.push({ lat: pos.lat, lon: pos.lon, ts: Date.now(), color: key });

    // Draw on map as small circle marker
    const c = MARKER_COLORS[key]?.hex || "#22c55e";
    L.circleMarker([pos.lat, pos.lon], { radius: 7, color: c, fillColor: c, fillOpacity: 0.85, weight: 2 })
      .addTo(taskLayerGroup);

    setStatus(`Marker gesetzt: ${MARKER_COLORS[key]?.name || key} · ${fmtLatLon(pos.lat, pos.lon)}`, "ok");
    renderTabLive();
  }

  // Briefings CRUD
  function createNewBriefing() {
    const title = prompt("Titel für neues Briefing:", "Morgenfahrt");
    if (!title) return;
    const b = { id: uid("brief"), title, createdTs: Date.now(), updatedTs: Date.now(), tasks: [] };
    STATE.briefings.list.push(b);
    STATE.briefings.selectedId = b.id;
    saveToStorage();
    renderAll();
    setStatus(`Briefing erstellt: ${title}`, "ok");
  }
  function renameBriefing() {
    const b = getSelectedBriefing();
    if (!b) return;
    const title = prompt("Neuer Titel:", b.title || "");
    if (!title) return;
    b.title = title;
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus("Briefing umbenannt.", "ok");
  }
  function deleteBriefing() {
    const b = getSelectedBriefing();
    if (!b) return;
    if (!confirm(`Briefing "${b.title}" löschen?`)) return;
    STATE.briefings.list = STATE.briefings.list.filter(x => x.id !== b.id);
    STATE.briefings.selectedId = STATE.briefings.list[0]?.id || null;
    saveToStorage();
    renderAll();
    setStatus("Briefing gelöscht.", "ok");
  }

  function addTaskToBriefing() {
    const b = getSelectedBriefing();
    if (!b) return;
    const d = TASK_LIBRARY[0];
    b.tasks.push({ id: uid("task"), short: d.short, cia: d.cia, markerColor: "", points: {}, targets: [], fields: {} });
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus("Aufgabe hinzugefügt. Jetzt Punkte setzen.", "hint");
  }

  function removeTask(briefingId, taskId) {
    const b = getBriefingById(briefingId);
    if (!b) return;
    b.tasks = (b.tasks || []).filter(t => t.id !== taskId);
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus("Aufgabe entfernt.", "ok");
  }

  function changeTaskType(briefingId, taskId, newShort) {
    const b = getBriefingById(briefingId);
    if (!b) return;
    const t = (b.tasks || []).find(x => x.id === taskId);
    if (!t) return;
    const def = getTaskDefByShort(newShort);
    if (!def) return;

    t.short = def.short;
    t.cia = def.cia;
    t.points = {};
    t.targets = [];
    t.fields = t.fields || {};

    for (const f of (def.fields || [])) {
      if (f.default != null && t.fields[f.key] == null) t.fields[f.key] = f.default;
      if (f.fixed) t.fields[f.key] = true;
    }

    t.updatedTs = Date.now();
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus(`Task geändert: ${def.cia} ${def.short}`, "ok");
  }

  function setTaskMarkerColor(briefingId, taskId, colorKey) {
    const b = getBriefingById(briefingId);
    if (!b) return;
    const t = (b.tasks || []).find(x => x.id === taskId);
    if (!t) return;
    t.markerColor = colorKey || "";
    t.updatedTs = Date.now();
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
  }

  // HWZ targets
  function addHwzTarget(briefingId, taskId) {
    const b = getBriefingById(briefingId);
    const t = b?.tasks?.find(x => x.id === taskId);
    if (!t) return;
    if (!Array.isArray(t.targets)) t.targets = [];
    t.targets.push({ lat: null, lon: null });
    t.updatedTs = Date.now();
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus("HWZ Ziel hinzugefügt. „Setzen“ drücken.", "hint");
  }
  function delHwzTarget(briefingId, taskId, idx) {
    const b = getBriefingById(briefingId);
    const t = b?.tasks?.find(x => x.id === taskId);
    if (!t || !Array.isArray(t.targets)) return;
    t.targets.splice(idx, 1);
    t.updatedTs = Date.now();
    b.updatedTs = Date.now();
    saveToStorage();
    renderAll();
    setStatus("HWZ Ziel gelöscht.", "ok");
  }

  // Export/Import briefings
  function downloadTextFile(text, filename, mime) {
    const blob = new Blob([text], { type: mime || "text/plain" });
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = filename;
    document.body.appendChild(a);
    a.click();
    a.remove();
    setTimeout(() => URL.revokeObjectURL(url), 2000);
  }

  function exportBriefings() {
    const payload = { app: APP.name, version: APP.version, exportedAt: new Date().toISOString(), briefings: STATE.briefings.list };
    downloadTextFile(JSON.stringify(payload, null, 2), `compnavair_briefings_${Date.now()}.json`, "application/json");
    setStatus("Briefings exportiert.", "ok");
  }

  async function importBriefingsFromFile(file) {
    try {
      const txt = await file.text();
      const obj = safeJsonParse(txt, null);
      const list = obj?.briefings;
      if (!Array.isArray(list)) throw new Error("Ungültige Datei: briefings[] fehlt.");

      const existingIds = new Set(STATE.briefings.list.map(b => b.id));
      const merged = [];

      for (const b of list) {
        if (!b || typeof b !== "object") continue;
        const nb = structuredCloneSafe(b);
        if (!nb.id || existingIds.has(nb.id)) nb.id = uid("brief");
        if (Array.isArray(nb.tasks)) {
          const seen = new Set();
          for (const t of nb.tasks) {
            if (!t.id || seen.has(t.id)) t.id = uid("task");
            seen.add(t.id);
          }
        }
        merged.push(nb);
      }

      STATE.briefings.list.push(...merged);
      if (!STATE.briefings.selectedId && STATE.briefings.list.length) STATE.briefings.selectedId = STATE.briefings.list[0].id;

      saveToStorage();
      renderAll();
      setStatus(`${merged.length} Briefing(s) importiert.`, "ok");
    } catch (e) {
      setStatus(`Import Fehler: ${e?.message || String(e)}`, "error");
    }
  }

  // KML
  async function importKmlFile(file) {
    try {
      const text = await file.text();
      const layer = omnivore.kml.parse(text);

      const overlayId = uid("kml");
      const name = file.name || "KML";
      const meta = { id: overlayId, name, layer, visible: true, source: "Datei" };

      layer.eachLayer((l) => {
        const props = (l.feature && l.feature.properties) ? l.feature.properties : {};
        const nm = props.name || props.Name || props.NAME || name || "KML";
        const desc = props.description || props.Description || props.DESCRIPTION || "";

        const restricted = isRestrictedAirspaceName(nm);

        if (typeof l.setStyle === "function") {
          l.setStyle(restricted ? {
            color: "#ef4444", weight: 2, opacity: 0.95,
            fillColor: "#ef4444", fillOpacity: 0.16
          } : {
            color: "#a78bfa", weight: 2, opacity: 0.85,
            fillColor: "#a78bfa", fillOpacity: 0.10
          });
        }

        l.on("click", (e) => {
          const ll = e?.latlng || (l.getBounds ? l.getBounds().getCenter() : null);
          if (!ll) return;
          const html = `
            <div class="text-[12px]">
              <div class="font-semibold">${escHtml(nm || "Luftraum")}</div>
              ${desc ? `<div class="mt-1 text-slate-200/90">${escHtml(desc).slice(0, 900)}</div>` : `<div class="mt-1 text-slate-200/70">Keine Details.</div>`}
            </div>
          `;
          L.popup({ className: "kml-popup", closeButton: true, autoPan: true })
            .setLatLng(ll)
            .setContent(html)
            .openOn(map);
        });
      });

      STATE.kml.overlays.push(meta);
      kmlLayerGroup.addLayer(layer);

      setStatus(`KML geladen: ${name}`, "ok");
      renderAll();
    } catch (e) {
      setStatus(`KML Fehler: ${e?.message || String(e)}`, "error");
    }
  }

  function toggleKmlOverlay(id) {
    const o = STATE.kml.overlays.find(x => x.id === id);
    if (!o) return;
    o.visible = !o.visible;
    if (o.visible) kmlLayerGroup.addLayer(o.layer);
    else kmlLayerGroup.removeLayer(o.layer);
    renderAll();
  }

  function removeKmlOverlay(id) {
    const idx = STATE.kml.overlays.findIndex(x => x.id === id);
    if (idx < 0) return;
    const o = STATE.kml.overlays[idx];
    try { kmlLayerGroup.removeLayer(o.layer); } catch {}
    STATE.kml.overlays.splice(idx, 1);
    renderAll();
    setStatus("KML entfernt.", "ok");
  }

  // KML export
  function exportKmlForFlight(flightObj, filenameBase) {
    const track = flightObj.track || [];
    const markers = flightObj.markers || [];
    const kmlTrackCoords = track.map(p => `${p.lon},${p.lat},${Math.round(p.altM||0)}`).join(" ");

    const markerPlacemarks = markers.map(m => `
      <Placemark>
        <name>${escHtml(`Marker ${fmtTime(m.ts)}`)}</name>
        <TimeStamp><when>${new Date(m.ts).toISOString()}</when></TimeStamp>
        <Point><coordinates>${m.lon},${m.lat},0</coordinates></Point>
      </Placemark>
    `.trim()).join("\n");

    const docName = escHtml(filenameBase || "CompNavAir");
    const kml = `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${docName}</name>
    <Placemark>
      <name>Track</name>
      <Style><LineStyle><color>ff4444ef</color><width>3</width></LineStyle></Style>
      <LineString>
        <tessellate>1</tessellate>
        <altitudeMode>absolute</altitudeMode>
        <coordinates>${kmlTrackCoords}</coordinates>
      </LineString>
    </Placemark>
    ${markerPlacemarks}
  </Document>
</kml>`;
    downloadTextFile(kml, `${filenameBase || "compnavair"}_${Date.now()}.kml`, "application/vnd.google-earth.kml+xml");
    setStatus("KML exportiert.", "ok");
  }

  // Simulation
  function setSimEnabled(on) {
    STATE.settings.simEnabled = !!on;
    if (!STATE.settings.simEnabled) STATE.sim.active = false;
    saveToStorage();
    renderAll();
  }

  function simUseGpsPosition() {
    const g = STATE.gps.lastRaw;
    if (!g) { setStatus("SIM: Keine GPS Position.", "error"); return; }
    STATE.sim.lat = g.lat;
    STATE.sim.lon = g.lon;
    STATE.sim.altM = g.altM || STATE.sim.altM;
    STATE.sim.hdgDeg = g.hdgDeg || 0;
    STATE.sim.active = true;
    setStatus("SIM auf GPS gesetzt.", "ok");
    renderAll();
  }

  function toggleSimActive() {
    if (!STATE.settings.simEnabled) return;
    STATE.sim.active = !STATE.sim.active;
    if (STATE.sim.active) {
      const g = STATE.gps.lastRaw;
      if (g) { STATE.sim.lat = g.lat; STATE.sim.lon = g.lon; STATE.sim.altM = g.altM || STATE.sim.altM; }
      setStatus("SIM aktiv.", "ok");
    } else {
      setStatus("SIM inaktiv.", "hint");
    }
    renderAll();
  }

  function startSimLoop() {
    if (simTimer) clearInterval(simTimer);
    simTimer = setInterval(simTick, APP.sim.tickMs);
  }

  function simTick() {
    if (!STATE.settings.simEnabled || !STATE.sim.active) return;

    const now = Date.now();
    const dt = STATE.sim.lastTickTs ? (now - STATE.sim.lastTickTs) / 1000 : (APP.sim.tickMs / 1000);
    STATE.sim.lastTickTs = now;

    let vario = 0;
    if (STATE.sim.burnerHeld) vario += APP.sim.climbRateMps;
    if (STATE.sim.ventHeld) vario -= APP.sim.sinkRateMps;

    STATE.sim.altM = clamp(STATE.sim.altM + vario * dt, 0, 9999);
    STATE.sim.varioMps = vario;

    const w = windAtAlt(STATE.sim.altM);
    const speedMps = w ? kmhToMps(w.speedKmh) : 0;
    const driftDeg = w ? degNormalize(w.dirFromDeg + 180) : 0;

    STATE.sim.spdKmh = mpsToKmh(speedMps);

    if (speedMps > 0.01) {
      const d = speedMps * dt;
      const dest = projectLatLon(STATE.sim.lat, STATE.sim.lon, driftDeg, d);
      STATE.sim.lat = dest.lat;
      STATE.sim.lon = dest.lon;
      STATE.sim.hdgDeg = driftDeg;
    }

    const pos = getCurrentPosition();
    if (pos) {
      updateBalloonOnMap(pos);
      maybeAddTrackPoint(pos);
      updateTrackLine();
      updateTrajectoryLine();
      renderCockpit();
      renderWindPanel();
    }
  }

  // Wake lock
  async function requestWakeLock() {
    try {
      if (!("wakeLock" in navigator)) return;
      wakeLock = await navigator.wakeLock.request("screen");
    } catch (e) {
      console.warn("WakeLock failed:", e);
    }
  }
  async function releaseWakeLock() {
    try { if (wakeLock) await wakeLock.release(); } catch {}
    wakeLock = null;
  }

  // ============================================================
  // 6) Event-Listener & Initialisierung (window.onload am Ende)
  // ============================================================
  function bindEvents() {
    // Panel / sheet
    document.getElementById("btnPanel").addEventListener("click", () => {
      // toggle between expanded and collapsed
      setSheetState(STATE.ui.sheet === "expanded" ? "collapsed" : "expanded");
    });

    document.getElementById("btnSheetToggle").addEventListener("click", () => {
      setSheetState(STATE.ui.sheet === "expanded" ? "collapsed" : "expanded");
    });

    // Tabs
    document.querySelectorAll(".tabBtn").forEach(btn => {
      btn.addEventListener("click", () => {
        STATE.ui.activeTab = btn.dataset.tab;
        // if user is picking, keep collapsed
        if (!STATE.ui.picking && STATE.ui.sheet === "collapsed") setSheetState("expanded");
        renderSheet();
      });
    });

    // Header buttons
    document.getElementById("btnFollow").addEventListener("click", () => {
      STATE.ui.follow = true;
      const pos = getCurrentPosition();
      if (pos) map.panTo([pos.lat, pos.lon], { animate:true, duration:0.25 });
      setStatus("Zentriert & Follow aktiv.", "ok");
      renderAll();
    });

    document.getElementById("btnLayer").addEventListener("click", switchBaseLayer);
    document.getElementById("btnFinish").addEventListener("click", stopFlight);

    // Wind panel
    document.getElementById("btnWindCollapse").addEventListener("click", () => setWindCollapsed(true));
    document.getElementById("btnWindExpand").addEventListener("click", () => setWindCollapsed(false));
    document.getElementById("btnWindFetch").addEventListener("click", fetchWindOnline);

    // SIM controls (hold)
    const hold = (btn, onDown, onUp) => {
      const down = (e) => { e.preventDefault(); onDown(); };
      const up = (e) => { e.preventDefault(); onUp(); };
      btn.addEventListener("pointerdown", down);
      btn.addEventListener("pointerup", up);
      btn.addEventListener("pointercancel", up);
      btn.addEventListener("pointerleave", up);
    };
    hold(document.getElementById("btnBurn"), () => STATE.sim.burnerHeld = true, () => STATE.sim.burnerHeld = false);
    hold(document.getElementById("btnVent"), () => STATE.sim.ventHeld = true, () => STATE.sim.ventHeld = false);

    // Marker
    document.getElementById("btnMarker").addEventListener("click", dropMarker);

    // Delegated events
    document.addEventListener("change", (e) => {
      const t = e.target;
      if (!t) return;

      if (t.id === "selBriefing") {
        STATE.briefings.selectedId = t.value || null;
        renderAll();
        return;
      }
      if (t.id === "briefingImportFile" && t.files && t.files[0]) {
        importBriefingsFromFile(t.files[0]);
        t.value = "";
        return;
      }
      if (t.id === "tglSim") {
        setSimEnabled(t.checked);
        return;
      }
      if (t.id === "kmlFile" && t.files && t.files[0]) {
        importKmlFile(t.files[0]);
        t.value = "";
        return;
      }

      if (t.dataset.action === "taskType") {
        changeTaskType(t.dataset.b, t.dataset.t, t.value);
        return;
      }
      if (t.dataset.action === "taskMarkerColor") {
        setTaskMarkerColor(t.dataset.b, t.dataset.t, t.value);
        return;
      }
      if (t.dataset.action === "fieldBool") {
        const b = getBriefingById(t.dataset.b);
        const task = b?.tasks?.find(x => x.id === t.dataset.t);
        if (task) {
          task.fields = task.fields || {};
          task.fields[t.dataset.k] = !!t.checked;
          task.updatedTs = Date.now(); b.updatedTs = Date.now();
          saveToStorage(); renderAll();
        }
        return;
      }
    });

    document.addEventListener("input", (e) => {
      const t = e.target;
      if (!t) return;

      if (t.dataset.action === "fieldNum") {
        const b = getBriefingById(t.dataset.b);
        const task = b?.tasks?.find(x => x.id === t.dataset.t);
        if (task) {
          task.fields = task.fields || {};
          const v = Number(String(t.value).replace(",", "."));
          task.fields[t.dataset.k] = isFinite(v) ? v : null;
          task.updatedTs = Date.now(); b.updatedTs = Date.now();
          saveToStorage();
          renderMapTasks(); renderWindPanel();
        }
      }

      if (t.dataset.action === "fieldText") {
        const b = getBriefingById(t.dataset.b);
        const task = b?.tasks?.find(x => x.id === t.dataset.t);
        if (task) {
          task.fields = task.fields || {};
          task.fields[t.dataset.k] = t.value;
          task.updatedTs = Date.now(); b.updatedTs = Date.now();
          saveToStorage();
        }
      }
    });

    document.addEventListener("click", (e) => {
      const btn = e.target?.closest?.("[data-action]") || null;
      const id = e.target?.id;

      // direct buttons by id
      if (id === "btnBriefingNew") { createNewBriefing(); return; }
      if (id === "btnBriefingRename") { renameBriefing(); return; }
      if (id === "btnBriefingDelete") { deleteBriefing(); return; }
      if (id === "btnBriefingExport") { exportBriefings(); return; }
      if (id === "btnAddTask") { addTaskToBriefing(); return; }
      if (id === "btnStartFlight") { startFlight(); return; }

      if (id === "btnLiveCenter") {
        const pos = getCurrentPosition();
        if (pos) map.panTo([pos.lat, pos.lon], { animate:true, duration:0.25 });
        return;
      }
      if (id === "btnLiveToggleFollow") { STATE.ui.follow = !STATE.ui.follow; renderAll(); return; }
      if (id === "btnLiveStop") { stopFlight(); return; }
      if (id === "btnLiveKmlNow") { if (STATE.flight.active) exportKmlForFlight(STATE.flight, STATE.flight.briefingSnapshot?.title || "flight"); return; }

      if (id === "btnSimUseGps") { simUseGpsPosition(); return; }
      if (id === "btnSimToggleActive") { toggleSimActive(); return; }

      if (id === "btnWindAddManual") {
        const alt = Number(String(document.getElementById("windAlt").value).replace(",", "."));
        const dir = Number(String(document.getElementById("windDir").value).replace(",", "."));
        const spd = Number(String(document.getElementById("windSpd").value).replace(",", "."));
        if (!isFinite(alt) || !isFinite(dir) || !isFinite(spd)) { setStatus("Wind: bitte Alt/Dir/Speed korrekt.", "error"); return; }
        STATE.wind.profile.push({ altM: Math.round(alt), dirFromDeg: degNormalize(dir), speedKmh: spd, ts: Date.now(), source: "Manuell" });
        STATE.wind.profile.sort((a,b)=>a.altM-b.altM);
        STATE.wind.lastSource = "Manuell";
        STATE.wind.lastUpdatedTs = Date.now();
        saveToStorage();
        document.getElementById("windAlt").value = "";
        document.getElementById("windDir").value = "";
        document.getElementById("windSpd").value = "";
        renderAll();
        setStatus("Wind: Eintrag hinzugefügt.", "ok");
        return;
      }
      if (id === "btnWindClear") {
        STATE.wind.profile = [];
        STATE.wind.lastSource = "—";
        STATE.wind.lastUpdatedTs = null;
        STATE.wind.lastError = null;
        saveToStorage();
        renderAll();
        setStatus("Windprofil geleert.", "ok");
        return;
      }

      // delegated by data-action
      if (!btn) return;
      const action = btn.dataset.action;

      if (action === "delTask") { removeTask(btn.dataset.b, btn.dataset.t); return; }
      if (action === "pickPoint") { startPickMode(btn.dataset.b, btn.dataset.t, btn.dataset.k, btn.dataset.l); return; }
      if (action === "addHWZ") { addHwzTarget(btn.dataset.b, btn.dataset.t); return; }
      if (action === "delHWZ") { delHwzTarget(btn.dataset.b, btn.dataset.t, Number(btn.dataset.i)); return; }
      if (action === "pickHWZ") { startPickMode(btn.dataset.b, btn.dataset.t, `HWZ_${Number(btn.dataset.i)}`, `HWZ Ziel ${Number(btn.dataset.i)+1}`); return; }

      if (action === "kmlToggle") { toggleKmlOverlay(btn.dataset.id); return; }
      if (action === "kmlRemove") { removeKmlOverlay(btn.dataset.id); return; }

      if (action === "archKml") {
        const a = STATE.archive.find(x => x.id === btn.dataset.id);
        if (a) exportKmlForFlight(a, a.title || "flight");
        return;
      }
      if (action === "archDel") {
        STATE.archive = STATE.archive.filter(x => x.id !== btn.dataset.id);
        saveToStorage();
        renderAll();
        setStatus("Archiv-Eintrag gelöscht.", "ok");
        return;
      }
      if (action === "archShow") {
        const a = STATE.archive.find(x => x.id === btn.dataset.id);
        if (a && a.track?.length) {
          const bounds = L.latLngBounds(a.track.map(p => [p.lat, p.lon]));
          map.fitBounds(bounds.pad(0.2));
          setStatus("Archiv: Track zentriert.", "ok");
        }
        return;
      }
    });
  }

  window.onload = () => {
    loadFromStorage();
    initMap();
    bindEvents();

    // seed briefing
    if (!STATE.briefings.list.length) {
      STATE.briefings.list.push({
        id: uid("brief"),
        title: "Morgenfahrt",
        createdTs: Date.now(),
        updatedTs: Date.now(),
        tasks: [{
          id: uid("task"),
          short: "JDG",
          cia: "15.2",
          markerColor: "",
          points: {},
          targets: [],
          fields: {}
        }]
      });
      STATE.briefings.selectedId = STATE.briefings.list[0].id;
      saveToStorage();
    }

    setWindCollapsed(false);
    setSheetState("expanded");

    startGps();
    startSimLoop();

    renderAll();
    setStatus("Bereit: Plane Briefing im Panel unten. Keine Toasts auf der Karte.", "ok");
  };
  </script>
</body>
</html>
