<!DOCTYPE html>
<html lang="de" class="dark">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>BallonNav Pilot PRO</title>
    
    <!-- PWA Integration -->
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#020617">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="BallonNav">

    <!-- Generated Favicon: Purple Balloon with Moon & Stars -->
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><path d=%22M50,95 C20,70 5,45 5,35 A45,45 0 0,1 95,35 C95,45 80,70 50,95 Z%22 fill=%22%234c1d95%22 stroke=%22white%22 stroke-width=%221%22/><path d=%22M65,30 Q80,50 65,70 Q55,50 65,30%22 fill=%22%23fbbf24%22/><text x=%2225%22 y=%2230%22 fill=%22%23fbbf24%22 font-size=%2210%22>★</text><text x=%2235%22 y=%2250%22 fill=%22%23fbbf24%22 font-size=%228%22>★</text><text x=%2220%22 y=%2260%22 fill=%22%23fbbf24%22 font-size=%2212%22>★</text><text x=%2280%22 y=%2235%22 fill=%22%23fbbf24%22 font-size=%229%22>★</text></svg>">

    <!-- Frameworks & Libraries -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <!-- KML Parser Plugin -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/js/all.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>

    <style>
        :root {
            --glass-bg: rgba(15, 23, 42, 0.85);
            --glass-border: rgba(255, 255, 255, 0.1);
            --accent-blue: #3b82f6;
            --accent-red: #ef4444;
            --accent-green: #22c55e;
            --accent-yellow: #eab308;
            --accent-purple: #a855f7;
        }

        body, html {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #020617;
            color: #f8fafc;
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
        }

        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            z-index: 0;
            background: #020617;
        }

        .glass-panel {
            background: var(--glass-bg);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid var(--glass-border);
            border-radius: 12px;
            box-shadow: 0 8px 32px 0 rgba(0, 0, 0, 0.5);
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* --- HUD COMMON ANIMATIONS --- */
        .hud-container-anim {
            transition: left 0.5s cubic-bezier(0.4, 0, 0.2, 1), transform 0.5s cubic-bezier(0.4, 0, 0.2, 1);
        }

        /* --- HUD TOP CONTAINER --- */
        .hud-top-container {
            position: absolute;
            top: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 1000;
            width: 95%;
            max-width: 800px;
            min-height: 75px; 
            display: flex;
            align-items: center; 
            padding-left: 40px; 
            pointer-events: none;
        }

        .hud-top-container.docked {
            left: 10px;
            transform: translateX(0);
            width: auto;
        }

        .hud-top {
            pointer-events: auto;
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr 0.5fr; /* Time column smaller */
            gap: 4px;
            padding: 8px;
            width: 100%;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1;
            transform: translateX(0);
        }

        .hud-top.minimized {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-20px);
            position: absolute; 
        }

        /* Toggle Button Wrapper */
        #btn-top-toggle-wrapper {
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            z-index: 1001;
            pointer-events: auto;
        }

        /* --- NAVIGATION HUD --- */
        .hud-nav-container {
            position: absolute;
            top: 80px; 
            left: 50%;
            transform: translateX(-50%);
            z-index: 990;
            width: 90%;
            max-width: 650px; /* Widened slightly for CPA */
            min-height: 75px; 
            display: flex;
            flex-direction: column; 
            align-items: center;
            padding-left: 40px;
            pointer-events: none;
        }

        .hud-nav-container.docked {
            left: 10px;
            transform: translateX(0);
            align-items: flex-start; /* Align left when docked */
            width: auto;
        }

        .hud-nav {
            pointer-events: auto;
            display: grid;
            /* Changed Grid for CPA: Dist | CPA (Smaller) | Brg | ETE */
            grid-template-columns: 1fr 0.7fr 1fr 1fr;
            gap: 4px;
            padding: 8px;
            border-color: var(--accent-yellow);
            border-width: 1px;
            width: 100%;
            transition: opacity 0.3s ease, transform 0.3s ease;
            opacity: 1;
            transform: translateX(0);
            position: relative;
        }
        
        .hud-nav.minimized {
            opacity: 0;
            pointer-events: none;
            transform: translateX(-20px);
            position: absolute;
        }

        /* CAR-STYLE INSTRUCTION BAR */
        #nav-instruction-bar {
            position: fixed;
            bottom: 100px; /* Above Bottom Toolbar */
            left: 50%;
            transform: translateX(-50%) translateY(20px); /* Start slightly down */
            z-index: 2000;
            pointer-events: auto;
            
            background: rgba(15, 23, 42, 0.95); /* Darker, more solid */
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-left-width: 4px; /* Colored accent bar */
            
            color: white;
            padding: 12px 20px;
            border-radius: 8px;
            
            font-size: 1.1rem;
            font-weight: 600;
            letter-spacing: 0.02em;
            
            display: flex;
            align-items: center;
            gap: 12px;
            box-shadow: 0 10px 25px rgba(0,0,0,0.5);
            
            transition: all 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            opacity: 0;
            visibility: hidden;
            max-width: 90%;
            width: auto;
            text-align: center;
        }
        
        #nav-instruction-bar.visible {
            opacity: 1;
            visibility: visible;
            transform: translateX(-50%) translateY(0);
        }

        /* Mode Styles for the Bar */
        #nav-instruction-bar.mode-ai { border-left-color: #3b82f6; } /* Blue */
        #nav-instruction-bar.mode-local { border-left-color: #f59e0b; } /* Amber */

        #btn-nav-toggle-wrapper {
            position: absolute;
            left: 0;
            top: 28px; /* Adjusted top alignment */
            z-index: 991;
            pointer-events: auto;
        }

        /* --- TOGGLE ICONS ROTATION --- */
        #icon-top-hud-toggle, 
        #icon-nav-hud-toggle, 
        #icon-wind-toggle {
            transition: transform 0.3s ease;
        }
        
        #icon-top-hud-toggle.collapsed, 
        #icon-nav-hud-toggle.collapsed, 
        #icon-wind-toggle.collapsed {
            transform: rotate(180deg);
        }

        .hud-value { text-align: center; }
        .hud-label { font-size: 0.75rem; color: #94a3b8; letter-spacing: 0.05em; font-weight: 600; display: flex; align-items: center; justify-content: center; gap: 2px; }
        .hud-label small { font-size: 0.55rem; opacity: 0.7; font-weight: normal; margin-left: 2px; }
        .hud-num { font-size: 1.4rem; font-weight: 700; font-family: 'Courier New', Courier, monospace; }
        .hud-nav .hud-num { font-size: 1.2rem; color: var(--accent-yellow); }
        
        /* Specific style for CPA in HUD to make it slightly smaller/different as requested */
        #hud-cpa { font-size: 1.0rem; color: var(--accent-purple); display: block; }
        #lbl-cpa { color: #c084fc; }
        #hud-cpa-time { font-family: 'Inter', sans-serif; }

        /* Animation for Vario Warning */
        @keyframes blink-red { 
            0%, 100% { color: #f87171; text-shadow: 0 0 5px rgba(239, 68, 68, 0.5); } 
            50% { color: #fee2e2; text-shadow: 0 0 10px rgba(239, 68, 68, 1); } 
        }
        .text-blink-red { animation: blink-red 0.8s infinite ease-in-out; }

        /* Time Display Style */
        #hud-time { font-size: 1.0rem; color: #cbd5e1; font-family: 'Inter', sans-serif; font-weight: 600; margin-top: 4px; }

        .sidebar-left { 
            position: absolute; 
            bottom: 30px; 
            left: 10px; 
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            gap: 10px; 
        }
        
        .sidebar-right-container { 
            position: absolute; 
            top: 150px; 
            right: 10px; 
            z-index: 1000; 
            display: flex; 
            flex-direction: column; 
            align-items: end; 
            gap: 5px; 
            transition: top 0.3s ease;
        }

        /* --- WIND PANEL UPDATED FOR HORIZONTAL SLIDE --- */
        #wind-panel {
            width: 120px; 
            display: flex; 
            flex-direction: column; 
            overflow: hidden; 
            transition: width 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s ease;
        }
        
        #wind-panel.collapsed {
            width: 0;
            padding: 0;
            border: none;
            opacity: 0;
        }
        
        #wind-content-wrapper {
            width: 120px; /* Fixed width to prevent content squishing */
        }

        /* --- STATUS AREA (REVISED FOR COLLAPSIBLE LINE BEHAVIOR) --- */
        .status-area {
            position: absolute;
            top: 10px;
            right: 0; /* Sticky to right edge */
            z-index: 1000;
            display: flex;
            flex-direction: column;
            gap: 8px;
            align-items: flex-end; /* Align items to the right */
            pointer-events: none; /* Pass clicks through container */
        }
        
        .status-badge {
            pointer-events: auto; /* Enable clicks on badges */
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            
            /* Border Logic for "Line" look */
            border: 1px solid rgba(255,255,255,0.1);
            border-right: none; /* Remove right border to merge with edge */
            border-left: 5px solid; /* This is the visible "line" */
            
            padding: 6px 12px;
            padding-left: 10px; /* Space from colored line */
            border-radius: 6px 0 0 6px; /* Round only left corners */
            
            font-size: 0.7rem;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: -2px 2px 8px rgba(0,0,0,0.3);
            cursor: pointer;
            
            /* Animation Transition */
            transition: transform 0.4s cubic-bezier(0.19, 1, 0.22, 1);
            
            /* COLLAPSED STATE (Default) */
            /* Translate right so only the 5px border + maybe 2px of body is visible */
            transform: translateX(calc(100% - 5px)); 
            white-space: nowrap;
        }

        /* Expanded State (Hover or Class) */
        /* REMOVED HOVER EXPANSION AS REQUESTED - ONLY CLICK NOW */
        .status-badge.expanded {
            transform: translateX(0);
        }

        /* Colors for the left "Line" and Text */
        .status-badge.red { border-left-color: #f87171; color: #f87171; }
        .status-badge.green { border-left-color: #4ade80; color: #4ade80; }
        .status-badge.blue { border-left-color: #60a5fa; color: #60a5fa; }
        .status-badge.yellow { border-left-color: #facc15; color: #facc15; }

        .btn-round { width: 50px; height: 50px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 1.2rem; transition: all 0.2s; cursor: pointer; }
        .btn-round:active { transform: scale(0.9); }
        .btn-round.active { background: var(--accent-blue); color: white; }
        .btn-round.recording { background: var(--accent-red); animation: pulse 2s infinite; }
        .btn-round.locked { color: var(--accent-red); border-color: var(--accent-red); background: rgba(239, 68, 68, 0.2); }
        
        @keyframes pulse {
            0% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0.7); }
            70% { box-shadow: 0 0 0 10px rgba(239, 68, 68, 0); }
            100% { box-shadow: 0 0 0 0 rgba(239, 68, 68, 0); }
        }

        .overlay { position: fixed; inset: 0; background: rgba(0,0,0,0.7); backdrop-filter: blur(6px); z-index: 9999; display: none; padding: 20px; overflow-y: auto; }
        
        /* RESPONSIVE MODAL CONTENT */
        .modal-content { 
            width: 100%; /* Ensure width is consistent */
            max-width: 1000px; 
            margin: auto; 
            min-height: 85vh; 
            display: flex; 
            flex-direction: column; 
        }
        @media (max-width: 768px) {
            .modal-content {
                width: 100%;
                height: 100%;
                margin: 0;
                min-height: 100vh;
                border-radius: 0;
                border: none;
            }
            .overlay { padding: 0; }
        }

        /* LAYERS MENU */
        #layers-menu { position: absolute; bottom: 90px; left: 10px; width: 220px; z-index: 2000; display: none; flex-direction: column; gap: 1px; }
        .layer-btn { text-align: left; padding: 12px; font-size: 0.85rem; display: flex; justify-content: space-between; align-items: center; color: #cbd5e1; transition: background 0.2s; }
        .layer-btn:hover { background: rgba(255,255,255,0.1); }
        .layer-btn.active { color: var(--accent-blue); background: rgba(59, 130, 246, 0.1); }
        
        /* SELECTION OVERLAY */
        #selection-overlay { position: fixed; inset: 0; z-index: 10001; background: rgba(0,0,0,0.8); display: none; justify-content: center; align-items: center; padding: 20px; backdrop-filter: blur(4px); }
        .selection-box { background: #1e293b; border: 1px solid rgba(255,255,255,0.1); border-radius: 12px; width: 100%; max-width: 400px; max-height: 80vh; display: flex; flex-direction: column; shadow: 0 25px 50px -12px rgba(0, 0, 0, 0.5); }

        /* Form Controls */
        input, select, textarea { background: rgba(30, 41, 59, 0.5) !important; border: 1px solid rgba(255,255,255,0.1) !important; color: white !important; border-radius: 6px; padding: 8px 12px; width: 100%; }
        input[type="color"] { padding: 0; height: 40px; }
        input:focus { border-color: var(--accent-blue) !important; outline: none; }
        label { font-size: 0.75rem; color: #94a3b8; margin-bottom: 4px; display: block; }
        .perf-grid input { padding: 4px; text-align: center; font-size: 0.8rem; }
        
        /* Range Slider Styling */
        input[type=range] { -webkit-appearance: none; width: 100%; background: transparent; }
        input[type=range]::-webkit-slider-thumb { -webkit-appearance: none; height: 16px; width: 16px; border-radius: 50%; background: var(--accent-blue); cursor: pointer; margin-top: -6px; box-shadow: 0 0 5px rgba(0,0,0,0.5); }
        input[type=range]::-webkit-slider-runnable-track { width: 100%; height: 4px; cursor: pointer; background: rgba(255,255,255,0.2); border-radius: 2px; }

        /* KML Item Style */
        .kml-item { background: rgba(30, 41, 59, 0.6); border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 8px 12px; display: flex; justify-content: space-between; align-items: center; margin-bottom: 6px; transition: background 0.2s; }
        .kml-item:hover { background: rgba(30, 41, 59, 0.9); }
        .kml-item.active { border-left: 3px solid var(--accent-green); }

        /* Report Stage Fix for html2canvas */
        #report-stage { 
            background: #0f172a; 
            color: #f8fafc; 
            width: 800px; 
            padding: 30px; 
            position: fixed; 
            left: 0; 
            top: 0; 
            z-index: -5000; 
            visibility: hidden; 
        }

        /* Updated Wind Layer Style */
        .wind-layer {
            background: rgba(0,0,0,0.3);
            border-bottom: 1px solid rgba(255,255,255,0.05);
            transition: all 0.3s;
        }

        /* Added Active Altitude Style */
        .wind-layer.active-altitude {
            background-color: rgba(34, 197, 94, 0.3) !important;
            border-left: 3px solid #22c55e !important;
        }

        /* --- TOAST CONTAINER (Lower right notifications) --- */
        #toast-container {
            position: fixed;
            top: 130px; /* Moved down below status area */
            right: 0;
            z-index: 2001;
            display: flex;
            flex-direction: column;
            gap: 5px;
            pointer-events: none;
            align-items: flex-end;
            padding-right: 0;
        }
        
        .toast-notification {
            pointer-events: auto;
            position: relative;
            background: rgba(15, 23, 42, 0.95);
            backdrop-filter: blur(8px);
            border-left: 4px solid;
            padding: 12px 16px;
            padding-right: 32px;
            border-radius: 8px 0 0 8px;
            box-shadow: -4px 4px 12px rgba(0,0,0,0.5);
            color: white;
            font-size: 0.85rem;
            display: flex;
            align-items: center;
            gap: 8px;
            transition: transform 0.4s cubic-bezier(0.175, 0.885, 0.32, 1.275);
            transform: translateX(100%); 
            margin-right: 0;
            min-width: 200px;
            max-width: 300px;
            cursor: pointer;
        }

        .toast-notification.show { transform: translateX(0); }
        .toast-notification.collapsed { transform: translateX(calc(100% - 8px)); }
        .toast-notification.collapsed:hover { transform: translateX(0); }

        .toast-close {
            position: absolute;
            top: 50%;
            right: 8px;
            transform: translateY(-50%);
            color: #64748b;
            padding: 4px;
            cursor: pointer;
            border: none;
            background: transparent;
            font-size: 1.2rem;
            line-height: 1;
        }
        .toast-close:hover { color: white; }
        
        .toast-notification.success { border-color: #22c55e; }
        .toast-notification.error { border-color: #ef4444; }
        .toast-notification.info { border-color: #3b82f6; }

        /* Loader inside AI Nav */
        .ai-pulse {
            display: inline-block;
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background-color: currentColor;
            animation: ai-pulse 1.5s infinite;
            flex-shrink: 0;
        }
        @keyframes ai-pulse {
            0% { transform: scale(0.8); opacity: 0.5; box-shadow: 0 0 0 0 rgba(255,255,255, 0.4); }
            50% { transform: scale(1.1); opacity: 1; box-shadow: 0 0 0 5px rgba(255,255,255, 0); }
            100% { transform: scale(0.8); opacity: 0.5; box-shadow: 0 0 0 0 rgba(255,255,255, 0); }
        }

        /* CPA Marker Pulse */
        .cpa-marker-pulse {
            background-color: #a855f7;
            border: 2px solid white;
            border-radius: 50%;
            box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7);
            animation: cpaPulse 1.5s infinite;
        }
        
        @keyframes cpaPulse {
            0% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(168, 85, 247, 0.7); }
            70% { transform: scale(1); box-shadow: 0 0 0 10px rgba(168, 85, 247, 0); }
            100% { transform: scale(0.95); box-shadow: 0 0 0 0 rgba(168, 85, 247, 0); }
        }

    </style>
</head>
<body>

    <div id="map"></div>
    
    <!-- Layers Menu Popover -->
    <div id="layers-menu" class="glass-panel overflow-hidden">
        <!-- Content injected by JS -->
    </div>
    
    <!-- Fullscreen Loading Overlay for Report Gen -->
    <div id="loading-overlay" class="fixed inset-0 z-[6000] bg-slate-900/95 flex flex-col items-center justify-center hidden backdrop-blur-sm">
        <div class="loader mb-4" style="width: 40px; height: 40px; border-width: 4px;"></div>
        <div class="text-white font-bold text-lg">Erstelle Bericht...</div>
        <div class="text-slate-400 text-sm">Bitte warten, Karte wird gerendert</div>
    </div>
    
    <!-- Photo View Overlay -->
    <div id="photo-overlay" onclick="this.style.display='none'">
        <img id="photo-overlay-img" src="">
    </div>
    
    <!-- SELECTION OVERLAY -->
    <div id="selection-overlay">
        <div class="selection-box">
            <div class="p-4 border-b border-white/10 flex justify-between items-center bg-slate-900/50 rounded-t-xl">
                <h3 id="sel-title" class="font-bold text-white">Auswahl</h3>
                <button onclick="document.getElementById('selection-overlay').style.display='none'" class="text-slate-400 hover:text-white px-2"><i class="fas fa-times"></i></button>
            </div>
            <div id="sel-content" class="overflow-y-auto p-2 flex-1 space-y-1 max-h-[60vh]">
                <!-- Items injected here -->
            </div>
        </div>
    </div>
    
    <!-- MANUAL WIND INPUT OVERLAY -->
    <div id="manual-wind-overlay" class="hidden fixed inset-0 z-[5000] bg-black/80 flex justify-center items-center backdrop-blur-sm p-4">
        <div class="glass-panel w-full max-w-sm p-6 border border-white/20">
            <h3 class="text-xl font-bold mb-4 flex items-center gap-2"><i class="fas fa-headset text-amber-400"></i> Funk-Winddaten erfassen</h3>
            <div class="space-y-4">
                <div>
                    <label class="text-xs uppercase text-slate-400 mb-1">Höhe (m)</label>
                    <input type="number" id="manual-wind-alt" class="w-full bg-slate-800 border-slate-600 rounded p-3 text-lg font-bold text-white" placeholder="z.B. 1200">
                </div>
                <div class="grid grid-cols-2 gap-4">
                     <div>
                        <label class="text-xs uppercase text-slate-400 mb-1">Fahrtrichtung (Track °)</label>
                        <input type="number" id="manual-wind-dir" class="w-full bg-slate-800 border-slate-600 rounded p-3 text-lg font-bold text-white" placeholder="0-360">
                        <div class="text-[9px] text-slate-500 mt-1">Wohin fährt der andere Ballon?</div>
                    </div>
                     <div>
                        <label class="text-xs uppercase text-slate-400 mb-1">Geschw. (km/h)</label>
                        <input type="number" id="manual-wind-spd" class="w-full bg-slate-800 border-slate-600 rounded p-3 text-lg font-bold text-white" placeholder="km/h">
                    </div>
                </div>
                <div class="flex gap-3 mt-6">
                    <button onclick="ui.toggleManualWindModal(false)" class="flex-1 bg-slate-700 hover:bg-slate-600 text-white py-3 rounded-lg font-bold">Abbrechen</button>
                    <button onclick="ui.saveManualWind()" class="flex-1 bg-amber-600 hover:bg-amber-500 text-white py-3 rounded-lg font-bold">Speichern</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Hidden Inputs -->
    <input type="file" id="cam-input" accept="image/*" capture="environment" class="hidden" onchange="flightManager.handlePhotoInput(this)">
    <input type="file" id="import-input" accept=".json" class="hidden">
    <input type="file" id="balloon-import-input" accept=".json" class="hidden" onchange="ui.handleBalloonImport(this)">
    <input type="file" id="kml-import-input" accept=".kml" class="hidden" onchange="mapManager.handleKmlImport(this)">

    <!-- HUD TOP CONTAINER -->
    <div id="hud-top-container" class="hud-top-container hud-container-anim">
         <!-- Collapse Button: Links -->
        <div id="btn-top-toggle-wrapper">
            <button onclick="ui.toggleTopHUD()" class="bg-slate-800 text-slate-400 hover:text-white rounded-full w-8 h-8 flex items-center justify-center text-xs shadow border border-white/20" title="Ein/Ausblenden">
                <i class="fas fa-chevron-left transition-transform duration-300" id="icon-top-hud-toggle"></i>
            </button>
        </div>

        <div id="hud-top" class="hud-top glass-panel">
            <div class="hud-value">
                <div class="hud-label">Höhe <small id="lbl-alt">m</small></div>
                <div class="hud-num"><span id="hud-alt">0</span></div>
            </div>
            <div class="hud-value">
                <div class="hud-label">Vario <small id="lbl-vario">m/s</small></div>
                <div class="hud-num"><span id="hud-vario">0.0</span></div>
            </div>
            <div class="hud-value">
                <div class="hud-label">Speed <small id="lbl-speed">km/h</small></div>
                <div class="hud-num"><span id="hud-speed">0.0</span></div>
            </div>
            <div class="hud-value">
                <div class="hud-label">Kurs</div>
                <div class="hud-num"><span id="hud-course">360</span>°</div>
            </div>
             <!-- NEW: Time Display -->
            <div class="hud-value">
                <div class="hud-label">Zeit</div>
                <div class="hud-num" id="hud-time">--:--</div>
            </div>
        </div>
    </div>

    <!-- STATUS AREA (COLLAPSIBLE SIDE BADGES) -->
    <!-- Click Only Expansion -->
    <div class="status-area">
        <div id="sb-rec" class="status-badge red hidden" onclick="this.classList.toggle('expanded')">
             <i class="fas fa-circle text-[8px]"></i> <span>REC</span>
        </div>
        <div id="sb-gps" class="status-badge blue" onclick="this.classList.toggle('expanded')">
             <i class="fas fa-satellite-dish text-[10px]"></i> <span id="sb-gps-text">NO GPS</span>
        </div>
        <div id="sb-baro" class="status-badge green hidden" onclick="this.classList.toggle('expanded')">
             <i class="fas fa-tachometer-alt text-[10px]"></i> <span>BARO ON</span>
        </div>
        <div id="sb-screen" class="status-badge yellow hidden" onclick="this.classList.toggle('expanded')">
             <i class="fas fa-sun text-[10px]"></i> <span>SCREEN ON</span>
        </div>
        <div id="sb-net" class="status-badge green" onclick="this.classList.toggle('expanded')">
             <i class="fas fa-wifi text-[10px]"></i> <span id="sb-net-text">ONLINE</span>
        </div>
    </div>

    <!-- HUD NAVIGATION CONTAINER -->
    <div id="hud-nav-container" class="hud-nav-container hidden hud-container-anim">
        <!-- Collapse Button: Links -->
        <div id="btn-nav-toggle-wrapper">
            <button onclick="ui.toggleNavHUD()" class="bg-slate-800 text-slate-400 hover:text-white rounded-full w-8 h-8 flex items-center justify-center text-xs shadow border border-white/20" title="Ein/Ausblenden">
                <i class="fas fa-chevron-left transition-transform duration-300" id="icon-nav-hud-toggle"></i>
            </button>
        </div>

        <div id="hud-nav" class="hud-nav glass-panel">
            <div class="hud-value">
                <div class="hud-label">Distanz <small id="lbl-nav-dist">km</small></div>
                <div class="hud-num"><span id="nav-dist">0.0</span></div>
            </div>
            
            <!-- NEW CPA COLUMN WITH TIME -->
            <div class="hud-value">
                <div class="hud-label" id="lbl-cpa">CPA <small>min</small></div>
                <div class="hud-num" style="line-height: 1;">
                    <span id="hud-cpa">--</span>
                    <div id="hud-cpa-time" style="font-size: 0.8rem; color: #a855f7; font-weight: normal; margin-top: -2px;"></div>
                </div>
            </div>

            <div class="hud-value">
                <div class="hud-label">Peilung</div>
                <div class="hud-num"><span id="nav-brg">0</span>°</div>
            </div>
            <div class="hud-value">
                <div class="hud-label">ETE</div>
                <div class="hud-num" id="nav-ete">--:--</div>
            </div>
            
            <!-- AI Button (Blue) -->
            <button onclick="aiService.toggleAutoNav()" id="btn-ai-nav" class="absolute -right-2 top-8 bg-blue-600 text-white rounded-full w-8 h-8 flex items-center justify-center text-xs shadow border border-white/20 hidden" title="Auto-Navi (KI)"><i class="fas fa-magic"></i></button>
            
            <!-- Local Nav Button (Amber) - Moved to left to avoid Wind Panel overlap -->
            <button onclick="localNavService.toggleLocalNav()" id="btn-local-nav" class="absolute -left-3 top-[68px] bg-amber-600 text-white rounded-full w-8 h-8 flex items-center justify-center text-xs shadow border border-white/20" title="Local Navi (Calc)"><i class="fas fa-calculator"></i></button>

            <button onclick="ui.clearTarget()" class="absolute -right-2 -top-2 bg-slate-800 text-slate-400 hover:text-white rounded-full w-6 h-6 flex items-center justify-center text-xs shadow border border-white/20"><i class="fas fa-times"></i></button>
        </div>
    </div>
    
    <!-- NEW: Car Style Instruction Bar (Bottom) -->
    <div id="nav-instruction-bar" class="mode-ai">
        <span class="ai-pulse"></span>
        <span id="nav-instruction-text">Berechne...</span>
    </div>

    <!-- TOAST CONTAINER IN BODY FOR CSS TARGETING -->
    <div id="toast-container"></div>

    <!-- SIDEBAR LEFT -->
    <div class="sidebar-left">
        <button id="btn-center" class="btn-round glass-panel" title="Zentrieren / Lock">
            <i class="fas fa-crosshairs"></i>
        </button>
        <button id="btn-record" class="btn-round glass-panel" title="Aufnahme (Lang drücken zum Stoppen)">
            <i class="fas fa-circle"></i>
        </button>
        
        <!-- PHOTO BUTTON -->
        <button id="btn-take-photo" class="hidden btn-round glass-panel text-white bg-blue-600 hover:bg-blue-500" title="Foto machen" onclick="flightManager.takePhoto()">
            <i class="fas fa-camera"></i>
        </button>
        
        <button id="btn-waypoint-lock" class="btn-round glass-panel text-slate-400" title="Wegpunkt sperren" onclick="ui.toggleWaypointLock()">
            <i class="fas fa-lock-open" id="icon-wp-lock"></i>
        </button>
        <button id="btn-layers" class="btn-round glass-panel" title="Ebenen">
            <i class="fas fa-layer-group"></i>
        </button>
        <div class="mt-4 flex flex-col gap-2">
            <button id="btn-settings" class="btn-round glass-panel bg-slate-800" title="Menü">
                <i class="fas fa-bars"></i>
            </button>
        </div>
    </div>

    <!-- SIDEBAR RIGHT (Wind) -->
    <div id="sidebar-right-container" class="sidebar-right-container">
        <!-- Collapse Button attached to panel -->
        <div id="btn-wind-toggle-wrapper" class="absolute -left-10 top-0">
             <button onclick="ui.toggleWindPanel()" class="bg-slate-800 text-slate-400 hover:text-white rounded-full w-8 h-8 flex items-center justify-center text-xs shadow border border-white/20" title="Wind">
                <i class="fas fa-chevron-right transition-transform duration-300" id="icon-wind-toggle"></i>
            </button>
        </div>

        <div id="wind-panel" class="glass-panel">
            <!-- Header with merged Live Button -->
            <div class="p-2 border-b border-white/10 flex justify-between items-center px-3 gap-2">
                 <i class="fas fa-wind text-blue-400"></i>
                 <div class="flex gap-2">
                    <button onclick="ui.toggleManualWindModal(true)" class="text-amber-400 hover:text-white" title="Manuelle Eingabe"><i class="fas fa-plus-circle"></i></button>
                    <button onclick="event.stopPropagation(); weatherService.fetchLiveWind()" class="text-[0.65rem] text-green-400 hover:text-white flex flex-col items-center leading-none" title="Live Update">
                        <i class="fas fa-sync-alt mb-0.5"></i>Live
                    </button>
                 </div>
            </div>
            
            <div id="wind-content-wrapper" class="overflow-hidden transition-all duration-300 w-[110px]">
                <div id="wind-layers-container" class="p-2 flex flex-col gap-1 max-h-60 overflow-y-auto scrollbar-hide">
                    <!-- Layers will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <!-- SIMULATION PANEL -->
    <div id="sim-panel" class="absolute bottom-8 left-1/2 -translate-x-1/2 z-[2000] hidden glass-panel px-6 py-3 flex items-center gap-4 border border-white/10 shadow-2xl">
        <div class="flex gap-3">
            <button onclick="simulation.setTargetVario(-4)" class="bg-red-600/90 hover:bg-red-500 text-white px-4 py-2 rounded-lg font-bold shadow-lg transition transform active:scale-95 text-sm flex items-center gap-2">
                <i class="fas fa-arrow-down"></i> Sinken
            </button>
            <button onclick="simulation.setTargetVario(0)" class="bg-slate-600/90 hover:bg-slate-500 text-white px-4 py-2 rounded-lg font-bold shadow-lg transition transform active:scale-95 text-sm flex items-center gap-2">
                <i class="fas fa-minus"></i> Halt
            </button>
            <button onclick="simulation.setTargetVario(4)" class="bg-blue-600/90 hover:bg-blue-500 text-white px-4 py-2 rounded-lg font-bold shadow-lg transition transform active:scale-95 text-sm flex items-center gap-2">
                <i class="fas fa-arrow-up"></i> Steigen
            </button>
        </div>
    </div>

    <!-- MAIN MODAL -->
    <div id="main-modal" class="overlay">
        <div class="modal-content glass-panel p-0 md:p-6">
            <div class="flex justify-between items-center mb-4 p-4 md:p-0">
                <h2 class="text-2xl font-bold flex items-center gap-2">BallonNav Control <span class="text-xs text-slate-500 font-normal ml-2">designed by CD</span></h2>
                <button onclick="ui.closeModal()" class="text-3xl opacity-50 hover:opacity-100">&times;</button>
            </div>
            
            <!-- Desktop Tabs -->
            <div class="hidden md:flex border-b border-white/10 mb-4 gap-4">
                <button class="tab-btn active" onclick="ui.switchTab('planning')">Planung</button>
                <button class="tab-btn" onclick="ui.switchTab('fleet')">Flotte</button>
                <button class="tab-btn" onclick="ui.switchTab('cylinders')">Gasflaschen</button>
                <button class="tab-btn" onclick="ui.switchTab('passengers')">Passagiere</button>
                <button class="tab-btn" onclick="ui.switchTab('logbook')">Logbuch</button>
                <button class="tab-btn" onclick="ui.switchTab('environment')">Wind</button>
                <button class="tab-btn" onclick="ui.switchTab('settings')">Einstellungen</button>
            </div>

            <!-- Mobile Dropdown -->
            <div class="md:hidden px-4 mb-4">
                <select id="mobile-tab-select" onchange="ui.switchTab(this.value)" class="w-full bg-slate-800 border border-white/20 rounded-lg p-3 text-white font-bold focus:outline-none focus:border-blue-500">
                    <option value="planning">Planung</option>
                    <option value="fleet">Flotte</option>
                    <option value="cylinders">Gasflaschen</option>
                    <option value="passengers">Passagiere</option>
                    <option value="logbook">Logbuch</option>
                    <option value="environment">Wind</option>
                    <option value="settings">Einstellungen</option>
                </select>
            </div>

            <div id="tab-content" class="flex-grow overflow-y-auto pr-2 p-4 md:p-0"></div>
        </div>
    </div>

    <!-- OFF-SCREEN REPORT GENERATOR STAGE -->
    <div id="report-stage"></div>

    <script>
        /**
         * STATE & CONSTANTS
         */
        const STORAGE_KEY = "AERONAV_PRO_DATA_V9"; // Version bumped for new settings
        const DEFAULT_BALLOON_IMG = "data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Cpath d='M50,95 C20,70 5,45 5,35 A45,45 0 0,1 95,35 C95,45 80,70 50,95 Z' fill='%234c1d95' stroke='white' stroke-width='1'/%3E%3Cpath d='M65,30 Q80,50 65,70 Q55,50 65,30' fill='%23fbbf24'/%3E%3Ctext x='25' y='30' fill='%23fbbf24' font-size='10'%3E★%3C/text%3E%3Ctext x='35' y='50' fill='%23fbbf24' font-size='8'%3E★%3C/text%3E%3Ctext x='20' y='60' fill='%23fbbf24' font-size='12'%3E★%3C/text%3E%3Ctext x='80' y='35' fill='%23fbbf24' font-size='9'%3E★%3C/text%3E%3C/svg%3E";
        
        let state = JSON.parse(localStorage.getItem(STORAGE_KEY)) || {
            pilot: { name: "Max Mustermann", weight: 85, initialFlights: 0, initialHours: 0 }, 
            balloons: [],
            cylinders: [],
            passengers: [],
            logs: [],
            plannings: [], 
            archive: [], 
            kmlOverlays: [], 
            windLayers: [
                { alt: 0, dir: 270, speed: 5 },
                { alt: 500, dir: 285, speed: 12 },
                { alt: 1000, dir: 300, speed: 18 },
                { alt: 2000, dir: 330, speed: 25 }
            ],
            measuredWindLayers: [],
            targetWaypoint: null,
            waypointLocked: false,
            settings: { 
                apiKey: "", 
                unitAlt: 'm', 
                unitSpeed: 'kmh', 
                unitVario: 'ms',
                trackColor: '#3b82f6',
                trackWidth: 4,
                navLineColor: '#eab308', // Added
                mapStyle: 'dark',
                mode: 'sim', 
                activeBalloonId: null,
                windThreshold: 5,            
                windMeasInterval: 50,        
                windMeasurementMinDeviation: 5, 
                imageRetention: 30,
                baptismMaxWords: 15,
                aiMaxWords: 10,
                useUTC: false,
                mapOffset: 0.25,
                showPathPrediction: false,
                pathPredictionMinutes: 5,
                navMode: 'direct',
                toastTimeout: 60 
            }
        };

        // Migration logic
        if(!state.settings.unitVario) state.settings.unitVario = 'ms';
        if(!state.settings.trackColor) state.settings.trackColor = '#3b82f6';
        if(!state.settings.navLineColor) state.settings.navLineColor = '#eab308'; // Default Yellow
        if(!state.settings.trackWidth) state.settings.trackWidth = 4;
        if(!state.settings.mapStyle) state.settings.mapStyle = 'dark';
        if(!state.settings.mode) state.settings.mode = 'sim';
        if(!state.measuredWindLayers) state.measuredWindLayers = [];
        if(state.settings.activeBalloonId === undefined) state.settings.activeBalloonId = null;
        if(!state.plannings) state.plannings = [];
        if(!state.archive) state.archive = [];
        if(!state.kmlOverlays) state.kmlOverlays = [];
        if(state.settings.mapOffset === undefined) state.settings.mapOffset = 0.25;
        if(state.settings.windMeasInterval === undefined) state.settings.windMeasInterval = 50;
        if(state.settings.windMeasurementMinDeviation === undefined) state.settings.windMeasurementMinDeviation = 5;
        if(state.settings.showPathPrediction === undefined) state.settings.showPathPrediction = false;
        if(state.settings.pathPredictionMinutes === undefined) state.settings.pathPredictionMinutes = 5;
        if(state.settings.navMode === undefined) state.settings.navMode = 'direct';
        if(state.settings.aiMaxWords === undefined) state.settings.aiMaxWords = 10;
        if(state.settings.toastTimeout === undefined) state.settings.toastTimeout = 60; 

        // Ensure archived property exists on balloons
        if (state.balloons) {
            state.balloons.forEach(b => {
                if (b.archived === undefined) b.archived = false;
                if (!b.matrix) b.matrix = [[0.3,0.28,0.26], [0.28,0.26,0.24], [0.26,0.24,0.22], [0.24,0.22,0.20]];
            });
        }

        function saveState() {
            try {
                localStorage.setItem(STORAGE_KEY, JSON.stringify(state));
            } catch (e) {
                if (ui && ui.showToast) ui.showToast("Speicher voll! Evtl. KML zu groß.", "error");
                console.error("Storage failed", e);
            }
        }
        
        // --- SYSTEM OBJECT (BACKUP & RESTORE) ---
        const system = {
            exportData() {
                const dataStr = JSON.stringify(state);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const exportFileDefaultName = 'BallonNav_Backup_' + new Date().toISOString().slice(0,10) + '.json';
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                ui.showToast("Backup Datei erstellt", "success");
            },
            triggerImport() {
                document.getElementById('import-input').click();
            },
            importData(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const importedState = JSON.parse(e.target.result);
                            // Basic validation: Check if essential properties exist
                            if (importedState.pilot && importedState.settings && Array.isArray(importedState.balloons)) {
                                if(confirm("ACHTUNG: Dies überschreibt alle aktuellen Daten mit dem Backup. Fortfahren?")) {
                                    state = importedState;
                                    saveState();
                                    ui.showToast("Backup erfolgreich wiederhergestellt!", "success");
                                    setTimeout(() => location.reload(), 1500);
                                }
                            } else {
                                throw new Error("Ungültiges Backup-Format (fehlende Schlüssel)");
                            }
                        } catch (err) {
                            ui.showToast("Fehler beim Import: " + err.message, "error");
                        }
                        input.value = '';
                    };
                    reader.readAsText(input.files[0]);
                }
            },
            resetData() {
                if(confirm("ACHTUNG: Alle Daten (Logbuch, Flotte, Einstellungen) werden unwiderruflich gelöscht! App wird auf Werkseinstellungen zurückgesetzt. Fortfahren?")) {
                    localStorage.removeItem(STORAGE_KEY);
                    location.reload();
                }
            }
        };

        // --- MATH HELPERS ---
        function toRad(deg) { return deg * Math.PI / 180; }
        function toDeg(rad) { return rad * 180 / Math.PI; }
        function getDistance(lat1, lon1, lat2, lon2) {
            const R = 6371; 
            const dLat = toRad(lat2 - lat1);
            const dLon = toRad(lon2 - lon1);
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        function getBearing(lat1, lon1, lat2, lon2) {
            const y = Math.sin(toRad(lon2 - lon1)) * Math.cos(toRad(lat2));
            const x = Math.cos(toRad(lat1)) * Math.sin(toRad(lat2)) - Math.sin(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.cos(toRad(lon2 - lon1));
            const brg = toDeg(Math.atan2(y, x));
            return (brg + 360) % 360;
        }
        
        function calculateDestination(lat, lon, brg, distKm) {
            const R = 6371;
            const lat1 = toRad(lat);
            const lon1 = toRad(lon);
            const brgRad = toRad(brg);
            
            const lat2 = Math.asin( Math.sin(lat1)*Math.cos(distKm/R) + Math.cos(lat1)*Math.sin(distKm/R)*Math.cos(brgRad) );
            const lon2 = lon1 + Math.atan2(Math.sin(brgRad)*Math.sin(distKm/R)*Math.cos(lat1), Math.cos(distKm/R)-Math.sin(lat1)*Math.sin(lat2));
            
            return { lat: toDeg(lat2), lng: toDeg(lon2) };
        }

        // --- NEW: Calculate CPA (Closest Point of Approach) ---
        function calculateCPA(lat, lng, course, targetLat, targetLng) {
            // Distance and Bearing to Target
            const dist = getDistance(lat, lng, targetLat, targetLng);
            const bearingToTarget = getBearing(lat, lng, targetLat, targetLng);
            
            // Relative Angle (Alpha)
            let relAngle = (bearingToTarget - course + 360) % 360;
            if (relAngle > 180) relAngle -= 360; // Normalize to -180 to +180

            // Trigonometry for "Right Triangle"
            const alphaRad = toRad(Math.abs(relAngle));
            
            // Distance along track to reach the perpendicular point (Lotheilpunkt)
            const distAlongTrack = dist * Math.cos(alphaRad);
            
            // Minimum distance (Perpendicular distance)
            const minMissDist = dist * Math.sin(alphaRad);
            
            // CPA Coordinate
            // If angle is > 90, CPA is behind us (negative distAlongTrack)
            let cpaCoord = null;
            if (Math.abs(relAngle) < 90) {
                 cpaCoord = calculateDestination(lat, lng, course, distAlongTrack);
            } else {
                 // Passed CPA
                 cpaCoord = calculateDestination(lat, lng, course + 180, Math.abs(distAlongTrack));
            }

            return {
                distAlongTrack: distAlongTrack, // Positive = Ahead, Negative = Behind
                missDistance: Math.abs(minMissDist),
                coords: cpaCoord
            };
        }

        /**
         * WAKE LOCK MANAGER
         */
        const wakeLockManager = {
            wakeLock: null,
            isSupported() { return 'wakeLock' in navigator; },
            async request() {
                if (!this.isSupported()) return;
                try {
                    this.wakeLock = await navigator.wakeLock.request('screen');
                    document.getElementById('sb-screen').classList.remove('hidden'); 
                    this.wakeLock.addEventListener('release', () => {
                        document.getElementById('sb-screen').classList.add('hidden'); 
                    });
                } catch (err) { 
                    console.warn(`Screen Wake Lock ignored: ${err.name}, ${err.message}`);
                }
            },
            release() {
                if (this.wakeLock !== null) {
                    this.wakeLock.release().then(() => { this.wakeLock = null; });
                }
            },
            handleVisibilityChange() {
                if (this.wakeLock !== null && document.visibilityState === 'visible') { this.request(); }
            }
        };

        /**
         * BAROMETER SERVICE (Experimental)
         */
        const barometerService = {
            sensor: null,
            isAvailable: false,
            lastPressure: null,
            lastTime: null,
            vario: 0,
            
            init() {
                if ('Barometer' in window) {
                    try {
                        this.sensor = new Barometer({ frequency: 10 }); // High frequency for Vario
                        this.sensor.addEventListener('reading', () => this.handleReading());
                        this.sensor.addEventListener('error', (e) => {
                            console.warn("Barometer error", e);
                        });
                        this.sensor.start();
                        this.isAvailable = true;
                        
                        const b = document.getElementById('sb-baro');
                        if(b) b.classList.remove('hidden');
                        
                    } catch (err) {
                        console.log("Barometer not supported/allowed", err);
                    }
                }
            },
            
            handleReading() {
                const now = Date.now();
                const pressure = this.sensor.pressure; // hPa
                
                if (this.lastPressure && this.lastTime) {
                    const dt = (now - this.lastTime) / 1000;
                    if (dt > 0) {
                        const alt1 = 44330 * (1 - Math.pow(this.lastPressure/1013.25, 0.1903));
                        const alt2 = 44330 * (1 - Math.pow(pressure/1013.25, 0.1903));
                        const instantVario = (alt2 - alt1) / dt;
                        this.vario = (this.vario * 0.8) + (instantVario * 0.2);
                    }
                }
                this.lastPressure = pressure;
                this.lastTime = now;
            }
        };

        /**
         * LOCAL NAV SERVICE (Algorithm-based)
         */
        const localNavService = {
            interval: null,
            isActive: false,
            settings: {
                climbRate: 2.0, // m/s, assumed vertical speed for transit
                maxDataAgeMin: 120 // Increased to 2 hours to keep manual data longer
            },

            toggleLocalNav() {
                if(this.isActive) this.stopLocalNav();
                else this.startLocalNav();
            },

            startLocalNav() {
                if (!state.targetWaypoint) { ui.showToast("Kein Ziel!", "error"); return; }
                
                // Ensure AI Nav is off
                if(aiService.isAutoNavActive) aiService.stopAutoNav();

                this.isActive = true;
                const btn = document.getElementById('btn-local-nav');
                if(btn) { btn.classList.add('text-amber-400'); btn.classList.add('animate-pulse'); }
                
                // UI Setup
                const bar = document.getElementById('nav-instruction-bar');
                bar.className = 'mode-local visible'; // Switch to local style (Amber)
                
                this.update(); // Initial run
                
                // Interval loop
                this.interval = setInterval(() => this.update(), 2000); // Faster updates (2s instead of 5s)
            },

            stopLocalNav() {
                this.isActive = false;
                if(this.interval) clearInterval(this.interval);
                
                const btn = document.getElementById('btn-local-nav');
                if(btn) { btn.classList.remove('text-amber-400'); btn.classList.remove('animate-pulse'); }
                
                document.getElementById('nav-instruction-bar').classList.remove('visible');
            },

            cleanupOldData() {
                const threshold = Date.now() - (this.settings.maxDataAgeMin * 60 * 1000);
                // Filter measured layers
                if(state.measuredWindLayers) {
                    state.measuredWindLayers = state.measuredWindLayers.filter(l => l.timestamp && l.timestamp >= threshold);
                }
            },

            calculateBestLayer() {
                const target = state.targetWaypoint;
                if (!target) return null;
                
                const currentPos = simulation.getCurrentState(); // {lat, lng, alt, speed (knots), course}
                
                // Use combined layers (from Simulation helper) to ensure manual winds are included
                let layersToScan = simulation.getCombinedLayers();

                // If absolutely no layers, return null
                if(!layersToScan || layersToScan.length === 0) return null;

                const candidates = [];
                const KNOTS_TO_MS = 0.514444;

                layersToScan.forEach(layer => {
                    // 1. Transit Calculation (Time & Drift to get to layer altitude)
                    const deltaAlt = Math.abs(layer.alt - currentPos.alt);
                    const t_transit = deltaAlt / this.settings.climbRate; // seconds
                    
                    // Assume drift speed/dir is average of current state and target layer
                    const currentSpeedMs = currentPos.speed * KNOTS_TO_MS;
                    const layerSpeedMs = layer.speed * KNOTS_TO_MS;
                    const avgSpeedMs = (currentSpeedMs + layerSpeedMs) / 2;
                    
                    // Drift distance (Simplified: assumes straight drift during climb)
                    const driftDistM = avgSpeedMs * t_transit;
                    
                    // Calculate New Position after drift
                    const R = 6371e3; 
                    const radBrg = toRad(currentPos.course);
                    const lat1 = toRad(currentPos.lat);
                    const lon1 = toRad(currentPos.lng);
                    
                    const lat2 = Math.asin( Math.sin(lat1)*Math.cos(driftDistM/R) + Math.cos(lat1)*Math.sin(driftDistM/R)*Math.cos(radBrg) );
                    const lon2 = lon1 + Math.atan2(Math.sin(radBrg)*Math.sin(driftDistM/R)*Math.cos(lat1), Math.cos(driftDistM/R)-Math.sin(lat1)*Math.sin(lat2));
                    
                    const startLat = toDeg(lat2);
                    const startLng = toDeg(lon2);
                    
                    // 2. VMG Calculation from new start point
                    const distToTargetM = getDistance(startLat, startLng, target.lat, target.lng) * 1000;
                    const bearingToTarget = getBearing(startLat, startLng, target.lat, target.lng);
                    
                    // Convert wind direction (FROM) to movement direction (TO)
                    const movementDir = (layer.dir + 180) % 360;
                    
                    const movementDirRad = toRad(movementDir);
                    const targetBrgRad = toRad(bearingToTarget);
                    
                    // VMG = Velocity Made Good towards target
                    const vmg = layerSpeedMs * Math.cos(movementDirRad - targetBrgRad);
                    
                    // Calculate Time to Target (if VMG > 0) or "Time to infinite loss" (score)
                    let totalTime = Infinity;
                    
                    if (vmg > 0.1) { 
                         const t_travel = distToTargetM / vmg; 
                         totalTime = t_transit + t_travel;
                    }

                    candidates.push({
                        layer: layer,
                        vmg: vmg,
                        totalTime: totalTime,
                        transitTime: t_transit,
                        distM: distToTargetM,
                        bearingToTarget: bearingToTarget,
                        movementDir: movementDir
                    });
                });
                
                // Sort candidates:
                // Primary: Positive VMG is better than Negative VMG
                // Secondary: If both Positive, lower Total Time is better
                // Secondary: If both Negative, higher VMG (closer to 0) is better (least drift away)
                
                candidates.sort((a,b) => {
                    if (a.vmg > 0 && b.vmg <= 0) return -1; // a wins
                    if (a.vmg <= 0 && b.vmg > 0) return 1;  // b wins
                    
                    if (a.vmg > 0 && b.vmg > 0) {
                        return a.totalTime - b.totalTime; // Fastest wins
                    } else {
                        return b.vmg - a.vmg; // Least negative wins (closest to 0)
                    }
                });
                
                return candidates[0]; // Return the best candidate
            },

            update() {
                if(!state.targetWaypoint) { this.stopLocalNav(); return; }
                
                this.cleanupOldData();
                const best = this.calculateBestLayer();
                const textEl = document.getElementById('nav-instruction-text');
                
                if (!best) {
                    textEl.innerText = "Keine Winddaten verfügbar";
                    return;
                }
                
                const currentAlt = simulation.alt;
                const targetAlt = best.layer.alt;
                const diff = targetAlt - currentAlt;
                
                // Calculate arrow for visual aid relative to current movement
                let dirArrow = '';
                if (best.movementDir !== undefined) {
                     // Simple arrow logic could go here if UI supports it
                }

                // If the best option still moves away (VMG <= 0)
                if (best.vmg <= 0) {
                     // Find relative bearing to show "Gegenwind" context
                     let bearingDiff = Math.abs(best.movementDir - best.bearingToTarget);
                     if(bearingDiff > 180) bearingDiff = 360 - bearingDiff;
                     
                     textEl.innerHTML = `<span class="text-red-400"><i class="fas fa-exclamation-triangle"></i> Ziel nicht direkt erreichbar</span>`;
                     // Still suggest the best altitude to minimize loss
                     if (Math.abs(diff) > 10) {
                         const action = diff > 0 ? "Steigen" : "Sinken";
                         textEl.innerHTML += ` <span class="text-sm">(${action} auf ${targetAlt}m für min. Abdrift)</span>`;
                     }
                     return;
                }
                
                // Normal Navigation
                let action = "Höhe halten";
                let icon = '<i class="fas fa-check-circle text-green-500"></i>';
                
                // Tolerance reduced to 10m (was 50m) for precision
                if (diff > 10) {
                    action = `Steigen auf ${targetAlt}m`;
                    icon = '<i class="fas fa-arrow-up text-blue-400 animate-bounce"></i>';
                }
                else if (diff < -10) {
                    action = `Sinken auf ${targetAlt}m`;
                    icon = '<i class="fas fa-arrow-down text-blue-400 animate-bounce"></i>';
                }
                
                const etaMin = Math.round(best.totalTime / 60);
                
                textEl.innerHTML = `${icon} ${action} <span class="text-slate-400 text-sm ml-2">(ETA: ${etaMin} min)</span>`;
            }
        };

        /**
         * AI SERVICE (GEMINI)
         */
        const aiService = {
            autoNavInterval: null,
            isAutoNavActive: false,
            lastCheckDir: null, // Track wind direction for auto-update

            // Helper to call API
            async callGemini(prompt, outputJson = false) {
                const apiKey = state.settings.apiKey;
                if (!apiKey) throw new Error("API Key fehlt");

                const url = `https://generativelanguage.googleapis.com/v1beta/models/gemini-2.5-flash-preview-09-2025:generateContent?key=${apiKey}`;
                const payload = {
                    contents: [{ parts: [{ text: prompt }] }]
                };
                
                if (outputJson) {
                    payload.generationConfig = { responseMimeType: "application/json" };
                }

                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(payload)
                });

                if (!response.ok) throw new Error("API Fehler: " + response.status);
                const data = await response.json();
                return data.candidates?.[0]?.content?.parts?.[0]?.text || "";
            },

            toggleAutoNav() {
                if(this.isAutoNavActive) this.stopAutoNav();
                else this.startAutoNav();
            },

            startAutoNav() {
                if (!state.settings.apiKey) { ui.showToast("Kein API Key!", "error"); return; }
                if (!state.targetWaypoint) { ui.showToast("Kein Ziel!", "error"); return; }
                
                // Stop Local Nav if active
                if(localNavService.isActive) localNavService.stopLocalNav();

                this.isAutoNavActive = true;
                const btn = document.getElementById('btn-ai-nav');
                if(btn) { btn.classList.add('text-green-400'); btn.classList.add('animate-pulse'); }
                
                // UI Setup for AI
                const bar = document.getElementById('nav-instruction-bar');
                bar.className = 'mode-ai visible'; 

                this.updateNavAdvice(true); // Force first update
                
                // Check every 5 seconds for changes
                this.autoNavInterval = setInterval(() => {
                    this.checkConditions();
                }, 5000);
            },

            stopAutoNav() {
                this.isAutoNavActive = false;
                if(this.autoNavInterval) clearInterval(this.autoNavInterval);
                const btn = document.getElementById('btn-ai-nav');
                if(btn) { btn.classList.remove('text-green-400'); btn.classList.remove('animate-pulse'); }
                document.getElementById('nav-instruction-bar').classList.remove('visible');
            },

            checkConditions() {
                if(!state.targetWaypoint) { this.stopAutoNav(); return; }
                
                // Check wind change
                const currentWind = simulation.getWindAtAlt(simulation.alt);
                const threshold = state.settings.windThreshold || 5;
                
                if (this.lastCheckDir !== null) {
                    let diff = Math.abs(currentWind.dir - this.lastCheckDir);
                    if(diff > 180) diff = 360 - diff;
                    
                    if (diff >= threshold) {
                        this.updateNavAdvice();
                    }
                } else {
                    this.updateNavAdvice();
                }
            },

            async updateNavAdvice(force = false) {
                const textEl = document.getElementById('nav-instruction-text');
                textEl.innerText = "Berechne...";
                
                try {
                    const pos = simulation.getCurrentState();
                    const target = state.targetWaypoint;
                    const dist = getDistance(pos.lat, pos.lng, target.lat, target.lng).toFixed(2);
                    const bearing = getBearing(pos.lat, pos.lng, target.lat, target.lng).toFixed(0);
                    const maxWords = state.settings.aiMaxWords || 10;
                    
                    this.lastCheckDir = simulation.getWindAtAlt(pos.alt).dir; // Update last check

                    const winds = simulation.getCombinedLayers().map(l => `${l.alt}m: ${l.dir}°/${l.speed}kt`).join('\n');

                    const prompt = `Du bist ein Auto-Navi für Heißluftballone.
        Ziel-Peilung: ${bearing}°. Distanz: ${dist}km.
        Aktueller Wind auf ${Math.round(pos.alt)}m kommt aus ${Math.round(this.lastCheckDir)}°.
        Verfügbare Winde (Höhe: Richtung):
        ${winds}

        Gib EIN einziges, kurzes, prägnantes Kommando (maximal ${maxWords} Wörter) im Imperativ. 
        Beispiele: "Steigen auf 500m", "Sinken auf 100m", "Höhe halten", "Ziel erreicht".
        Keine Erklärungen.`;

                    const text = await this.callGemini(prompt);
                    textEl.innerText = text.replace(/[*"]/g, ''); // Clean output

                } catch (e) {
                    textEl.innerText = "Verbindung verloren";
                }
            },

            // Legacy manual call (kept but likely unused if auto is preferred)
            async getNavigationAdvice() {
                this.toggleAutoNav(); // Reuse button for auto-toggle
            },

            async getBaptismSuggestions(paxName, start, end, date, notes, btn, targetId) {
                if (!state.settings.apiKey) { ui.showToast("Kein API Key!", "error"); return; }
                
                const originalText = btn.innerHTML;
                btn.innerHTML = '<i class="fas fa-spinner fa-spin"></i>';
                btn.disabled = true;

                try {
                    const prompt = `Erstelle eine Liste von 5 lustigen, traditionellen Ballonfahrer-Adelstiteln (Taufnamen) für einen Passagier namens "${paxName}".
        Startort: ${start}. Landeort: ${end}.
        Besonderheiten: ${notes}.
        WICHTIG: Nutze das Wort "fahren" statt "fliegen" (Ballone fahren!).
        Format: Ein JSON Array von Strings. Beispiel: ["Graf X zu Y", "Baron Z von A"].`;

                    const text = await this.callGemini(prompt, true); // JSON Mode
                    let suggestions = [];
                    try {
                        suggestions = JSON.parse(text);
                        if (!Array.isArray(suggestions)) throw new Error("Kein Array");
                    } catch(e) {
                        // Fallback parsing if strict JSON fails (though model usually obeys)
                        suggestions = text.split('\n').filter(l => l.trim().length > 5).map(l => l.replace(/^\d+[\.\)]\s*/, '').replace(/"/g, ''));
                    }

                    if(suggestions.length > 0) {
                        // Prepare items for selection modal
                        const items = suggestions.map((s, i) => ({
                            id: s, // value is the text itself
                            main: s,
                            sub: `Vorschlag ${i+1}`
                        }));
                        
                        ui.showSelectionModal("Taufnamen wählen", items, (selectedText) => {
                            const input = document.getElementById(targetId);
                            if(input) input.value = selectedText;
                            ui.showToast("Taufname übernommen!");
                        });
                    } else {
                        throw new Error("Keine Vorschläge erhalten");
                    }

                } catch (e) {
                    ui.showToast("KI Fehler: " + e.message, "error");
                } finally {
                    btn.innerHTML = originalText;
                    btn.disabled = false;
                }
            }
        };

        /**
         * MAP MANAGER
         */
        const mapManager = {
            map: null, marker: null, track: null, lock: false, targetLayer: null, navLine: null, predictionLine: null, cpaMarker: null,
            activeKmlLayers: {}, 

            layers: {
                dark: L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'),
                light: L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png'),
                sat: L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}')
            },
            
            getTileUrl(style) {
                 if (style === 'light') return 'https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png';
                 if (style === 'sat') return 'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}';
                 return 'https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png'; // Default dark
            },

            init() {
                this.map = L.map('map', { zoomControl: false }).setView([51.1657, 10.4515], 13);
                const style = state.settings.mapStyle || 'dark';
                this.setLayer(style);
                this.updateIcon();
                this.track = L.polyline([], { color: state.settings.trackColor, weight: state.settings.trackWidth }).addTo(this.map);
                this.targetLayer = L.layerGroup().addTo(this.map);
                
                // Use custom color for Nav Line
                const navColor = state.settings.navLineColor || '#eab308';
                this.navLine = L.polyline([], { color: navColor, weight: 2, dashArray: '5, 10' }).addTo(this.map); 
                
                this.predictionLine = L.polyline([], { color: '#f472b6', weight: 3, dashArray: '5, 10', opacity: 0.7 }).addTo(this.map);
                this.renderTarget();
                this.renderKMLs();
                this.map.on('contextmenu', (e) => ui.setTarget(e.latlng));
                document.getElementById('btn-center').onclick = () => { this.lock = !this.lock; document.getElementById('btn-center').classList.toggle('active', this.lock); };
                document.getElementById('btn-layers').onclick = () => ui.toggleLayersMenu();
                ui.updateLockBtn();
                setTimeout(() => this.map.invalidateSize(), 500);
            },

            update(pos) {
                this.marker.setLatLng([pos.lat, pos.lng]);
                
                if (this.lock) {
                    let targetLat = pos.lat;
                    let targetLng = pos.lng;
                    if (state.settings.mapOffset > 0) {
                        const bounds = this.map.getBounds();
                        const heightDeg = bounds.getNorth() - bounds.getSouth();
                        const shiftDist = heightDeg * state.settings.mapOffset;
                        const rad = toRad(pos.course);
                        targetLat += Math.cos(rad) * shiftDist;
                        targetLng += (Math.sin(rad) * shiftDist) / Math.cos(toRad(pos.lat));
                    }
                    this.map.panTo([targetLat, targetLng], { animate: true, duration: 0.5 });
                }
                
                if (state.targetWaypoint) {
                    this.navLine.setLatLngs([[pos.lat, pos.lng], [state.targetWaypoint.lat, state.targetWaypoint.lng]]);
                    this.navLine.setStyle({ color: state.settings.navLineColor || '#eab308' });

                    // --- NEW: CPA on Map (Linked to Path Prediction) ---
                    // Show CPA if path prediction is enabled
                    if (state.settings.showPathPrediction) {
                        const cpaData = calculateCPA(pos.lat, pos.lng, pos.course, state.targetWaypoint.lat, state.targetWaypoint.lng);
                        const navColor = state.settings.navLineColor || '#eab308';
                        
                        // Only show if CPA is ahead or very close
                        if (cpaData.coords && cpaData.distAlongTrack > -1.0) { 
                             const cpaIconHtml = `<div style="display: flex; align-items: center; justify-content: center; width: 100%; height: 100%; color: ${navColor}; font-size: 24px; text-shadow: 0 0 5px black; filter: drop-shadow(0 0 2px black);">✕</div>`;
                             
                             if (!this.cpaMarker) {
                                 const cpaIcon = L.divIcon({
                                     html: cpaIconHtml,
                                     className: 'bg-transparent',
                                     iconSize: [24, 24],
                                     iconAnchor: [12, 12]
                                 });
                                 // Increased Z-Index to ensure visibility
                                 this.cpaMarker = L.marker([cpaData.coords.lat, cpaData.coords.lng], { icon: cpaIcon, zIndexOffset: 2000 }).addTo(this.map);
                             } else {
                                 this.cpaMarker.setLatLng([cpaData.coords.lat, cpaData.coords.lng]);
                                 // Update Icon (to handle color changes dynamically)
                                 const cpaIcon = L.divIcon({
                                     html: cpaIconHtml,
                                     className: 'bg-transparent',
                                     iconSize: [24, 24],
                                     iconAnchor: [12, 12]
                                 });
                                 this.cpaMarker.setIcon(cpaIcon);
                             }
                        } else {
                             if(this.cpaMarker) { this.map.removeLayer(this.cpaMarker); this.cpaMarker = null; }
                        }
                    } else {
                        if(this.cpaMarker) { this.map.removeLayer(this.cpaMarker); this.cpaMarker = null; }
                    }

                } else {
                    this.navLine.setLatLngs([]);
                    if(this.cpaMarker) { this.map.removeLayer(this.cpaMarker); this.cpaMarker = null; }
                }

                if (flightManager.recording) {
                    flightManager.points.push([pos.lat, pos.lng, pos.alt]);
                    this.track.setLatLngs(flightManager.points);
                }

                // PATH PREDICTION
                if (state.settings.showPathPrediction && pos.speed > 1) {
                      // Speed in knots -> km/h -> km/min
                      const speedKmh = pos.speed * 1.852;
                      const distKm = (speedKmh / 60) * (state.settings.pathPredictionMinutes || 5);
                      const dest = calculateDestination(pos.lat, pos.lng, pos.course, distKm);
                      this.predictionLine.setLatLngs([[pos.lat, pos.lng], [dest.lat, dest.lng]]);
                } else {
                      this.predictionLine.setLatLngs([]);
                }
            },

            updateTrackStyle() {
                if(this.track) {
                    this.track.setStyle({ color: state.settings.trackColor, weight: state.settings.trackWidth });
                }
            },

            updateIcon() {
                let iconHtml = '<div class="text-3xl">🎈</div>';
                let className = '';
                let balloonIdToUse = state.settings.activeBalloonId;
                if (flightManager.recording && flightManager.currentActivePlan) {
                    balloonIdToUse = flightManager.currentActivePlan.balloonId;
                }
                if (balloonIdToUse) {
                    const balloon = state.balloons.find(b => b.id === balloonIdToUse);
                    if (balloon && balloon.image) {
                        iconHtml = `<img src="${balloon.image}" class="balloon-marker-img">`;
                        className = ''; 
                    }
                }
                const newIcon = L.divIcon({ html: iconHtml, className: className, iconSize: [44, 44], iconAnchor: [22, 22] });
                if (this.marker) { this.marker.setIcon(newIcon); } else { this.marker = L.marker([51.1657, 10.4515], { icon: newIcon }).addTo(this.map); }
            },

            setLayer(style) {
                if (this.map.hasLayer(this.layers.dark)) this.map.removeLayer(this.layers.dark);
                if (this.map.hasLayer(this.layers.light)) this.map.removeLayer(this.layers.light);
                if (this.map.hasLayer(this.layers.sat)) this.map.removeLayer(this.layers.sat);
                const m = document.getElementById('map');
                m.classList.remove('satellite-layer');
                if (style === 'light') { this.layers.light.addTo(this.map); } 
                else if (style === 'sat') { this.layers.sat.addTo(this.map); m.classList.add('satellite-layer'); } 
                else { this.layers.dark.addTo(this.map); }
                state.settings.mapStyle = style;
                saveState();
            },

            renderTarget() {
                this.targetLayer.clearLayers();
                if (state.targetWaypoint) {
                    const marker = L.marker([state.targetWaypoint.lat, state.targetWaypoint.lng], {
                        icon: L.divIcon({ 
                            html: '<i class="fas fa-map-marker-alt text-yellow-500 text-3xl drop-shadow-md"></i>', 
                            className: 'bg-transparent',
                            iconSize: [30, 30],
                            iconAnchor: [15, 30]
                        })
                    });
                    marker.bindPopup(`<div class="text-slate-900 text-sm text-center font-bold"><button onclick="ui.clearTarget()" class="text-red-600 hover:text-red-800 text-xs">Ziel Löschen</button></div>`);
                    this.targetLayer.addLayer(marker);
                }
            },

            // --- KML HANDLING ---
            renderKMLs() {
                state.kmlOverlays.forEach(overlay => {
                    if (overlay.visible && !this.activeKmlLayers[overlay.id]) {
                        try {
                            const customLayer = L.geoJson(null, {
                                style: (feature) => {
                                    let color = '#3b82f6'; 
                                    if (feature && feature.properties) {
                                        const text = ((feature.properties.name || '') + ' ' + (feature.properties.description || '')).toUpperCase();
                                        const isRestricted = text.includes('ED-R') || text.includes('ED-P') || text.includes('ED-D') || /ED[RPD]\s*\d/.test(text) || text.includes('RESTRICTED') || text.includes('PROHIBITED') || text.includes('DANGER');
                                        if (isRestricted) { color = '#ef4444'; }
                                    }
                                    return { color: color, weight: 2, opacity: 0.8, fillColor: color, fillOpacity: 0.2 };
                                },
                                onEachFeature: (feature, layer) => {
                                    if (feature.properties && (feature.properties.name || feature.properties.description)) {
                                        layer.bindPopup(`<div class="text-slate-900"><div class="font-bold border-b border-slate-300 mb-1">${feature.properties.name || ''}</div><div class="text-xs">${feature.properties.description || ''}</div></div>`);
                                    }
                                }
                            });
                            const layer = omnivore.kml.parse(overlay.content, null, customLayer);
                            layer.addTo(this.map);
                            this.activeKmlLayers[overlay.id] = layer;
                        } catch (e) { console.error("KML Parse Error", e); }
                    } else if (!overlay.visible && this.activeKmlLayers[overlay.id]) {
                        this.map.removeLayer(this.activeKmlLayers[overlay.id]);
                        delete this.activeKmlLayers[overlay.id];
                    }
                });
                Object.keys(this.activeKmlLayers).forEach(id => {
                    if (!state.kmlOverlays.find(o => o.id == id)) {
                        this.map.removeLayer(this.activeKmlLayers[id]);
                        delete this.activeKmlLayers[id];
                    }
                });
            },

            handleKmlImport(input) {
                if (input.files && input.files[0]) {
                    Array.from(input.files).forEach(file => {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            state.kmlOverlays.push({ id: Date.now() + Math.random(), name: file.name, content: e.target.result, visible: true });
                            saveState();
                            this.renderKMLs();
                            ui.render(); 
                            ui.showToast(`KML "${file.name}" geladen!`);
                        };
                        reader.readAsText(file);
                    });
                    input.value = '';
                }
            }
        };

        const flightManager = {
            recording: false, points: [], start: null, currentActivePlan: null, currentPhotos: [],
            maxSpeed: 0, maxAlt: 0,
            init() { 
                const btn = document.getElementById('btn-record');
                let pressTimer;
                let longPressTriggered = false;
                btn.addEventListener('click', (e) => {
                    if (longPressTriggered) { longPressTriggered = false; return; }
                    if (!this.recording) { ui.showStartDialog(); } else { ui.showToast("Zum Stoppen 1.5 Sek. gedrückt halten", "error"); }
                });
                const start = (e) => {
                    if (!this.recording) return;
                    if (e.type === 'mousedown' && e.button !== 0) return;
                    longPressTriggered = false;
                    pressTimer = setTimeout(() => { longPressTriggered = true; this.stopRecording(); if (navigator.vibrate) navigator.vibrate(500); }, 1500); 
                };
                const cancel = () => { clearTimeout(pressTimer); };
                btn.addEventListener('mousedown', start);
                btn.addEventListener('touchstart', start, {passive: true});
                btn.addEventListener('mouseup', cancel);
                btn.addEventListener('mouseleave', cancel);
                btn.addEventListener('touchend', cancel);
                this.cleanOldPhotos();
            },
            toggle() { },
            takePhoto() { document.getElementById('cam-input').click(); },
            handlePhotoInput(input) {
                if (input.files && input.files[0]) {
                    const file = input.files[0];
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        const img = new Image();
                        img.onload = () => {
                            const canvas = document.createElement('canvas');
                            const ctx = canvas.getContext('2d');
                            const MAX_SIZE = 800; 
                            let width = img.width; let height = img.height;
                            if (width > height) { if (width > MAX_SIZE) { height *= MAX_SIZE / width; width = MAX_SIZE; } } else { if (height > MAX_SIZE) { width *= MAX_SIZE / height; height = MAX_SIZE; } }
                            canvas.width = width; canvas.height = height;
                            ctx.drawImage(img, 0, 0, width, height);
                            const compressedDataUrl = canvas.toDataURL('image/jpeg', 0.6); 
                            this.currentPhotos.push({ time: new Date().toISOString(), src: compressedDataUrl, lat: simulation.lat, lng: simulation.lng });
                            ui.showToast("Foto gespeichert (komprimiert)!", "success");
                            saveState();
                        };
                        img.src = e.target.result;
                    };
                    reader.readAsDataURL(file);
                }
            },
            cleanOldPhotos() { /* ... same */ },
            cleanOldPhotosNow() { this.cleanOldPhotos(); ui.showToast("Bereinigung durchgeführt.", "success"); },
            startRecording(planId, balloonId) {
                wakeLockManager.request();
                let plan = null;
                if (planId) { plan = state.plannings.find(p => p.id == planId) || state.archive.find(p => p.id == planId); }
                if (!plan && balloonId) {
                    const b = state.balloons.find(x => x.id === balloonId);
                    this.currentActivePlan = { id: null, name: "Spontanfahrt", balloonId: balloonId, balloonName: b ? b.callsign : "Unbekannt", passengers: [], cylinders: [] };
                } else { this.currentActivePlan = plan; }
                this.currentPhotos = []; this.maxSpeed = 0; this.maxAlt = 0;
                state.measuredWindLayers = []; ui.renderWind(); this.points = []; mapManager.track.setLatLngs([]);
                this.recording = true; this.start = new Date();
                document.getElementById('btn-record').classList.add('recording');
                document.getElementById('sb-rec').classList.remove('hidden');
                document.getElementById('btn-take-photo').classList.remove('hidden');
                ui.closeModal();
                mapManager.updateIcon();
                ui.updateAiButtonVisibility();
            },
            async stopRecording() {
                if (state.settings.mode !== 'gps') { wakeLockManager.release(); }
                const end = new Date();
                let balloonName = "Spontan";
                if (this.currentActivePlan && this.currentActivePlan.balloonName) { balloonName = this.currentActivePlan.balloonName; } else { const defB = state.balloons.find(b => b.id === state.settings.activeBalloonId); if(defB) balloonName = defB.callsign; }
                const currentPaxIds = this.currentActivePlan ? this.currentActivePlan.passengers : [];
                if (currentPaxIds.length > 0) { currentPaxIds.forEach(pid => { const p = state.passengers.find(px => px.id == pid); if (p) { p.flights = (p.flights || 0) + 1; p.lastFlight = new Date().toISOString(); } }); }
                let startLoc = "Unbekannt"; let endLoc = "Unbekannt";
                if (this.points.length > 0) {
                    try {
                        const startPt = this.points[0]; const endPt = this.points[this.points.length-1];
                        const getPlaceName = (data) => { if (!data || !data.address) return data.display_name ? data.display_name.split(',')[0] : "Unbekannter Ort"; return data.address.city || data.address.town || data.address.village || data.address.hamlet || data.address.municipality || data.address.suburb || (data.display_name ? data.display_name.split(',')[0] : "Unbekannter Ort"); };
                        const r1 = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${startPt[0]}&lon=${startPt[1]}`); const d1 = await r1.json(); startLoc = getPlaceName(d1);
                        const r2 = await fetch(`https://nominatim.openstreetmap.org/reverse?format=json&lat=${endPt[0]}&lon=${endPt[1]}`); const d2 = await r2.json(); endLoc = getPlaceName(d2);
                    } catch(e) { 
                        // Fallback coords
                        if(this.points.length > 0) {
                            startLoc = `${this.points[0][0].toFixed(4)}, ${this.points[0][1].toFixed(4)}`;
                            endLoc = `${this.points[this.points.length-1][0].toFixed(4)}, ${this.points[this.points.length-1][1].toFixed(4)}`;
                        }
                    }
                }
                const newLog = { id: Date.now(), start: this.start.toISOString(), end: end.toISOString(), track: this.points, balloon: balloonName, notes: "", startLoc: startLoc, endLoc: endLoc, planId: this.currentActivePlan ? this.currentActivePlan.id : null, pax: currentPaxIds, cylinders: this.currentActivePlan ? this.currentActivePlan.cylinders : [], photos: this.currentPhotos, maxSpeed: this.maxSpeed, maxAlt: this.maxAlt };
                state.logs.push(newLog);
                saveState();
                this.recording = false;
                this.currentActivePlan = null;
                document.getElementById('btn-record').classList.remove('recording');
                document.getElementById('sb-rec').classList.add('hidden');
                document.getElementById('btn-take-photo').classList.add('hidden');
                mapManager.updateIcon();
                ui.showSummary(newLog);
            },
            updateHUD(data) {
                mapManager.update(data);
                // ... same HUD update logic ...
                let dAlt = data.alt; let dSpeed = data.speed; let dVario = data.vario; let uAlt = 'm'; let uSpeed = 'km/h'; let uVario = 'm/s';
                if (state.settings.unitAlt === 'ft') { dAlt = data.alt * 3.28084; uAlt = 'ft'; }
                if (state.settings.unitSpeed === 'kmh') { dSpeed = data.speed * 1.852; uSpeed = 'km/h'; } else { uSpeed = 'kt'; }
                if (state.settings.unitVario === 'fts') { dVario = data.vario * 3.28084; uVario = 'ft/s'; }

                document.getElementById('hud-alt').innerText = Math.round(dAlt);
                document.getElementById('lbl-alt').innerText = uAlt;
                document.getElementById('hud-speed').innerText = dSpeed.toFixed(1);
                document.getElementById('lbl-speed').innerText = uSpeed;
                document.getElementById('hud-course').innerText = Math.round(data.course);
                
                const varioValEl = document.getElementById('hud-vario');
                varioValEl.innerText = dVario.toFixed(1);
                document.getElementById('lbl-vario').innerText = uVario;
                varioValEl.className = 'hud-num'; 
                
                // Vario Limits Check
                let currentBalloon = null;
                let balloonIdToUse = state.settings.activeBalloonId;
                if (this.recording && this.currentActivePlan) { balloonIdToUse = this.currentActivePlan.balloonId; }
                if (balloonIdToUse) { currentBalloon = state.balloons.find(b => b.id === balloonIdToUse); }

                if (currentBalloon) {
                    const maxClimb = currentBalloon.maxClimb || 5;
                    const maxDescent = currentBalloon.maxDescent || 3;
                    if (data.vario > maxClimb || data.vario < -maxDescent) { varioValEl.classList.add('text-blink-red'); } 
                    else if (data.vario >= 0.1) { varioValEl.classList.add('text-green-400'); } 
                    else if (data.vario <= -0.1) { varioValEl.classList.add('text-red-400'); }
                }
                
                const timeEl = document.getElementById('hud-time');
                if (this.recording && this.start) {
                    const now = new Date(); const diffMs = now - this.start; const h = Math.floor(diffMs / 3600000); const m = Math.floor((diffMs % 3600000) / 60000);
                    timeEl.innerText = `${h.toString().padStart(2,'0')}:${m.toString().padStart(2,'0')}`;
                } else { timeEl.innerText = "--:--"; }
                
                if (this.recording && data.speed > 1) { 
                    const interval = state.settings.windMeasInterval || 50;
                    const bucketAlt = Math.round(data.alt / interval) * interval;
                    const existingIdx = state.measuredWindLayers.findIndex(l => l.alt === bucketAlt);
                    
                    // FIX: Convert Track (Movement) to Wind Source (From)
                    // If moving South (180), Wind is From North (0).
                    const windFrom = (data.course + 180) % 360;

                    // NEW: Add timestamp
                    const newLayer = { alt: bucketAlt, dir: windFrom, speed: data.speed, isMeasured: true, timestamp: Date.now() };
                    
                    if (existingIdx >= 0) { state.measuredWindLayers[existingIdx] = newLayer; } else { state.measuredWindLayers.push(newLayer); }
                    ui.renderWind();
                    if (data.alt > this.maxAlt) this.maxAlt = data.alt;
                    let currentSpeedKmh = data.speed * 1.852;
                    if (currentSpeedKmh > this.maxSpeed) this.maxSpeed = currentSpeedKmh;
                }
                // Wind rows highlight
                const windRows = document.querySelectorAll('.wind-layer');
                windRows.forEach(row => {
                    row.classList.remove('active-altitude'); // Reset all first
                    const rowAlt = parseInt(row.dataset.alt);
                    const diff = Math.abs(rowAlt - data.alt);
                    // Simple highlighting logic: Highlight if within range of layer
                    if (diff < 25) { 
                        row.classList.add('active-altitude'); 
                    } 
                });
                // Find closest just in case none were < 25 (e.g. at 75m between 50 and 100)
                let minDiff = Infinity;
                let closestRow = null;
                windRows.forEach(row => {
                    const rowAlt = parseInt(row.dataset.alt);
                    const diff = Math.abs(rowAlt - data.alt);
                    if(diff < minDiff) { minDiff = diff; closestRow = row; }
                });
                if(closestRow) closestRow.classList.add('active-altitude');


                // Nav
                if (state.targetWaypoint) {
                    const wp = state.targetWaypoint;
                    const distKm = getDistance(simulation.lat, simulation.lng, wp.lat, wp.lng);
                    const bearing = getBearing(simulation.lat, simulation.lng, wp.lat, wp.lng);
                    document.getElementById('hud-nav-container').classList.remove('hidden'); 
                    document.getElementById('nav-brg').innerText = Math.round(bearing);
                    
                    // --- NEW CPA DISPLAY LOGIC with TIME ---
                    const cpaData = calculateCPA(simulation.lat, simulation.lng, simulation.course, wp.lat, wp.lng);
                    const cpaEl = document.getElementById('hud-cpa');
                    const cpaLbl = document.getElementById('lbl-cpa');
                    const cpaTimeEl = document.getElementById('hud-cpa-time');
                    
                    // Calculate Time to CPA
                    // Time = distAlongTrack (km) / speed (km/h)
                    let tcpaStr = "";
                    const speedKmh = data.speed * 1.852;
                    
                    if (cpaData.distAlongTrack > 0 && speedKmh > 1) {
                        const tcpaHrs = cpaData.distAlongTrack / speedKmh;
                        const tcpaMin = Math.round(tcpaHrs * 60);
                        if (tcpaMin < 1) tcpaStr = "< 1 min";
                        else if (tcpaMin > 60) tcpaStr = `> 1h`;
                        else tcpaStr = `in ${tcpaMin} min`;
                    } else if (cpaData.distAlongTrack <= 0) {
                        tcpaStr = "Passiert";
                    }

                    cpaTimeEl.innerText = tcpaStr;

                    if (state.settings.unitAlt === 'ft') {
                         // NM Display
                         const missNm = cpaData.missDistance * 0.539957;
                         cpaEl.innerText = missNm.toFixed(2);
                         cpaLbl.innerHTML = 'CPA <small>nm</small>';
                    } else {
                         // KM Display (or meters if very close)
                         if (cpaData.missDistance < 1) {
                             cpaEl.innerText = Math.round(cpaData.missDistance * 1000);
                             cpaLbl.innerHTML = 'CPA <small>m</small>';
                         } else {
                             cpaEl.innerText = cpaData.missDistance.toFixed(2);
                             cpaLbl.innerHTML = 'CPA <small>km</small>';
                         }
                    }

                    // --- Original Nav Dist ---
                    if (state.settings.unitAlt === 'ft') { 
                        const distNm = distKm * 0.539957;
                        document.getElementById('nav-dist').innerText = distNm.toFixed(1);
                        document.getElementById('lbl-nav-dist').innerText = 'nm'; 
                        if (data.speed > 1) {
                            const hours = distNm / data.speed;
                            const mins = Math.round(hours * 60);
                            document.getElementById('nav-ete').innerText = mins + " min";
                        } else { document.getElementById('nav-ete').innerText = "--:--"; }
                    } else {
                        document.getElementById('nav-dist').innerText = distKm.toFixed(1);
                        document.getElementById('lbl-nav-dist').innerText = 'km'; 
                        
                        if (speedKmh > 1) {
                            const hours = distKm / speedKmh;
                            const mins = Math.round(hours * 60);
                            document.getElementById('nav-ete').innerText = mins + " min";
                        } else { document.getElementById('nav-ete').innerText = "--:--"; }
                    }
                } else { 
                    document.getElementById('hud-nav-container').classList.add('hidden'); 
                    // Stop Auto Nav if active when target cleared
                    if(aiService.isAutoNavActive) {
                        aiService.stopAutoNav();
                    }
                    if(localNavService.isActive) localNavService.stopLocalNav();
                }
            }
        };

        const simulation = {
            gpsWatchId: null, lastGpsTime: null, lastGpsAlt: null,
            lat: 51.1657, lng: 10.4515, alt: 200, targetAlt: 200,
            course: 270, speed: 5, vario: 0,
            targetVario: 0, // NEW for realistic physics

            init() {
                document.addEventListener('visibilitychange', () => wakeLockManager.handleVisibilityChange());
                if (navigator.geolocation) {
                    navigator.geolocation.getCurrentPosition(pos => {
                        this.lat = pos.coords.latitude;
                        this.lng = pos.coords.longitude;
                        if(mapManager.map) { mapManager.map.setView([this.lat, this.lng], 14); flightManager.updateHUD(this.getCurrentState()); }
                    }, () => {});
                }
                barometerService.init();
                setInterval(() => this.tick(), 1000);
                this.applyMode();
            },

            applyMode() {
                const mode = state.settings.mode;
                const simPanel = document.getElementById('sim-panel');
                const badgeGPS = document.getElementById('sb-gps');
                const badgeGPSText = document.getElementById('sb-gps-text');
                if (!simPanel || !badgeGPS) return;
                if (mode === 'gps') {
                    simPanel.classList.add('hidden'); badgeGPS.classList.remove('hidden'); badgeGPS.classList.remove('blue', 'green'); badgeGPS.classList.add('red');
                    if(badgeGPSText) badgeGPSText.innerText = "NO GPS";
                    this.startGPS();
                } else {
                    simPanel.classList.remove('hidden'); badgeGPS.classList.remove('hidden');
                    if(badgeGPSText) badgeGPSText.innerText = "SIMULATION";
                    badgeGPS.classList.remove('red', 'green'); badgeGPS.classList.add('blue');
                    this.stopGPS();
                }
            },

            startGPS() {
                wakeLockManager.request();
                const badgeGPS = document.getElementById('sb-gps'); const badgeGPSText = document.getElementById('sb-gps-text');
                if (navigator.geolocation) {
                    if (this.gpsWatchId) navigator.geolocation.clearWatch(this.gpsWatchId);
                    this.gpsWatchId = navigator.geolocation.watchPosition(pos => {
                        const c = pos.coords; const now = Date.now();
                        if(badgeGPSText) badgeGPSText.innerText = "GPS OK";
                        badgeGPS.classList.remove('red', 'blue'); badgeGPS.classList.add('green');
                        
                        this.lat = c.latitude; this.lng = c.longitude;
                        if (c.altitude !== null) {
                            if (barometerService.isAvailable) { this.vario = barometerService.vario; this.alt = c.altitude; } 
                            else {
                                if (this.lastGpsTime && this.lastGpsAlt !== null) {
                                    const dt = (now - this.lastGpsTime) / 1000;
                                    if (dt > 0) { const instantVario = (c.altitude - this.lastGpsAlt) / dt; this.vario = (this.vario * 0.7) + (instantVario * 0.3); }
                                }
                                this.alt = c.altitude; this.lastGpsAlt = c.altitude; this.lastGpsTime = now;
                            }
                        }
                        this.speed = (c.speed || 0) * 1.94384; 
                        if(c.heading !== null && !isNaN(c.heading)) this.course = c.heading;
                        flightManager.updateHUD(this.getCurrentState());
                    }, err => {
                        console.warn("GPS Fehler:", err.message);
                        if(badgeGPSText) badgeGPSText.innerText = "NO GPS";
                        badgeGPS.classList.remove('green', 'blue'); badgeGPS.classList.add('red');
                        ui.showToast("GPS Signal verloren", "error");
                    }, { enableHighAccuracy: true, timeout: 5000, maximumAge: 0 });
                } else { if(badgeGPSText) badgeGPSText.innerText = "NO SUPP"; badgeGPS.classList.remove('green', 'blue'); badgeGPS.classList.add('red'); }
            },

            stopGPS() {
                if (this.gpsWatchId) { navigator.geolocation.clearWatch(this.gpsWatchId); this.gpsWatchId = null; }
                if (!flightManager.recording) { wakeLockManager.release(); }
            },

            // New Physics-like control
            setTargetVario(v) { this.targetVario = v; },
            adjustAltitude(delta) { this.targetAlt += delta; /* Backward compat */ },

            tick() {
                if (state.settings.mode === 'gps') return;
                
                // --- NEW PHYSICS ---
                // Vario Inertia: Move current vario towards target vario
                const inertia = 0.2; // 0.2 m/s change per second (approx)
                if (this.vario < this.targetVario) this.vario = Math.min(this.targetVario, this.vario + inertia);
                else if (this.vario > this.targetVario) this.vario = Math.max(this.targetVario, this.vario - inertia);
                
                this.alt += this.vario;
                if(this.alt < 0) { this.alt = 0; this.vario = 0; }

                const wind = this.getWindAtAlt(this.alt);
                
                // Wind from Direction. Balloon goes WITH wind.
                // If wind is 270 (West), balloon goes TO 90 (East).
                this.course = (wind.dir + 180) % 360;
                this.speed = wind.speed; 
                
                const moveScale = this.speed * 0.000009; // Approx scale factor for kn to degrees
                
                this.lat += Math.cos(toRad(this.course)) * moveScale;
                this.lng += Math.sin(toRad(this.course)) * moveScale;

                flightManager.updateHUD(this.getCurrentState());
            },

            // Helper to merge layers correctly
            getCombinedLayers() {
                // Start with base layers (forecast)
                const allLayers = [...state.windLayers];
                
                // Add measured/manual layers
                if (state.measuredWindLayers) {
                    state.measuredWindLayers.forEach(m => {
                        // Find if there is a layer at basically the same altitude and replace it
                        // Or just add it. Since we sort by altitude, adding is fine unless exact duplicate.
                        // Let's replace if within 1m to avoid double layers
                        const idx = allLayers.findIndex(l => Math.abs(l.alt - m.alt) < 1);
                        if(idx >= 0) allLayers[idx] = m;
                        else allLayers.push(m);
                    });
                }
                // Sort by altitude ascending
                return allLayers.sort((a,b) => a.alt - b.alt);
            },

            getWindAtAlt(altitude) {
                // Use combined layers for consistent physics
                const sorted = this.getCombinedLayers();
                
                if (sorted.length === 0) return { dir: 0, speed: 0 }; // Fallback

                let lower = sorted[0], upper = sorted[sorted.length-1];
                for (let i = 0; i < sorted.length - 1; i++) {
                    if (altitude >= sorted[i].alt && altitude <= sorted[i+1].alt) {
                        lower = sorted[i]; upper = sorted[i+1]; break;
                    }
                }
                // Linear Interpolation
                const range = upper.alt - lower.alt;
                const factor = range === 0 ? 0 : (altitude - lower.alt) / range;
                
                // Handle 360 wrap around for direction?
                // Simple linear for now. 350 to 10 is tricky.
                let dirDiff = upper.dir - lower.dir;
                if (dirDiff > 180) dirDiff -= 360;
                if (dirDiff < -180) dirDiff += 360;
                
                let newDir = lower.dir + dirDiff * factor;
                if(newDir < 0) newDir += 360;
                if(newDir >= 360) newDir -= 360;

                return {
                    dir: newDir,
                    speed: lower.speed + (upper.speed - lower.speed) * factor
                };
            },

            getCurrentState() { return { lat: this.lat, lng: this.lng, alt: this.alt, course: this.course, speed: this.speed, vario: this.vario }; }
        };

        const weatherService = {
            async fetchLiveWind() {
                const center = mapManager.map.getCenter();
                // ... (Existing code kept as is) ...
                // Reusing previous logic
                const lat = center.lat; const lng = center.lng;
                document.getElementById('wind-layers-container').innerHTML = '<div class="text-center p-2"><div class="loader"></div></div>';
                try {
                    const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current=wind_speed_10m,wind_direction_10m&hourly=wind_speed_1000hPa,wind_direction_1000hPa,wind_speed_950hPa,wind_direction_950hPa,wind_speed_850hPa,wind_direction_850hPa,wind_speed_700hPa,wind_direction_700hPa&wind_speed_unit=kn&models=best_match`;
                    const response = await fetch(url);
                    const data = await response.json();
                    if (!data.hourly) throw new Error("Keine Daten");
                    const now = new Date();
                    const currentHourIso = now.toISOString().slice(0, 13) + ":00";
                    const hourIndex = data.hourly.time.findIndex(t => t.startsWith(currentHourIso)) || 0;
                    const newLayers = [
                        { alt: 0, dir: data.current.wind_direction_10m, speed: data.current.wind_speed_10m },
                        { alt: 100, dir: data.hourly.wind_direction_1000hPa[hourIndex], speed: data.hourly.wind_speed_1000hPa[hourIndex] },
                        { alt: 500, dir: data.hourly.wind_direction_950hPa[hourIndex], speed: data.hourly.wind_speed_950hPa[hourIndex] },
                        { alt: 1500, dir: data.hourly.wind_direction_850hPa[hourIndex], speed: data.hourly.wind_speed_850hPa[hourIndex] },
                        { alt: 3000, dir: data.hourly.wind_direction_700hPa[hourIndex], speed: data.hourly.wind_speed_700hPa[hourIndex] }
                    ];
                    state.windLayers = newLayers;
                    saveState();
                    ui.renderWind();
                    ui.showToast(`Live-Winddaten für ${lat.toFixed(2)}, ${lng.toFixed(2)} geladen!`, 'success');
                    if (ui.tab === 'environment') ui.render();
                } catch (e) {
                    ui.showToast("Fehler beim Laden der Wetterdaten: " + e.message, 'error');
                    ui.renderWind(); 
                }
            }
        };

        const ui = {
            tab: 'planning', editingId: null, editingPlanId: null, planningMode: 'active', passengerMode: 'active', toastTimeout: null,
            fleetMode: 'active', summaryMap: null, // Holds reference to map in modal

            init() { 
                document.getElementById('btn-settings').onclick = () => this.openModal(); 
                this.renderWind(); 
                this.updateLockBtn(); 
                this.updateAiButtonVisibility(); // Check initially

                // Global click listener for menus
                document.addEventListener('click', (e) => {
                    const menu = document.getElementById('layers-menu');
                    const btn = document.getElementById('btn-layers');
                    
                    // Close layers menu if clicked outside
                    if (menu.style.display === 'flex' && !menu.contains(e.target) && !btn.contains(e.target)) {
                        menu.style.display = 'none';
                    }
                });

                // --- NEW: Network Status Listeners ---
                window.addEventListener('online', () => this.updateNetworkStatus());
                window.addEventListener('offline', () => this.updateNetworkStatus());
                this.updateNetworkStatus(); // Initial check
                
                // --- NEW: Import Listener Fix ---
                const importInput = document.getElementById('import-input');
                if (importInput) {
                    importInput.addEventListener('change', (e) => system.importData(e.target));
                }
                
                // Expose system globally for inline calls if needed, though listeners are better
                window.system = system;
                window.ui = this;
            },
            
            // --- NEW: Network Status Logic ---
            updateNetworkStatus() {
                const badge = document.getElementById('sb-net');
                const text = document.getElementById('sb-net-text');
                const isOnline = navigator.onLine;
                
                if (badge && text) {
                    if (isOnline) {
                        badge.classList.remove('red');
                        badge.classList.add('green');
                        text.innerText = "ONLINE";
                    } else {
                        badge.classList.remove('green');
                        badge.classList.add('red');
                        text.innerText = "OFFLINE";
                        this.showToast("Du bist Offline. Karte lädt nicht mehr.", "error");
                    }
                }
            },
            
            formatTime(isoString) { /* ... */ const date = new Date(isoString); if (state.settings.useUTC) { const h = date.getUTCHours().toString().padStart(2, '0'); const m = date.getUTCMinutes().toString().padStart(2, '0'); return `${h}:${m} (UTC)`; } return date.toLocaleTimeString('de-DE', {hour: '2-digit', minute:'2-digit'}); },

            // --- FIXED: AUTO-COLLAPSING TOASTS ON RIGHT EDGE ---
            showToast(msg, type = 'success') {
                const container = document.getElementById('toast-container');
                
                // Create element
                const t = document.createElement('div');
                const typeClass = type === 'error' ? 'error' : (type === 'info' ? 'info' : 'success');
                t.className = `toast-notification ${typeClass}`;
                
                const icon = type === 'error' ? '<i class="fas fa-exclamation-circle text-red-400"></i>' : (type === 'info' ? '<i class="fas fa-info-circle text-blue-400"></i>' : '<i class="fas fa-check-circle text-green-400"></i>');
                
                // Inner HTML with explicit close button and click handler for body expansion
                t.innerHTML = `
                    ${icon} 
                    <span class="font-medium">${msg}</span>
                    <button class="toast-close" onclick="this.parentElement.remove()">&times;</button>
                `;
                
                // Click handler to expand if collapsed (mobile friendly)
                t.onclick = (e) => {
                    if(!e.target.classList.contains('toast-close')) {
                        t.classList.remove('collapsed');
                    }
                };

                // Limit stack size
                if (container.children.length > 4) {
                    container.removeChild(container.firstChild);
                }

                container.appendChild(t);
                
                // Slide in animation (remove offset)
                requestAnimationFrame(() => {
                    t.classList.add('show');
                });
                
                // Auto collapse logic (visual minimize)
                setTimeout(() => {
                    if (t && t.parentElement) {
                        t.classList.add('collapsed');
                    }
                }, 3000); // 3 seconds visible, then collapse

                // NEW: Auto Remove Logic based on Settings
                const timeoutSec = state.settings.toastTimeout || 60; // Default 60s
                setTimeout(() => {
                    if (t && t.parentElement) t.remove();
                }, timeoutSec * 1000);
            },
            
            toggleWindPanel() {
                const panel = document.getElementById('wind-panel');
                const chevron = document.getElementById('icon-wind-toggle'); 
                if (panel) panel.classList.toggle('collapsed');
                
                // Toggle Chevron Direction
                if (chevron) {
                      const isCollapsed = panel.classList.contains('collapsed');
                      if (isCollapsed) {
                          chevron.classList.add('collapsed'); // Rotate 180
                      } else {
                          chevron.classList.remove('collapsed'); // Default
                      }
                }
            },
            
            toggleTopHUD() {
                const hud = document.getElementById('hud-top');
                const btnIcon = document.getElementById('icon-top-hud-toggle');
                const container = document.getElementById('hud-top-container');
                hud.classList.toggle('minimized'); container.classList.toggle('docked');
                btnIcon.classList.toggle('collapsed', hud.classList.contains('minimized'));
            },

            toggleNavHUD() {
                const nav = document.getElementById('hud-nav');
                const btnIcon = document.getElementById('icon-nav-hud-toggle');
                const container = document.getElementById('hud-nav-container');
                nav.classList.toggle('minimized'); container.classList.toggle('docked');
                btnIcon.classList.toggle('collapsed', nav.classList.contains('minimized'));
            },
            
            toggleWaypointLock() { state.waypointLocked = !state.waypointLocked; saveState(); this.updateLockBtn(); this.showToast(state.waypointLocked ? "Wegpunkt gesperrt" : "Wegpunkt entsperrt"); },
            updateLockBtn() { const btn = document.getElementById('btn-waypoint-lock'); const icon = document.getElementById('icon-wp-lock'); if (state.waypointLocked) { btn.classList.add('locked'); icon.className = 'fas fa-lock'; } else { btn.classList.remove('locked'); icon.className = 'fas fa-lock-open'; } },
            setTarget(latlng) { if (state.waypointLocked) { this.showToast("Wegpunkt ist gesperrt!", "error"); return; } state.targetWaypoint = { lat: latlng.lat, lng: latlng.lng }; saveState(); mapManager.renderTarget(); this.showToast("Ziel gesetzt", "success"); flightManager.updateHUD(simulation.getCurrentState()); document.getElementById('btn-nav-toggle-wrapper').classList.remove('hidden'); },
            clearTarget() { 
                if (state.waypointLocked) { this.showToast("Wegpunkt ist gesperrt!", "error"); return; } 
                state.targetWaypoint = null; 
                saveState(); 
                mapManager.renderTarget(); 
                document.getElementById('hud-nav-container').classList.add('hidden'); 
                document.getElementById('btn-nav-toggle-wrapper').classList.add('hidden'); 
                this.showToast("Navigation beendet");
                
                // Stop auto nav if active
                if(aiService.isAutoNavActive) {
                    aiService.stopAutoNav();
                }
                if(localNavService.isActive) localNavService.stopLocalNav();
            },
            editWindSettings() { this.openModal(); this.switchTab('environment'); },
            openModal() { document.getElementById('main-modal').style.display = 'flex'; this.switchTab(this.tab); },
            closeModal() { document.getElementById('main-modal').style.display = 'none'; },
            
            showPhoto(src) { document.getElementById('photo-overlay-img').src = src; document.getElementById('photo-overlay').style.display = 'flex'; },
            
            updateAiButtonVisibility() { const btn = document.getElementById('btn-ai-nav'); if (btn) { if (state.settings.apiKey && state.settings.apiKey.trim() !== "") { btn.classList.remove('hidden'); } else { btn.classList.add('hidden'); } } },
            
            // --- NEW: Layers Menu Toggle ---
            toggleLayersMenu() {
                const menu = document.getElementById('layers-menu');
                if (menu.style.display === 'flex') {
                    menu.style.display = 'none';
                } else {
                    menu.style.display = 'flex';
                    this.renderLayersMenu();
                }
            },
            
            renderLayersMenu() {
                const menu = document.getElementById('layers-menu');
                const styles = [
                    { id: 'dark', label: 'Dark Matter (Dunkel)' },
                    { id: 'light', label: 'OpenStreetMap (Hell)' },
                    { id: 'sat', label: 'Satellit' }
                ];
                
                let html = '<div class="text-xs uppercase font-bold text-slate-500 px-3 py-2 border-b border-white/5">Kartenstil</div>';
                
                styles.forEach(s => {
                    const isActive = state.settings.mapStyle === s.id;
                    html += `
                        <button onclick="event.stopPropagation(); mapManager.setLayer('${s.id}'); ui.renderLayersMenu();" class="layer-btn ${isActive ? 'active' : ''}">
                            <span>${s.label}</span>
                            ${isActive ? '<i class="fas fa-check text-green-400"></i>' : ''}
                        </button>
                    `;
                });

                // Path Prediction Toggle (CPA Integrated)
                const ppActive = state.settings.showPathPrediction;
                const ppMin = state.settings.pathPredictionMinutes || 5;
                
                html += `
                    <div class="text-xs uppercase font-bold text-slate-500 px-3 py-2 border-b border-white/5 border-t mt-1">Tools</div>
                    <div class="p-3">
                        <div class="flex items-center justify-between mb-2">
                             <div class="flex flex-col">
                                <span class="text-sm text-slate-300">Vorausberechnung</span>
                                <span class="text-[10px] text-slate-500">Zeigt auch CPA-Punkt</span>
                             </div>
                             <label class="relative inline-flex items-center cursor-pointer" onclick="event.stopPropagation()">
                                <input type="checkbox" class="sr-only peer" ${ppActive ? 'checked' : ''} onchange="state.settings.showPathPrediction = this.checked; saveState(); ui.renderLayersMenu(); mapManager.update(simulation.getCurrentState());">
                                <div class="w-9 h-5 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-4 after:w-4 after:transition-all peer-checked:bg-pink-600"></div>
                             </label>
                        </div>
                        ${ppActive ? `
                            <div class="flex gap-2 mt-2 justify-end mb-2" onclick="event.stopPropagation()">
                               ${[5, 10, 15].map(m => {
                                   const active = ppMin === m ? 'bg-pink-600 text-white' : 'bg-slate-700 text-slate-300 hover:bg-slate-600';
                                   return `<button onclick="state.settings.pathPredictionMinutes=${m}; saveState(); ui.renderLayersMenu();" class="px-2 py-1 rounded text-xs ${active}">${m}m</button>`;
                               }).join('')}
                            </div>
                        ` : ''}
                    </div>
                `;
                
                if (state.kmlOverlays.length > 0) {
                    html += '<div class="text-xs uppercase font-bold text-slate-500 px-3 py-2 border-b border-white/5 border-t mt-1">Overlays</div>';
                    state.kmlOverlays.forEach(kml => {
                        html += `
                            <button onclick="event.stopPropagation(); ui.toggleKml('${kml.id}'); ui.renderLayersMenu();" class="layer-btn ${kml.visible ? 'active' : ''}">
                                <span class="truncate pr-2">${kml.name}</span>
                                <i class="fas ${kml.visible ? 'fa-eye text-blue-400' : 'fa-eye-slash text-slate-500'}"></i>
                            </button>
                        `;
                    });
                }
                
                menu.innerHTML = html;
            },

            switchTab(t) { 
                this.tab = t; 
                this.editingId = null; 
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.toggle('active', b.onclick.toString().includes(`'${t}'`))); 
                const mobileSelect = document.getElementById('mobile-tab-select'); if(mobileSelect) mobileSelect.value = t;
                this.render(); 
            },

            setFleetView(mode) { this.fleetMode = mode; this.render(); },

            render() { const c = document.getElementById('tab-content'); c.innerHTML = ''; if (this.editingId) { this.renderForm(c); return; } switch(this.tab) { case 'planning': this.viewPlanning(c); break; case 'fleet': this.viewFleet(c); break; case 'cylinders': this.viewCylinders(c); break; case 'passengers': this.viewPassengers(c); break; case 'logbook': this.viewLogbook(c); break; case 'settings': this.viewSettings(c); break; case 'environment': this.viewEnvironment(c); break; } },
            
            viewFleet(c) { 
                const isArchive = this.fleetMode === 'archive';
                const listTitle = isArchive ? 'Archivierte Ballone' : 'Aktive Flotte';
                const balloons = state.balloons.filter(b => !!b.archived === isArchive);

                c.innerHTML = `
                    <h3 class="text-xl font-bold mb-4">Ballon-Flotte</h3>
                    <div class="mb-4 glass-panel border border-white/10 p-4">
                        <div class="flex gap-4 border-b border-white/10 pb-2 mb-4 text-sm">
                            <button onclick="ui.setFleetView('active')" class="${!isArchive ? 'text-blue-400 font-bold border-b-2 border-blue-400' : 'text-slate-500 hover:text-slate-300'} pb-1 transition">Aktiv</button>
                            <button onclick="ui.setFleetView('archive')" class="${isArchive ? 'text-blue-400 font-bold border-b-2 border-blue-400' : 'text-slate-500 hover:text-slate-300'} pb-1 transition">Archiv</button>
                        </div>

                        <div class="flex justify-between items-center mb-4">
                            <h4 class="text-xs uppercase text-slate-400 font-bold">${listTitle}</h4>
                            <div class="flex gap-2">
                                <button onclick="document.getElementById('balloon-import-input').click()" class="bg-slate-700 px-3 py-1 rounded text-xs hover:bg-slate-600 transition" title="Ballon Importieren"><i class="fas fa-file-import"></i> Import</button>
                                ${!isArchive ? '<button onclick="ui.edit(\'new\')" class="bg-blue-600 px-4 py-2 rounded text-sm hover:bg-blue-500 transition">+ Ballon hinzufügen</button>' : ''}
                            </div>
                        </div>
                        
                        <div class="space-y-2">
                             ${balloons.length === 0 ? `<div class="text-center text-slate-500 italic py-4">Keine Einträge in dieser Liste</div>` : ''}
                             ${balloons.map(b => {
                                 const defaultCount = b.defaultCylinders ? b.defaultCylinders.length : 0;
                                 let cylWeight = 0;
                                 if (b.defaultCylinders && b.defaultCylinders.length > 0) {
                                     b.defaultCylinders.forEach(cId => {
                                         const cyl = state.cylinders.find(c => c.id === cId);
                                         if (cyl) cylWeight += (cyl.tare + cyl.gas);
                                     });
                                 }
                                 const startWeight = b.weight + cylWeight;
                                 
                                 return `
                                     <div class="glass-panel p-4 ${isArchive ? 'opacity-75' : ''}">
                                        <div class="flex justify-between items-center">
                                             <div>
                                                 <div class="font-bold text-lg text-white">${b.callsign}</div>
                                                 <div class="text-xs text-slate-400">${b.volume}m³ | Std-Flaschen: ${defaultCount} | MTOM: ${b.mtom}kg</div>
                                                 <div class="text-xs text-green-400 mt-1"><i class="fas fa-weight-hanging"></i> Startgewicht: ${Math.round(startWeight)} kg (inkl. ${Math.round(cylWeight)} kg Gas/Flaschen)</div>
                                             </div>
                                             <div class="flex gap-2">
                                                 <button onclick="ui.exportBalloon('${b.id}')" class="bg-slate-700/50 text-slate-300 px-3 py-1 rounded hover:bg-slate-700 transition" title="Exportieren"><i class="fas fa-file-export"></i></button>
                                                 ${!isArchive ? `<button onclick="ui.archiveBalloon('${b.id}')" class="bg-amber-900/30 text-amber-500 px-3 py-1 rounded hover:bg-amber-900/50 transition" title="Archivieren"><i class="fas fa-archive"></i></button><button onclick="ui.edit('${b.id}')" class="bg-slate-700 px-3 py-1 rounded hover:bg-slate-600 transition">Edit</button>` : `<button onclick="ui.restoreBalloon('${b.id}')" class="bg-green-900/30 text-green-500 px-3 py-1 rounded hover:bg-green-900/50 transition" title="Wiederherstellen"><i class="fas fa-trash-restore"></i></button>`}
                                                 <button onclick="ui.deleteBalloon('${b.id}')" class="text-red-400 p-1 hover:text-red-300 transition" title="Löschen"><i class="fas fa-trash"></i></button>
                                             </div>
                                        </div>
                                     </div>`;
                             }).join('')}
                        </div>
                    </div>
                `; 
            },
            viewCylinders(c) { 
                c.innerHTML = `
                    <div class="flex justify-between items-center mb-4">
                        <h3 class="text-xl font-bold">Gasflaschen-Inventar</h3>
                        <button onclick="ui.edit('new')" class="bg-blue-600 px-4 py-2 rounded text-sm">+ Flasche hinzufügen</button>
                    </div>`; 
                state.cylinders.forEach(cyl => { 
                    const isTuvExpired = new Date(cyl.tuv) < new Date(); 
                    c.innerHTML += `
                        <div class="glass-panel p-4 mb-2 flex justify-between items-center ${isTuvExpired ? 'border-red-500/50 border' : ''}">
                            <div>
                                <div class="font-bold">${cyl.label} (${cyl.type})</div>
                                <div class="text-xs text-slate-400">SN: ${cyl.sn} | Tara: ${cyl.tare}kg | Gas: ${cyl.gas}kg | TÜV: <span class="${isTuvExpired ? 'text-red-400 font-bold' : ''}">${cyl.tuv}</span></div>
                            </div>
                            <div class="flex gap-2">
                                <button onclick="ui.cloneCylinder('${cyl.id}')" class="bg-slate-700/50 text-slate-300 px-3 py-1 rounded hover:bg-slate-700" title="Klonen"><i class="fas fa-copy"></i></button>
                                <button onclick="ui.edit('${cyl.id}')" class="bg-slate-700 px-3 py-1 rounded">Edit</button>
                                <button onclick="ui.delete('cylinders','${cyl.id}')" class="text-red-400 p-1"><i class="fas fa-trash"></i></button>
                            </div>
                        </div>`; 
                }); 
            },
            
            cloneCylinder(id) {
                const original = state.cylinders.find(c => c.id === id);
                if (original) {
                    const newCyl = { ...original };
                    newCyl.id = Date.now().toString();
                    newCyl.label = original.label + " (Kopie)";
                    newCyl.sn = "";
                    state.cylinders.push(newCyl);
                    saveState();
                    this.render();
                    ui.showToast("Flasche geklont", "success");
                }
            },

            viewPassengers(c) { c.innerHTML = `<h3 class="text-xl font-bold mb-4">Passagier-Datenbank</h3><div class="mb-4 glass-panel border border-white/10 p-4"><div class="flex gap-4 border-b border-white/10 pb-2 mb-4 text-sm"><button onclick="ui.setPassengerView('active')" class="${this.passengerMode!=='archive'?'text-blue-400 font-bold border-b-2 border-blue-400':'text-slate-500'} pb-1 transition">Warteliste</button><button onclick="ui.setPassengerView('archive')" class="${this.passengerMode==='archive'?'text-blue-400 font-bold border-b-2 border-blue-400':'text-slate-500'} pb-1 transition">Archiv</button></div><div class="flex justify-between items-center mb-4"><h4 class="text-xs uppercase text-slate-400 font-bold">${this.passengerMode==='archive'?'Gäste-Archiv':'Warteliste'}</h4><button onclick="ui.edit('new')" class="bg-blue-600 px-4 py-2 rounded text-sm">+ Passagier hinzufügen</button></div><div class="space-y-2">${(this.passengerMode==='archive'?state.passengers.filter(p=>(p.flights||0)>0):state.passengers.filter(p=>!p.flights)).map(p=>`<div class="glass-panel p-4 flex justify-between items-center"><div><div class="font-bold">${p.firstName} ${p.lastName}</div><div class="text-xs text-slate-400">${p.weight}kg | ${p.gender}</div></div><div class="flex gap-2"><button onclick="ui.edit('${p.id}')" class="bg-slate-700 px-3 py-1 rounded">Edit</button></div></div>`).join('')}</div></div>`; },
            viewLogbook(c) { const logFlights = state.logs.length; const logDurationMs = state.logs.reduce((acc, log) => acc + (new Date(log.end) - new Date(log.start)), 0); const logHours = logDurationMs / 3600000; const totalFlights = (state.pilot.initialFlights || 0) + logFlights; const totalHoursDec = (state.pilot.initialHours || 0) + logHours; const tHrs = Math.floor(totalHoursDec); const tMins = Math.round((totalHoursDec - tHrs) * 60); const timeString = `${tHrs}h ${tMins.toString().padStart(2, '0')}m`; c.innerHTML = `<div class="flex justify-between items-center mb-4"><div><h3 class="text-xl font-bold">Fahrtenbuch</h3><div class="text-xs text-slate-400 mt-1">Gesamt: <span class="text-white font-bold">${totalFlights}</span> Fahrten | <span class="text-white font-bold">${timeString}</span></div></div><button onclick="ui.edit('new')" class="bg-blue-600 px-4 py-2 rounded text-sm">+ Manueller Eintrag</button></div>`; state.logs.sort((a,b)=>new Date(b.start)-new Date(a.start)).forEach(l => { const startStr = ui.formatTime(l.start); const endStr = ui.formatTime(l.end); c.innerHTML += `<div class="glass-panel p-4 mb-2 flex justify-between items-center"><div><div class="font-bold">${new Date(l.start).toLocaleDateString()} - ${l.balloon}</div><div class="text-xs text-slate-400">${startStr} bis ${endStr} | ${l.notes.substring(0,30)}...</div></div><div class="flex gap-2"><button onclick="ui.showSummary(${l.id})" class="text-blue-400 p-1"><i class="fas fa-eye"></i></button><button onclick="ui.delete('logs',${l.id})" class="text-red-400 p-1"><i class="fas fa-trash"></i></button></div></div>`; }); },
            viewPlanning(c) { if (!state.plannings) { state.plannings = []; saveState(); } if (!state.archive) { state.archive = []; saveState(); } const isArchive = this.planningMode === 'archive'; const listData = isArchive ? state.archive : state.plannings; c.innerHTML = `<h3 class="text-xl font-bold mb-4">Weight & Balance Planung</h3><div class="mb-6 p-4 glass-panel border border-white/10"><div class="flex gap-4 border-b border-white/10 pb-2 mb-2 text-sm"><button onclick="ui.setPlanView('active')" class="${!isArchive ? 'text-blue-400 font-bold border-b-2 border-blue-400' : 'text-slate-500 hover:text-slate-300'} pb-1 transition">Aktive Planungen</button><button onclick="ui.setPlanView('archive')" class="${isArchive ? 'text-blue-400 font-bold border-b-2 border-blue-400' : 'text-slate-500 hover:text-slate-300'} pb-1 transition">Archiv</button></div><div class="flex justify-between items-center mb-2"><h4 class="text-xs uppercase text-slate-400 font-bold">${isArchive ? 'Archiv / Vorlagen' : 'Aktive Planungen'}</h4>${!isArchive ? '<button onclick="ui.clearPlanForm()" class="text-xs bg-slate-700 px-3 py-1 rounded hover:bg-slate-600 transition">+ Neue Planung</button>' : ''}</div><div class="max-h-32 overflow-y-auto space-y-1" id="saved-plans-list">${listData.sort((a,b) => b.id - a.id).map(p => `<div class="flex justify-between items-center bg-slate-800 p-2 rounded text-xs group hover:bg-slate-700/50 transition"><div class="cursor-pointer flex-1" onclick="${isArchive ? `ui.loadTemplate('${p.id}')` : `ui.loadPlan('${p.id}')`}"><div class="font-bold text-white flex items-center gap-2">${isArchive ? '<i class="fas fa-history text-slate-500"></i>' : ''} ${p.name}</div><div class="text-slate-400 text-[10px]">${p.date} | ${p.balloonName}</div></div><div class="flex gap-1">${!isArchive ? `<button onclick="ui.archivePlan(${p.id})" class="text-blue-400 hover:text-blue-300 p-1 px-2 bg-slate-900/50 rounded"><i class="fas fa-box-archive"></i></button>` : `<button onclick="ui.unarchivePlan(${p.id})" class="text-green-400 hover:text-green-300 p-1 px-2 bg-slate-900/50 rounded"><i class="fas fa-box-open"></i></button>`}<button onclick="ui.delete('${isArchive ? 'archive' : 'plannings'}', ${p.id})" class="text-red-400 hover:text-red-300 p-1 px-2 bg-slate-900/50 rounded"><i class="fas fa-trash"></i></button></div></div>`).join('')}</div></div><div class="grid grid-cols-1 md:grid-cols-2 gap-6"><div class="space-y-4"><div><label>Bezeichnung der Planung</label><input type="text" id="plan-name" placeholder="z.B. Morgenfahrt Alpen" class="bg-slate-800 border-slate-600 focus:border-blue-500"></div><div><label>Ballon wählen</label><select id="plan-balloon" onchange="ui.selectBalloon()"><option value="">-- Wählen --</option>${state.balloons.map(b => `<option value="${b.id}">${b.callsign}</option>`).join('')}</select></div><div><label>Gasflaschen für diese Fahrt</label><div class="glass-panel p-3 border border-white/5 bg-slate-900/40"><div id="plan-cyl-list" class="space-y-2 mb-3"><div class="text-xs text-slate-500 italic">Keine Flaschen ausgewählt</div></div><div class="flex gap-2 pt-2 border-t border-white/10"><select id="plan-cyl-add-select" class="text-xs bg-slate-800 border-none w-full"><option value="">+ Flasche wählen</option>${state.cylinders.map(c => `<option value="${c.id}">${c.label} (${c.type}) - ${c.gas+c.tare}kg</option>`).join('')}</select><button onclick="ui.addPlanCylinder()" class="bg-blue-600 px-3 rounded text-xs hover:bg-blue-500 shrink-0"><i class="fas fa-plus"></i></button></div></div></div><div><label>Passagiere wählen</label><div class="grid grid-cols-1 sm:grid-cols-2 gap-2 max-h-40 overflow-y-auto p-2 border border-white/5 rounded" id="plan-pax">${state.passengers.sort((a,b) => (a.flights||0) - (b.flights||0)).map(p => { const isFlown = p.flights > 0; const badge = isFlown ? `<span class="text-green-400 text-[9px] ml-1">✓ ${p.flights}</span>` : ''; return `<label class="flex items-center gap-2 bg-slate-800 p-2 rounded text-[10px] hover:bg-slate-700 cursor-pointer ${isFlown ? 'opacity-75' : ''}"><input type="checkbox" value="${p.id}" onchange="ui.recalcWB()" class="w-4 h-4 shrink-0"> <span class="flex-1 truncate">${p.firstName} ${p.lastName}${badge}</span> <span class="text-slate-400">${p.weight}kg</span></label>`; }).join('')}</div></div></div><div class="space-y-4"><div class="grid grid-cols-1 sm:grid-cols-2 gap-2"><div><label>Startort Temp (°C)</label><input type="number" id="plan-temp" value="15" onchange="ui.recalcWB()"></div><div><label>Zielhöhe (m)</label><input type="number" id="plan-alt" value="1000" onchange="ui.recalcWB()"></div></div><div id="wb-result" class="glass-panel p-6 border-blue-500/30 border min-h-[200px] flex flex-col justify-center text-center"><div class="text-slate-500 italic">Bitte Ballon und Zuladung wählen...</div></div><button onclick="ui.savePlan()" id="btn-save-plan" class="bg-green-600 hover:bg-green-500 w-full py-3 rounded font-bold shadow-lg shadow-green-900/20 mt-4 transition transform active:scale-95 flex items-center justify-center gap-2"><i class="fas fa-save"></i> Planung Speichern</button></div></div>`; },
            
            viewSettings(c) { const initHrs = Math.floor(state.pilot.initialHours || 0); const initMins = Math.round(((state.pilot.initialHours || 0) - initHrs) * 60); const initTimeStr = `${initHrs}:${initMins.toString().padStart(2, '0')}`; 
                const offsetPercent = Math.round((state.settings.mapOffset || 0) * 100);
                
                c.innerHTML = `
                <div class="space-y-6">
                    <div class="bg-white/5 p-4 rounded-lg">
                        <h4 class="text-blue-400 font-bold mb-3 border-b border-white/10 pb-1">Pilot & Basisdaten</h4>
                        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                            <div><label>Name des Piloten</label><input type="text" id="set-pilot-name" value="${state.pilot.name}" onchange="ui.saveSettings(true)"></div>
                            <div class="grid grid-cols-2 gap-2">
                                <div><label>Gewicht (kg)</label><input type="number" id="set-pilot-weight" value="${state.pilot.weight}" onchange="ui.saveSettings(true)"></div>
                                <div class="col-span-1 grid grid-cols-2 gap-2">
                                    <div><label>Stunden</label><input type="text" id="set-pilot-hours" value="${initTimeStr}" placeholder="hh:mm" onchange="ui.saveSettings(true)"></div>
                                    <div><label>Fahrten</label><input type="number" id="set-pilot-flights" value="${state.pilot.initialFlights || 0}" onchange="ui.saveSettings(true)"></div>
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white/5 p-4 rounded-lg">
                        <h4 class="text-blue-400 font-bold mb-3 border-b border-white/10 pb-1">Anzeige & Einheiten</h4>
                        <div class="space-y-3">
                             <div class="flex items-center justify-between bg-black/20 p-2 rounded">
                                 <span class="text-sm" id="lbl-settings-mode">Betriebsmodus: <b>${state.settings.mode === 'gps' ? 'GPS LIVE' : 'SIMULATION'}</b></span>
                                 <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" id="set-mode-toggle" class="sr-only peer" ${state.settings.mode === 'gps' ? 'checked' : ''} onchange="ui.saveSettings(true)"><div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label>
                             </div>
                             <div class="flex items-center justify-between bg-black/20 p-2 rounded">
                                 <span class="text-sm">Zeiten in UTC anzeigen</span>
                                 <label class="relative inline-flex items-center cursor-pointer"><input type="checkbox" id="set-use-utc" class="sr-only peer" ${state.settings.useUTC ? 'checked' : ''} onchange="ui.saveSettings(true)"><div class="w-11 h-6 bg-slate-700 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div></label>
                             </div>
                             
                             <div class="mb-4 pt-2 border-t border-white/10">
                                <div class="flex justify-between text-sm mb-1">
                                    <span>Karten-Offset (Vorausschau)</span>
                                    <span class="font-bold text-blue-300" id="lbl-offset">${offsetPercent}%</span>
                                </div>
                                <input type="range" min="0" max="0.5" step="0.05" value="${state.settings.mapOffset}" 
                                    oninput="state.settings.mapOffset = parseFloat(this.value); document.getElementById('lbl-offset').innerText = Math.round(this.value*100) + '%'; saveState();">
                                <div class="text-[10px] text-slate-500 mt-1">Verschiebt die Karte entgegen der Flugrichtung.</div>
                            </div>
                            
                            <div class="mb-4 pt-2 border-t border-white/10">
                                <div class="flex justify-between text-sm mb-1">
                                    <span>Track-Stärke</span>
                                    <span class="font-bold text-blue-300" id="lbl-track-width">${state.settings.trackWidth}px</span>
                                </div>
                                <input type="range" min="1" max="10" step="1" value="${state.settings.trackWidth}" 
                                    oninput="state.settings.trackWidth = parseInt(this.value); document.getElementById('lbl-track-width').innerText = this.value + 'px'; ui.saveSettings(true);">
                            </div>

                             <div class="grid grid-cols-2 gap-2">
                                <div><label>Kartenstil</label><select id="set-map-style" onchange="ui.saveSettings(true)"><option value="dark" ${state.settings.mapStyle==='dark'?'selected':''}>Dark Matter (Dunkel)</option><option value="light" ${state.settings.mapStyle==='light'?'selected':''}>OpenStreetMap (Hell)</option><option value="sat" ${state.settings.mapStyle==='sat'?'selected':''}>Satellit</option></select></div>
                                <div><label>Track Farbe</label><input type="color" id="set-track-color" value="${state.settings.trackColor}" onchange="ui.saveSettings(true)"></div>
                                <!-- NEW Nav Color -->
                                <div><label>Nav-Linie Farbe</label><input type="color" id="set-nav-line-color" value="${state.settings.navLineColor || '#eab308'}" onchange="ui.saveSettings(true)"></div>
                             </div>
                             
                             <!-- Toast Timeout Setting -->
                             <div>
                                <label>Nachrichten automatisch löschen nach (Sekunden)</label>
                                <input type="number" id="set-toast-timeout" value="${state.settings.toastTimeout || 60}" onchange="ui.saveSettings(true)">
                             </div>
                        </div>
                    </div>
                    
                    <div class="bg-white/5 p-4 rounded-lg">
                        <div class="flex justify-between items-center mb-3 border-b border-white/10 pb-1">
                            <h4 class="text-amber-400 font-bold">KML Luftraum-Overlays</h4>
                            <button onclick="document.getElementById('kml-import-input').click()" class="bg-slate-700 hover:bg-slate-600 text-xs px-2 py-1 rounded"><i class="fas fa-upload"></i> KML hinzufügen</button>
                        </div>
                        
                        <div id="kml-list" class="space-y-2 max-h-40 overflow-y-auto">
                            ${state.kmlOverlays.length === 0 ? '<div class="text-xs text-slate-500 italic text-center">Keine Overlays geladen.</div>' : ''}
                            ${state.kmlOverlays.map(kml => `
                                <div class="kml-item ${kml.visible ? 'active' : ''}">
                                    <div class="flex-1 truncate text-sm font-medium text-white pr-2">${kml.name}</div>
                                    <div class="flex gap-2">
                                        <button onclick="ui.toggleKml('${kml.id}')" class="text-xs p-1 ${kml.visible ? 'text-green-400' : 'text-slate-500'} hover:text-white" title="An/Aus">
                                            <i class="fas ${kml.visible ? 'fa-eye' : 'fa-eye-slash'}"></i>
                                        </button>
                                        <button onclick="ui.deleteKml('${kml.id}')" class="text-xs p-1 text-red-400 hover:text-red-300" title="Löschen">
                                            <i class="fas fa-trash"></i>
                                        </button>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        <div class="text-[10px] text-slate-500 mt-2">Hinweis: Große KML-Dateien können den Speicher verlangsamen.</div>
                    </div>

                    <div class="bg-white/5 p-4 rounded-lg">
                        <h4 class="text-amber-400 font-bold mb-3 border-b border-white/10 pb-1">Speicher</h4>
                        <div class="space-y-3">
                            <div class="flex items-end gap-2">
                                <div class="flex-1">
                                    <label class="text-[10px]">Fotos aufbewahren (Tage)</label>
                                    <input type="number" id="set-image-retention" value="${state.settings.imageRetention || 30}" onchange="ui.saveSettings(true)" class="bg-slate-800 border border-slate-600 rounded p-2 text-sm w-full">
                                </div>
                                <button onclick="flightManager.cleanOldPhotosNow()" class="bg-amber-700/50 hover:bg-amber-600 text-amber-100 p-2 rounded text-sm mb-[1px]">Jetzt bereinigen</button>
                            </div>
                        </div>
                    </div>

                    <div class="bg-white/5 p-4 rounded-lg mt-4">
                        <h4 class="text-purple-400 font-bold mb-3 border-b border-white/10 pb-1">KI Konfiguration</h4>
                        <div class="space-y-3">
                            <div>
                                <label class="text-xs text-purple-200">Gemini API Key</label>
                                <input type="password" id="set-api-key" value="${state.settings.apiKey || ''}" placeholder="AI Key eingeben..." onchange="ui.saveSettings(true)" class="border-purple-500/30 focus:border-purple-500">
                            </div>
                            <div>
                                <label class="text-xs text-purple-200">Navigations-Strategie</label>
                                <select id="set-nav-mode" onchange="state.settings.navMode=this.value; saveState();" class="w-full bg-slate-800 border border-purple-500/30 rounded text-sm p-2 text-white focus:border-purple-500">
                                    <option value="direct" ${state.settings.navMode === 'direct' ? 'selected' : ''}>Direkt (Kürzester Weg)</option>
                                    <option value="predictive" ${state.settings.navMode === 'predictive' ? 'selected' : ''}>Vorausschauend (Vorhalten)</option>
                                </select>
                            </div>
                            <div class="flex items-end gap-2">
                                <div class="flex-1">
                                    <label class="text-[10px]">Max. Wörter (Taufname)</label>
                                    <input type="number" id="set-baptism-words" value="${state.settings.baptismMaxWords || 15}" onchange="ui.saveSettings(true)" class="bg-slate-800 border border-slate-600 rounded p-2 text-sm w-full">
                                </div>
                                <div class="flex-1">
                                    <label class="text-[10px]">Max. Wörter (Navi)</label>
                                    <input type="number" id="set-ai-max-words" value="${state.settings.aiMaxWords || 10}" onchange="ui.saveSettings(true)" class="bg-slate-800 border border-slate-600 rounded p-2 text-sm w-full">
                                </div>
                            </div>
                        </div>
                    </div>

                    <div class="bg-red-900/10 border border-red-900/30 p-4 rounded-lg mt-8">
                        <h4 class="text-red-400 font-bold mb-3 text-sm uppercase">System & Daten (Gefahrenzone)</h4>
                        <div class="flex flex-col gap-2">
                            <button onclick="system.exportData()" class="bg-slate-800 hover:bg-slate-700 py-2 rounded text-sm border border-white/10">Backup erstellen (Export)</button>
                            <button onclick="system.triggerImport()" class="bg-slate-800 hover:bg-slate-700 py-2 rounded text-sm border border-white/10 text-blue-200">Backup wiederherstellen (Import)</button>
                            <button onclick="system.resetData()" class="bg-red-900/40 hover:bg-red-900/60 text-red-200 py-2 rounded text-sm mt-2 border border-red-500/30">Werkseinstellungen (Reset)</button>
                        </div>
                    </div>
                </div>`; 
            },
            
            viewEnvironment(c) { c.innerHTML = `
                <h3 class="text-xl font-bold mb-4">Wind Simulation</h3>
                <div class="glass-panel p-6 border-white/10 border">
                    <div class="flex justify-between items-start mb-4">
                        <p class="text-sm text-slate-400">Hier definierst du die Windschichten für die Simulation. Der Ballon bewegt sich basierend auf der aktuellen Höhe und diesen Werten.</p>
                        <button onclick="weatherService.fetchLiveWind()" class="bg-green-600/20 text-green-400 border border-green-500/50 px-3 py-1 rounded text-xs whitespace-nowrap hover:bg-green-600 hover:text-white transition"><i class="fas fa-satellite-dish mr-1"></i> Live-Daten laden</button>
                    </div>
                    
                    <div class="grid grid-cols-2 gap-4 mb-6 pb-6 border-b border-white/10">
                         <div>
                            <label class="text-xs uppercase text-blue-300 font-bold mb-1">Mess-Intervall (Höhe)</label>
                            <div class="flex items-center gap-1">
                                <input type="number" id="set-wind-interval" value="${state.settings.windMeasInterval || 50}" onchange="state.settings.windMeasInterval = parseInt(this.value); saveState();" class="bg-slate-800 border border-slate-600 rounded p-2 text-sm w-full">
                                <span class="text-xs text-slate-500">m</span>
                            </div>
                        </div>
                        <div>
                            <label class="text-xs uppercase text-blue-300 font-bold mb-1">Mess-Abweichung (Min)</label>
                            <div class="flex items-center gap-1">
                                <input type="number" id="set-wind-threshold" value="${state.settings.windThreshold || 5}" onchange="state.settings.windThreshold = parseInt(this.value); saveState();" class="bg-slate-800 border border-slate-600 rounded p-2 text-sm w-full">
                                <span class="text-xs text-slate-500">°</span>
                            </div>
                        </div>
                    </div>

                    <div class="grid grid-cols-4 gap-2 text-xs uppercase text-slate-500 font-bold mb-2"><div>Höhe (m)</div><div>Richtung (°)</div><div>Speed (kt)</div><div></div></div>
                    <div id="wind-rows" class="space-y-2 mb-4">${state.windLayers.sort((a,b)=>a.alt-b.alt).map((w, idx) => `<div class="grid grid-cols-4 gap-2 items-center"><input type="number" class="wind-edit-alt" value="${w.alt}" placeholder="Höhe"><input type="number" class="wind-edit-dir" value="${w.dir}" placeholder="Dir"><input type="number" class="wind-edit-spd" value="${w.speed}" placeholder="Knots"><button onclick="ui.removeWindLayer(${idx})" class="text-red-400 hover:text-red-300"><i class="fas fa-trash"></i></button></div>`).join('')}</div>
                    <button onclick="ui.addWindLayer()" class="bg-slate-700 px-4 py-2 rounded text-xs mb-6">+ Schicht hinzufügen</button>
                    <button onclick="ui.saveEnvironment()" class="bg-blue-600 w-full py-3 rounded font-bold shadow-lg">Wetterdaten Speichern</button>
                    
                    <p class="text-[10px] text-slate-500 mt-4 text-center">Live-Daten bereitgestellt durch Open-Meteo.com (Kein Key erforderlich)</p>
                </div>`; 
            },
            
            // --- WIND FILTER LOGIC ---
            renderWind() { 
                const container = document.getElementById('wind-layers-container'); 
                container.innerHTML = ''; 
                
                const isKmh = state.settings.unitSpeed === 'kmh';
                const unitLabel = isKmh ? 'km/h' : 'kt';
                const threshold = state.settings.windThreshold || 5;

                const layerMap = new Map();
                
                state.windLayers.forEach(l => layerMap.set(l.alt, { ...l, isMeasured: false }));
                
                if (state.measuredWindLayers) {
                    state.measuredWindLayers.forEach(l => layerMap.set(l.alt, { ...l, isMeasured: true, isManual: l.isManual }));
                }

                const sortedLayers = Array.from(layerMap.values()).sort((a, b) => b.alt - a.alt);

                let lastKeptDir = null;
                
                sortedLayers.forEach((layer, index) => {
                    let keep = false;
                    
                    if (index === 0) keep = true;
                    else if (layer.isMeasured) keep = true;
                    else {
                        if (lastKeptDir === null) {
                            keep = true;
                        } else {
                            let diff = Math.abs(layer.dir - lastKeptDir);
                            if (diff > 180) diff = 360 - diff;
                            if (diff >= threshold) keep = true;
                        }
                    }

                    if (keep) {
                        let speed = layer.speed;
                        if (isKmh) speed *= 1.852; 

                        const colorClass = layer.isMeasured ? (layer.isManual ? 'text-amber-400 font-bold' : 'text-green-400 font-bold') : 'text-blue-300';
                        const arrowClass = layer.isMeasured ? (layer.isManual ? 'text-amber-400' : 'text-green-400') : 'text-blue-400';
                        const iconHtml = layer.isMeasured ? (layer.isManual ? '<i class="fas fa-headset text-[8px] text-amber-500"></i>' : '<i class="fas fa-wifi text-[8px] text-green-500"></i>') : '';

                        // HIGHLIGHT CURRENT ALTITUDE
                        const isCurrentAlt = Math.abs(layer.alt - simulation.alt) < 25;
                        const activeClass = isCurrentAlt ? 'active-altitude' : 'bg-slate-800/40';
                        
                        // Direction calculations
                        const windFrom = Math.round(layer.dir);
                        const windTo = (windFrom + 180) % 360;

                        const div = document.createElement('div'); 
                        div.className = `wind-layer p-1 mb-1 rounded flex flex-col items-center justify-center transition-all ${activeClass}`; 
                        div.dataset.alt = layer.alt;
                        
                        // New Vertical Stack Layout
                        div.innerHTML = `
                            <div class="text-center w-full">
                                <!-- Altitude Row -->
                                <div class="font-bold text-xs text-white border-b border-white/10 pb-0.5 mb-1 flex justify-center items-center gap-1">
                                    ${layer.alt}m ${iconHtml}
                                </div>
                                
                                <!-- Direction Row -->
                                <div class="flex items-center justify-center gap-1 mb-0.5">
                                     <div class="w-5 h-5 rounded-full bg-white/5 flex items-center justify-center">
                                        <i class="fas fa-long-arrow-alt-up ${arrowClass}" style="transform: rotate(${windTo}deg); font-size: 0.7rem;"></i>
                                     </div>
                                     <span class="text-[0.65rem] font-mono text-slate-300">${windFrom}°</span>
                                </div>
                                
                                <!-- Speed Row -->
                                <div class="text-[0.7rem] font-bold ${colorClass}">${speed.toFixed(1)} <span class="text-[0.6rem] font-normal text-slate-400">${unitLabel}</span></div>
                            </div>
                        `;
                        container.appendChild(div);
                        
                        lastKeptDir = layer.dir;
                    }
                });
            },
            
            toggleManualWindModal(show) {
                const modal = document.getElementById('manual-wind-overlay');
                if(show) {
                    modal.classList.remove('hidden');
                    // Pre-fill alt roughly
                    document.getElementById('manual-wind-alt').value = Math.round(simulation.alt);
                } else {
                    modal.classList.add('hidden');
                }
            },

            saveManualWind() {
                const alt = parseInt(document.getElementById('manual-wind-alt').value);
                const dirInput = parseInt(document.getElementById('manual-wind-dir').value);
                const spd = parseFloat(document.getElementById('manual-wind-spd').value);

                if (isNaN(alt) || isNaN(dirInput) || isNaN(spd)) {
                    ui.showToast("Bitte gültige Zahlen eingeben", "error");
                    return;
                }

                // Convert Input (Track/Direction of other pilot) to Wind Source (From)
                // If Pilot drives East (90), Wind comes from West (270).
                const windFrom = (dirInput + 180) % 360;

                // Create new layer
                const newLayer = {
                    alt: alt,
                    dir: windFrom,
                    speed: spd, 
                    isMeasured: true,
                    isManual: true, // Mark as manual entry
                    timestamp: Date.now()
                };

                // Add to measured layers
                // Check if layer exists nearby
                const existingIdx = state.measuredWindLayers.findIndex(l => Math.abs(l.alt - alt) < 25); // 25m tolerance
                
                if (existingIdx >= 0) {
                    state.measuredWindLayers[existingIdx] = newLayer;
                } else {
                    state.measuredWindLayers.push(newLayer);
                }
                
                // Sort
                state.measuredWindLayers.sort((a,b) => a.alt - b.alt);

                ui.toggleManualWindModal(false);
                ui.renderWind();
                ui.showToast("Winddaten manuell hinzugefügt", "success");
                
                // Trigger route recalculation if active
                if(localNavService.isActive) localNavService.update();
            },
            
            addWindLayer() { const container = document.getElementById('wind-rows'); const div = document.createElement('div'); div.className = "grid grid-cols-4 gap-2 items-center"; div.innerHTML = `<input type="number" class="wind-edit-alt" value="0" placeholder="Höhe"><input type="number" class="wind-edit-dir" value="0" placeholder="Dir"><input type="number" class="wind-edit-spd" value="0" placeholder="Knots"><button onclick="this.parentElement.remove()" class="text-red-400 hover:text-red-300"><i class="fas fa-trash"></i></button>`; container.appendChild(div); },
            removeWindLayer(idx) { state.windLayers.splice(idx, 1); this.render(); },
            saveEnvironment() { const newLayers = []; const rows = document.querySelectorAll('#wind-rows > div'); rows.forEach(row => { const alt = parseFloat(row.querySelector('.wind-edit-alt').value); const dir = parseFloat(row.querySelector('.wind-edit-dir').value); const spd = parseFloat(row.querySelector('.wind-edit-spd').value); if (!isNaN(alt)) { newLayers.push({ alt, dir, speed: spd }); } }); state.windLayers = newLayers; saveState(); this.renderWind(); ui.showToast("Wetterdaten gespeichert!", "success"); },
            
            // --- HELPER FUNCTIONS ---
            selectBalloon() { const bId = document.getElementById('plan-balloon').value; const list = document.getElementById('plan-cyl-list'); list.innerHTML = ''; if (!bId) { list.innerHTML = '<div class="text-xs text-slate-500 italic">Keine Flaschen ausgewählt</div>'; return; } const b = state.balloons.find(x => x.id === bId); if (b.defaultCylinders && b.defaultCylinders.length > 0) { b.defaultCylinders.forEach(id => { this.addPlanCylinder(id); }); } else { list.innerHTML = '<div class="text-xs text-slate-500 italic">Keine Standard-Flaschen definiert</div>'; } this.recalcWB(); },
            
            recalcWB() {
                const bId = document.getElementById('plan-balloon').value;
                if (!bId) return;
                const b = state.balloons.find(x => x.id === bId);
                const temp = parseFloat(document.getElementById('plan-temp').value);
                const alt = parseFloat(document.getElementById('plan-alt').value);
                
                const selectedCylIds = [];
                document.querySelectorAll('.plan-cyl-item').forEach(el => selectedCylIds.push(el.dataset.pid));
                const selectedCyls = selectedCylIds.map(id => state.cylinders.find(c => c.id === id)).filter(Boolean);
                const selectedPax = Array.from(document.querySelectorAll('#plan-pax input:checked')).map(i => state.passengers.find(p => p.id === i.value));
                
                const totalCylWeight = selectedCyls.reduce((sum, c) => sum + c.tare + c.gas, 0);
                const totalPaxWeight = selectedPax.reduce((sum, p) => sum + p.weight, 0);
                const totalWeight = b.weight + state.pilot.weight + totalCylWeight + totalPaxWeight;

                const altSteps = [0, 1000, 2000, 3000];
                const tempSteps = [0, 15, 30];
                const cAlt = Math.max(0, Math.min(3000, alt));
                const cTemp = Math.max(0, Math.min(30, temp));
                let i = 0; while (i < altSteps.length - 2 && cAlt > altSteps[i+1]) i++;
                let j = 0; while (j < tempSteps.length - 2 && cTemp > tempSteps[j+1]) j++;
                const rAlt = (cAlt - altSteps[i]) / (altSteps[i+1] - altSteps[i]);
                const rTemp = (cTemp - tempSteps[j]) / (tempSteps[j+1] - tempSteps[j]);
                const q11 = b.matrix[i][j]; const q12 = b.matrix[i][j+1]; const q21 = b.matrix[i+1][j]; const q22 = b.matrix[i+1][j+1];
                const r1 = q11 + (q12 - q11) * rTemp; const r2 = q21 + (q22 - q21) * rTemp;
                const liftFactor = r1 + (r2 - r1) * rAlt;
                const maxLift = b.volume * liftFactor;

                const res = document.getElementById('wb-result');
                const isOverLift = totalWeight > maxLift;

                res.innerHTML = `
                    <div class="text-lg font-bold mb-4">Analyse für ${b.callsign}</div>
                    <div class="space-y-1 text-sm text-left max-w-xs mx-auto mb-4">
                        <div class="flex justify-between"><span>Ballon leer:</span> <span>${b.weight} kg</span></div>
                        <div class="flex justify-between"><span>Pilot:</span> <span>${state.pilot.weight} kg</span></div>
                        <div class="flex justify-between"><span>Passagiere:</span> <span>${totalPaxWeight} kg</span></div>
                        <div class="flex justify-between"><span>Gasflaschen (${selectedCyls.length}):</span> <span>${totalCylWeight} kg</span></div>
                        <hr class="border-white/10 my-1">
                        <div class="flex justify-between font-bold text-lg"><span>Gesamt:</span> <span>${Math.round(totalWeight)} kg</span></div>
                    </div>
                    <div class="flex justify-center text-xs">
                         <div class="p-2 rounded w-full max-w-[200px] text-center ${isOverLift ? 'bg-red-900/40 text-red-300 border border-red-500/50' : 'bg-green-900/40 text-green-300 border border-green-500/50'}">
                            TRAGKRAFT: ${Math.round(maxLift)}kg<br><b>${isOverLift ? 'ZU SCHWER' : 'OK'}</b>
                         </div>
                    </div>
                    <div class="mt-4 text-xs italic text-slate-500">Berechnet für ${cAlt}m AMSL bei ${cTemp}°C<br>(Tragkraftfaktor: ${liftFactor.toFixed(4)} kg/m³)</div>
                `;
            },
            
            showStartDialog() {
                const c = document.getElementById('tab-content');
                document.getElementById('main-modal').style.display = 'flex';
                document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
                
                // Get all balloons for dropdown
                const balloonOptions = state.balloons.map(b => 
                    `<option value="${b.id}">${b.callsign}</option>`
                ).join('');

                c.innerHTML = `
                    <h3 class="text-2xl font-bold mb-6 text-center">Fahrt Starten</h3>
                    <div class="grid gap-4 max-w-md mx-auto">
                        <div class="bg-slate-800 p-4 rounded-xl shadow-lg border border-white/10">
                            <h4 class="font-bold text-slate-300 mb-2 text-sm uppercase">Spontanfahrt</h4>
                            <div class="mb-4">
                                <label class="text-xs text-slate-400 block mb-1">Ballon wählen</label>
                                <select id="spontan-balloon-select" class="w-full bg-slate-700 border border-white/10 rounded p-2 text-white text-sm">
                                    ${state.balloons.length === 0 ? '<option value="">Keine Ballone verfügbar</option>' : balloonOptions}
                                </select>
                            </div>
                            <button onclick="flightManager.startRecording(null, document.getElementById('spontan-balloon-select').value)" class="w-full bg-blue-600 hover:bg-blue-500 py-3 rounded-lg font-bold text-lg shadow-lg flex items-center justify-center gap-2 transition active:scale-95">
                                <i class="fas fa-play"></i> Starten
                            </button>
                        </div>
                        
                        <div class="text-center text-slate-500 text-xs my-2">- ODER GEPLANTE FAHRT WÄHLEN -</div>
                        
                        <div class="space-y-2 max-h-60 overflow-y-auto">
                            ${state.plannings.length === 0 ? '<div class="text-center text-slate-500 italic">Keine aktiven Planungen vorhanden</div>' : 
                                state.plannings.map(p => `
                                    <button onclick="flightManager.startRecording('${p.id}')" class="w-full bg-slate-800 hover:bg-slate-700 p-3 rounded-lg flex justify-between items-center text-left border border-white/5 transition active:scale-95">
                                        <div>
                                            <div class="font-bold text-white">${p.name}</div>
                                            <div class="text-xs text-slate-400">${p.date} | ${p.balloonName}</div>
                                        </div>
                                        <i class="fas fa-chevron-right text-slate-500"></i>
                                    </button>
                                `).join('')
                            }
                        </div>
                    </div>
                `;
            },

            addPlanCylinder(idOverride) { const sel = document.getElementById('plan-cyl-add-select'); const id = idOverride || sel.value; if (!id) return; const list = document.getElementById('plan-cyl-list'); if (list.querySelector(`[data-pid="${id}"]`)) return; if(list.innerHTML.includes('Keine Flaschen')) list.innerHTML = ''; const cyl = state.cylinders.find(c => c.id === id); const div = document.createElement('div'); div.className = "flex justify-between items-center bg-slate-800 p-2 rounded mb-1 text-xs plan-cyl-item"; div.setAttribute('data-pid', id); div.innerHTML = `<div><div class="font-bold">${cyl.label}</div><div class="text-slate-400 text-[10px]">Total: ${cyl.gas+cyl.tare}kg</div></div><button onclick="ui.removePlanCylinder(this)" class="text-red-400 hover:text-red-300 px-2"><i class="fas fa-trash-alt"></i></button>`; list.appendChild(div); if (!idOverride) this.recalcWB(); },
            removePlanCylinder(btn) { btn.parentElement.remove(); this.recalcWB(); },

            clearPlanForm() {
                this.editingPlanId = null; // Reset to new mode

                // Reset to default empty state
                document.getElementById('plan-balloon').value = "";
                document.getElementById('plan-name').value = "";
                document.getElementById('plan-temp').value = "15";
                document.getElementById('plan-alt').value = "1000";
                
                document.getElementById('plan-cyl-list').innerHTML = '<div class="text-xs text-slate-500 italic">Keine Flaschen ausgewählt</div>';
                document.querySelectorAll('#plan-pax input').forEach(cb => cb.checked = false);
                document.getElementById('wb-result').innerHTML = '<div class="text-slate-500 italic">Bitte Ballon und Zuladung wählen...</div>';

                // Reset Button Text
                const btn = document.getElementById('btn-save-plan');
                if(btn) { btn.innerHTML = '<i class="fas fa-save"></i> Planung Speichern'; btn.className = btn.className.replace('bg-blue-600', 'bg-green-600'); }
            },
            
            _fillPlanForm(plan) {
                // Set Balloon
                document.getElementById('plan-balloon').value = plan.balloonId;
                document.getElementById('plan-name').value = plan.name;
                document.getElementById('plan-temp').value = plan.temp;
                document.getElementById('plan-alt').value = plan.alt;

                // Clear current cylinders list visual
                const list = document.getElementById('plan-cyl-list');
                list.innerHTML = '';
                
                // Add cylinders from plan
                if (plan.cylinders && plan.cylinders.length > 0) {
                    plan.cylinders.forEach(cylId => this.addPlanCylinder(cylId));
                } else {
                    list.innerHTML = '<div class="text-xs text-slate-500 italic">Keine Flaschen ausgewählt</div>';
                }

                // Check passengers
                document.querySelectorAll('#plan-pax input').forEach(cb => {
                    cb.checked = plan.passengers.includes(cb.value);
                });

                this.recalcWB();
            },

            loadPlan(id) {
                const plan = state.plannings.find(p => p.id == id);
                if(!plan) return;
                this._fillPlanForm(plan);
                this.editingPlanId = plan.id; // Set edit mode (Update)
                
                const btn = document.getElementById('btn-save-plan');
                if(btn) { btn.innerHTML = '<i class="fas fa-pen"></i> Änderung Speichern'; btn.className = btn.className.replace('bg-green-600', 'bg-blue-600'); }
            },

            loadTemplate(id) {
                const plan = state.archive.find(p => p.id == id);
                if(!plan) return;
                this._fillPlanForm(plan);
                this.editingPlanId = null; // New Mode (Create copy)
                
                // Pre-fill name with "Kopie von..." to indicate template usage
                document.getElementById('plan-name').value = `${plan.name} (Kopie)`;
                
                const btn = document.getElementById('btn-save-plan');
                if(btn) { btn.innerHTML = '<i class="fas fa-save"></i> Als neue Planung Speichern'; btn.className = btn.className.replace('bg-blue-600', 'bg-green-600'); }
            },

            showSelectionModal(title, items, onSelect) {
                const overlay = document.getElementById('selection-overlay');
                const titleEl = document.getElementById('sel-title');
                const contentEl = document.getElementById('sel-content');
                
                titleEl.innerText = title;
                contentEl.innerHTML = '';
                
                if (items.length === 0) {
                    contentEl.innerHTML = '<div class="text-slate-400 text-center italic p-4">Keine Einträge verfügbar</div>';
                } else {
                    items.forEach((item) => {
                        const btn = document.createElement('button');
                        btn.className = "w-full text-left bg-slate-800 hover:bg-slate-700 p-3 rounded mb-1 flex justify-between items-center transition";
                        btn.innerHTML = `<div><div class="font-bold text-white">${item.main}</div><div class="text-xs text-slate-400">${item.sub}</div></div><i class="fas fa-plus text-slate-500"></i>`;
                        btn.onclick = () => {
                            onSelect(item.id);
                            overlay.style.display = 'none';
                        };
                        contentEl.appendChild(btn);
                    });
                }
                
                overlay.style.display = 'flex';
            },

            addLogCylinder(logId) {
                const log = state.logs.find(l => l.id == logId);
                if(!log) return;
                
                // Prepare items
                const items = state.cylinders.map(c => ({
                    id: c.id,
                    main: c.label,
                    sub: `${c.type} | ${c.gas + c.tare}kg`
                }));
                
                this.showSelectionModal("Gasflasche hinzufügen", items, (selectedId) => {
                    log.cylinders.push(selectedId);
                    saveState();
                    this.showSummary(logId, true); // Refresh
                    this.showToast("Flasche hinzugefügt");
                });
            },

            addLogPassenger(logId) {
                const log = state.logs.find(l => l.id == logId);
                if(!log) return;
                
                // Filter passengers not already in log
                const available = state.passengers.filter(p => !log.pax.includes(p.id));
                
                if(available.length === 0) {
                    this.showToast("Alle Passagiere bereits an Bord", "error");
                    return;
                }
                
                const items = available.map(p => ({
                    id: p.id,
                    main: `${p.firstName} ${p.lastName}`,
                    sub: `${p.weight}kg | ${p.flights || 0} Fahrten`
                }));
                
                this.showSelectionModal("Passagier hinzufügen", items, (selectedId) => {
                    const p = state.passengers.find(px => px.id === selectedId);
                    if (p) {
                        log.pax.push(p.id);
                        
                        // Update Stats
                        p.flights = (p.flights || 0) + 1;
                        const logDate = new Date(log.start);
                        const pDate = p.lastFlight ? new Date(p.lastFlight) : new Date(0);
                        if (logDate > pDate) {
                            p.lastFlight = log.start;
                        }
                        
                        saveState();
                        this.showSummary(logId, true); // Refresh UI
                        this.showToast(`${p.firstName} hinzugefügt`);
                    }
                });
            },
            
            removeLogPassenger(logId, paxId) {
                const log = state.logs.find(l => l.id == logId);
                if(!log) return;
                
                log.pax = log.pax.filter(id => id !== paxId);
                
                // Update Stats (decrement)
                const p = state.passengers.find(px => px.id == paxId);
                if(p) {
                    p.flights = Math.max(0, (p.flights || 1) - 1);
                }
                
                saveState();
                this.showSummary(logId, true);
                this.showToast("Passagier entfernt");
            },

            saveSummaryChanges(logId) {
                const log = state.logs.find(l => l.id == logId);
                if (log) {
                    log.startLoc = document.getElementById('sum-start').value;
                    log.endLoc = document.getElementById('sum-end').value;
                    log.notes = document.getElementById('sum-notes').value;
                    
                    // Save baptism names
                    log.pax.forEach(pid => {
                        const input = document.getElementById(`bapt-name-${pid}`);
                        if(input) {
                            const p = state.passengers.find(px => px.id == pid);
                            if(p && input.value.trim() !== "") {
                                p.baptism = true;
                                p.baptismName = input.value.trim();
                            }
                        }
                    });

                    saveState();
                    this.showSummary(logId, false); // Switch to read mode
                    ui.showToast("Änderungen gespeichert");
                }
            },
            
            archivePlanFromSummary(planId, btn) {
                this.archivePlan(planId);
                btn.remove();
                ui.showToast("Planung archiviert");
            },
            
            exportGPX(logId) {
                const log = state.logs.find(l => l.id == logId);
                if (!log || !log.track || log.track.length === 0) { ui.showToast("Kein Track vorhanden!", "error"); return; }
                
                let gpx = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1" creator="AeroNav">
  <trk>
    <name>Flight ${new Date(log.start).toLocaleDateString()}</name>
    <trkseg>`;
   
                log.track.forEach(pt => {
                    // pt[0]: lat, pt[1]: lng, pt[2]: alt
                    // Ensure altitude is formatted correctly
                    const ele = pt[2] !== undefined ? pt[2].toFixed(1) : 0;
                    gpx += `\n      <trkpt lat="${pt[0]}" lon="${pt[1]}"><ele>${ele}</ele></trkpt>`;
                });
                
                gpx += `\n    </trkseg>\n  </trk>\n</gpx>`;
                
                const blob = new Blob([gpx], {type: 'application/gpx+xml'});
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `flight-${logId}.gpx`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
            },

            generateReportImage(logId) {
                const log = state.logs.find(l => l.id == logId);
                if (!log) return;
                
                const loader = document.getElementById('loading-overlay');
                loader.classList.remove('hidden');
                
                const stage = document.getElementById('report-stage');
                // Ensure stage is visible to renderer but offscreen
                // Changed from display: block/none to visibility to keep layout flow for html2canvas
                // Positioned at 0,0 with negative z-index to be "behind" everything but technically in view
                stage.style.visibility = 'visible';
                stage.style.zIndex = '-5000';
                stage.style.top = '0';
                stage.style.left = '0';
                stage.style.position = 'fixed';
                
                // Data prep
                const balloon = state.balloons.find(b => b.callsign === log.balloon);
                const balloonImg = balloon ? balloon.image : null;
                const durMs = new Date(log.end) - new Date(log.start);
                const hrs = Math.floor(durMs / 3600000);
                const mins = Math.floor((durMs % 3600000) / 60000);
                const dateStr = new Date(log.start).toLocaleDateString('de-DE', { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' });
                
                // Passenger List for Report (Names only)
                const paxListHtml = log.pax.map(pid => {
                    const p = state.passengers.find(px => px.id == pid);
                    if (!p) return '';
                    const baptism = p.baptismName ? `<div class="text-[10px] text-amber-400 italic font-serif mt-0.5">${p.baptismName}</div>` : '';
                    return `<div class="bg-white/5 p-2 rounded text-sm text-slate-300"><div>${p.firstName} ${p.lastName}</div>${baptism}</div>`;
                }).join('');

                // Photos Grid for Report
                let photosHtml = '';
                if (log.photos && log.photos.length > 0) {
                    photosHtml = `
                        <div class="mt-8">
                            <h4 class="text-slate-500 text-xs uppercase mb-2">Impressionen</h4>
                            <div class="grid grid-cols-4 gap-2">
                                ${log.photos.slice(0, 4).map(p => `
                                    <div class="aspect-square bg-cover bg-center rounded-lg border border-white/10" style="background-image: url('${p.src}')"></div>
                                `).join('')}
                            </div>
                        </div>
                    `;
                }

                // HTML Structure for Report
                stage.innerHTML = `
                    <div class="border border-white/20 rounded-xl overflow-hidden bg-slate-900 shadow-2xl relative w-[800px]">
                        <!-- Header Banner -->
                        <div class="h-40 relative bg-slate-800 overflow-hidden">
                            ${balloonImg ? `<div class="absolute inset-0 bg-cover bg-center opacity-60" style="background-image: url('${balloonImg}')"></div>` : `<div class="absolute inset-0 bg-gradient-to-r from-blue-900 to-slate-900"></div>`}
                            <div class="absolute inset-0 bg-gradient-to-t from-slate-900 via-transparent to-transparent"></div>
                            <div class="absolute bottom-6 left-8">
                                <h1 class="text-4xl font-bold text-white mb-1">Flight Report</h1>
                                <div class="text-blue-300 text-lg font-mono">${log.balloon} | ${dateStr}</div>
                            </div>
                            <div class="absolute top-6 right-8 text-right">
                                <div class="text-white/50 text-xs uppercase tracking-widest">BallonNav Pilot</div>
                                <div class="text-white font-bold text-xl">${state.pilot.name}</div>
                            </div>
                        </div>
                        
                        <div class="p-8">
                            <!-- Stats Grid -->
                            <div class="grid grid-cols-4 gap-4 mb-8">
                                <div class="bg-white/5 p-4 rounded-lg text-center border border-white/5">
                                    <div class="text-slate-400 text-xs uppercase">Dauer</div>
                                    <div class="text-2xl font-bold text-white">${hrs}h ${mins}m</div>
                                </div>
                                <div class="bg-white/5 p-4 rounded-lg text-center border border-white/5">
                                    <div class="text-slate-400 text-xs uppercase">Max Höhe</div>
                                    <div class="text-2xl font-bold text-blue-400">${Math.round(log.maxAlt || 0)} m</div>
                                </div>
                                <div class="bg-white/5 p-4 rounded-lg text-center border border-white/5">
                                    <div class="text-slate-400 text-xs uppercase">Max Speed</div>
                                    <div class="text-2xl font-bold text-yellow-400">${Math.round(log.maxSpeed || 0)} km/h</div>
                                </div>
                                <div class="bg-white/5 p-4 rounded-lg text-center border border-white/5">
                                    <div class="text-slate-400 text-xs uppercase">Passagiere</div>
                                    <div class="text-2xl font-bold text-green-400">${log.pax.length}</div>
                                </div>
                            </div>

                            <!-- Locations -->
                            <div class="flex justify-between items-center mb-8 px-4 py-4 bg-white/5 rounded-lg border border-white/5">
                                <div>
                                    <div class="text-slate-500 text-xs uppercase mb-1">Start</div>
                                    <div class="text-white font-bold text-lg leading-tight">${log.startLoc || 'Unbekannt'}</div>
                                    <div class="text-slate-600 text-xs mt-1">${ui.formatTime(log.start)}</div>
                                </div>
                                <div class="text-slate-600"><i class="fas fa-arrow-right"></i></div>
                                <div class="text-right">
                                    <div class="text-slate-500 text-xs uppercase mb-1">Landung</div>
                                    <div class="text-white font-bold text-lg leading-tight">${log.endLoc || 'Unbekannt'}</div>
                                    <div class="text-slate-600 text-xs mt-1">${ui.formatTime(log.end)}</div>
                                </div>
                            </div>
                            
                            <!-- Notes & Passengers -->
                            <div class="grid grid-cols-2 gap-6 mb-8">
                                <div>
                                    <h4 class="text-slate-500 text-xs uppercase mb-2">Bemerkungen</h4>
                                    <div class="bg-white/5 p-3 rounded-lg text-sm text-slate-300 min-h-[80px] border border-white/5 whitespace-pre-line">
                                        ${log.notes || 'Keine besonderen Vorkommnisse.'}
                                    </div>
                                </div>
                                <div>
                                    <h4 class="text-slate-500 text-xs uppercase mb-2">Gästeliste</h4>
                                    <div class="grid grid-cols-1 gap-2 max-h-[80px] overflow-hidden">
                                        ${paxListHtml || '<div class="text-slate-500 italic text-sm">Keine Passagiere</div>'}
                                    </div>
                                </div>
                            </div>

                            <!-- Map & Profile -->
                            <div class="grid grid-cols-3 gap-6 h-64">
                                <!-- Using simple ID for map container -->
                                <div class="col-span-2 bg-black rounded-lg border border-white/20 overflow-hidden relative" id="report-map-container" style="height: 100%;"></div>
                                <div class="col-span-1 bg-slate-800/50 rounded-lg border border-white/5 p-2 flex flex-col">
                                    <div class="text-xs text-slate-500 mb-2 text-center uppercase">Höhenprofil</div>
                                    <div class="flex-1 relative"><canvas id="report-altitude-chart"></canvas></div>
                                </div>
                            </div>

                            ${photosHtml}
                        </div>
                        
                        <!-- Footer -->
                        <div class="px-8 py-4 bg-black/20 border-t border-white/5 flex justify-between items-center text-[10px] text-slate-500">
                            <div>Generated by BallonNav Pilot</div>
                            <div>${new Date().toLocaleString()}</div>
                        </div>
                    </div>
                `;

                // --- Init Report Map ---
                // Using Canvas renderer for better html2canvas support
                const mapContainer = document.getElementById('report-map-container');
                const reportMap = L.map(mapContainer, { 
                    zoomControl: false, 
                    attributionControl: false,
                    preferCanvas: true // Critical for html2canvas
                });
                
                // Style logic for report map - always use current setting
                const style = state.settings.mapStyle || 'dark';
                const tileUrl = mapManager.getTileUrl(style);
                
                // Use canvas renderer for tiles if possible (Leaflet doesn't support canvas tiles natively easily, but setting crossOrigin is key)
                L.tileLayer(tileUrl, { crossOrigin: true }).addTo(reportMap);

                if (log.track && log.track.length > 0) {
                    const line = L.polyline(log.track, { color: '#3b82f6', weight: 4, renderer: L.canvas() }).addTo(reportMap);
                    reportMap.fitBounds(line.getBounds(), { padding: [30, 30] });
                } else {
                    reportMap.setView([51.1657, 10.4515], 6);
                }

                // --- Init Report Chart ---
                const ctx = document.getElementById('report-altitude-chart').getContext('2d');
                const altData = log.track ? log.track.map(p => p[2]) : [];
                const labels = altData.map((_, i) => i);
                
                new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            data: altData,
                            borderColor: '#3b82f6',
                            borderWidth: 2,
                            backgroundColor: 'rgba(59, 130, 246, 0.2)',
                            fill: true,
                            pointRadius: 0,
                            tension: 0.1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: { legend: { display: false } },
                        scales: {
                            x: { display: false },
                            y: { display: true, grid: { color: 'rgba(255,255,255,0.1)' }, ticks: { color: '#64748b', font: { size: 8 } } }
                        }
                    }
                });

                // --- Capture ---
                // Increased timeout to allow tiles to load
                setTimeout(() => {
                    html2canvas(stage, { 
                        useCORS: true, 
                        backgroundColor: '#0f172a',
                        scale: 2, // High res
                        allowTaint: true,
                        scrollY: -window.scrollY // Fix for scrolling offsets
                    }).then(canvas => {
                        loader.classList.add('hidden');
                        const link = document.createElement('a');
                        link.download = `Flight-Report-${log.balloon}-${dateStr}.png`;
                        link.href = canvas.toDataURL('image/png');
                        link.click();
                        ui.showToast("Bericht erstellt!");
                        
                        // Cleanup
                        stage.style.visibility = 'hidden'; 
                        stage.style.zIndex = '-5000';
                        stage.innerHTML = '';
                    }).catch(err => {
                        loader.classList.add('hidden');
                        console.error(err);
                        ui.showToast("Fehler beim Export", "error");
                        stage.style.visibility = 'hidden';
                    });
                }, 2000); // 2 seconds wait for map tiles
            },

            // --- KML ACTIONS ---
            toggleKml(id) {
                const kml = state.kmlOverlays.find(k => k.id == id);
                if (kml) {
                    kml.visible = !kml.visible;
                    saveState();
                    mapManager.renderKMLs();
                    this.render(); // Re-render list to update icon
                }
            },
            deleteKml(id) {
                if (confirm("Dieses Overlay wirklich löschen?")) {
                    state.kmlOverlays = state.kmlOverlays.filter(k => k.id != id);
                    saveState();
                    mapManager.renderKMLs();
                    this.render();
                }
            },
            
            // --- ADD MISSING FUNCTION ---
            taufe(name) { 
                 // Simple toast notification instead of alert
                 this.showToast(`${name} wurde erfolgreich getauft!`, 'success');
            },

            // --- BALLOON MANAGEMENT ---
            exportBalloon(id) {
                const b = state.balloons.find(x => x.id === id);
                if (!b) return;
                
                // Collect balloon and its associated cylinders
                const exportData = {
                    balloon: b,
                    cylinders: []
                };
                
                if (b.defaultCylinders && b.defaultCylinders.length > 0) {
                    exportData.cylinders = state.cylinders.filter(c => b.defaultCylinders.includes(c.id));
                }
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const exportFileDefaultName = `balloon-${b.callsign.replace(/\s+/g, '_')}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
            }, // <-- FIXED: Added missing comma
            
            handleBalloonImport(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        try {
                            const data = JSON.parse(e.target.result);
                            if (!data.balloon) throw new Error("Ungültiges Format: Kein Ballon gefunden.");
                            
                            // 1. Process Cylinders
                            if (data.cylinders && Array.isArray(data.cylinders)) {
                                let addedCyls = 0;
                                data.cylinders.forEach(importedCyl => {
                                    if (!state.cylinders.some(c => c.id === importedCyl.id)) {
                                        state.cylinders.push(importedCyl);
                                        addedCyls++;
                                    }
                                });
                                if (addedCyls > 0) ui.showToast(`${addedCyls} fehlende Flaschen hinzugefügt.`);
                            }
                            
                            // 2. Process Balloon
                            const existingBalloon = state.balloons.find(b => b.id === data.balloon.id);
                            
                            if (existingBalloon) {
                                // Conflict resolution: Generate new ID for import (Copy) or Overwrite?
                                // Safest approach: Generate new ID and append "(Import)" to callsign
                                if (confirm(`Ballon ${data.balloon.callsign} existiert bereits.\nAls Kopie importieren?`)) {
                                    data.balloon.id = Date.now().toString(); // New ID
                                    data.balloon.callsign += " (Import)";
                                    state.balloons.push(data.balloon);
                                    ui.showToast("Ballon als Kopie importiert.", "success");
                                }
                            } else {
                                state.balloons.push(data.balloon);
                                ui.showToast("Ballon erfolgreich importiert.", "success");
                            }
                            
                            saveState();
                            ui.render(); // Refresh list
                            
                        } catch (err) {
                            ui.showToast("Import fehlgeschlagen: " + err.message, "error");
                        }
                        // Reset input
                        input.value = '';
                    };
                    reader.readAsText(input.files[0]);
                }
            },
            
            archiveBalloon(id) {
                const b = state.balloons.find(x => x.id === id);
                if (b) {
                    b.archived = true;
                    saveState();
                    this.render();
                    this.showToast("Ballon archiviert.");
                }
            },
            
            restoreBalloon(id) {
                const b = state.balloons.find(x => x.id === id);
                if (b) {
                    b.archived = false;
                    saveState();
                    this.render();
                    this.showToast("Ballon wiederhergestellt.");
                }
            },
            
            deleteBalloon(id) {
                const b = state.balloons.find(x => x.id === id);
                if (!b) return;
                
                if (confirm(`Möchtest du den Ballon ${b.callsign} wirklich löschen?`)) {
                    // Check for standard cylinders
                    if (b.defaultCylinders && b.defaultCylinders.length > 0) {
                        if (confirm(`Sollen auch die ${b.defaultCylinders.length} zugeordneten Standard-Flaschen aus dem Inventar gelöscht werden?`)) {
                            // Remove associated cylinders
                            state.cylinders = state.cylinders.filter(c => !b.defaultCylinders.includes(c.id));
                            this.showToast("Zugehörige Flaschen gelöscht.");
                        }
                    }
                    
                    // Remove balloon
                    state.balloons = state.balloons.filter(x => x.id !== id);
                    saveState();
                    this.render();
                    this.showToast("Ballon gelöscht.", "success");
                }
            },

            // --- Helper for Edit Form ---
            handleImageUpload(input) {
                if (input.files && input.files[0]) {
                    const reader = new FileReader();
                    reader.onload = function(e) {
                        const img = document.getElementById('preview-balloon-img');
                        img.src = e.target.result;
                        img.classList.remove('hidden');
                        img.nextElementSibling.classList.add('hidden');
                    }
                    reader.readAsDataURL(input.files[0]);
                }
            },
            addEditCylinder() { 
                const sel = document.getElementById('edit-cyl-select'); 
                const id = sel.value; 
                if (!id) return; 
                const list = document.getElementById('edit-cyl-list'); 
                if (list.querySelector(`[data-id="${id}"]`)) return; 
                if(list.innerHTML.includes('Keine Standard')) list.innerHTML = ''; 
                const cyl = state.cylinders.find(c => c.id === id); 
                const div = document.createElement('div'); 
                div.className = "flex justify-between items-center bg-slate-800 p-2 rounded mb-1 text-xs default-cyl-item"; 
                div.setAttribute('data-id', id); 
                div.innerHTML = `<span>${cyl.label} (${cyl.type})</span> <button onclick="ui.removeEditCylinder(this)" class="text-red-400 hover:text-red-300"><i class="fas fa-times"></i></button>`; 
                list.appendChild(div); 
                sel.value = ""; // Reset after adding
            },
            removeEditCylinder(btn) { btn.parentElement.remove(); },
            
            // --- SAVE SETTINGS ---
            saveSettings(skipToast) {
                state.pilot.name = document.getElementById('set-pilot-name').value;
                state.pilot.weight = parseFloat(document.getElementById('set-pilot-weight').value);
                // Hours format hh:mm
                const hoursStr = document.getElementById('set-pilot-hours').value;
                if(hoursStr.includes(':')) {
                    const [h,m] = hoursStr.split(':');
                    state.pilot.initialHours = parseInt(h) + (parseInt(m)/60);
                } else {
                    state.pilot.initialHours = parseFloat(hoursStr);
                }
                state.pilot.initialFlights = parseInt(document.getElementById('set-pilot-flights').value);
                
                state.settings.mode = document.getElementById('set-mode-toggle').checked ? 'gps' : 'sim';
                state.settings.useUTC = document.getElementById('set-use-utc').checked;
                state.settings.mapStyle = document.getElementById('set-map-style').value;
                state.settings.trackColor = document.getElementById('set-track-color').value;
                // Added Nav Line Color Save
                state.settings.navLineColor = document.getElementById('set-nav-line-color').value;

                state.settings.apiKey = document.getElementById('set-api-key').value;
                state.settings.imageRetention = parseInt(document.getElementById('set-image-retention').value);
                state.settings.baptismMaxWords = parseInt(document.getElementById('set-baptism-words').value);
                state.settings.aiMaxWords = parseInt(document.getElementById('set-ai-max-words').value);
                state.settings.toastTimeout = parseInt(document.getElementById('set-toast-timeout').value); // Save Toast Timeout
                
                saveState();
                if(!skipToast) ui.showToast("Einstellungen gespeichert!");
                
                // Update mode label text dynamically
                const modeLabel = document.getElementById('lbl-settings-mode');
                if(modeLabel) modeLabel.innerHTML = `Betriebsmodus: <b>${state.settings.mode === 'gps' ? 'GPS LIVE' : 'SIMULATION'}</b>`;

                // Apply changes
                mapManager.setLayer(state.settings.mapStyle);
                mapManager.updateTrackStyle();
                if (state.targetWaypoint) mapManager.renderTarget(); // Update nav line color
                simulation.applyMode();
                ui.updateAiButtonVisibility();
                // Rerender specific views if needed
            },
            
            // --- GENERAL EDIT/DELETE HANDLER STUBS ---
            // These were in original code but simplified out. Need generic implementations:
            
            edit(idOrNew) {
                // Determine current context (Fleet, Cylinder, Pax) based on ui.tab
                // This requires the dynamic form builder logic which was huge.
                // For brevity in this fix, I will assume a simplified generic form alert or console log
                // BUT better is to paste the full form builder if possible.
                // Let's create a placeholder that informs user to use specific edit buttons if any.
                // Actually, the original code had a 'renderForm' method.
                this.editingId = idOrNew;
                this.render(); // This will call renderForm
            },
            
            delete(type, id) {
                if(type === 'cylinders') {
                    if(confirm("Flasche löschen?")) { state.cylinders = state.cylinders.filter(c => c.id !== id); saveState(); this.render(); }
                } else if (type === 'passengers') {
                    if(confirm("Passagier löschen?")) { state.passengers = state.passengers.filter(p => p.id !== id); saveState(); this.render(); }
                } else if (type === 'logs') {
                    if(confirm("Logbucheintrag löschen?")) { state.logs = state.logs.filter(l => l.id !== id); saveState(); this.render(); }
                } else if (type === 'plannings' || type === 'archive') {
                    const arr = type === 'plannings' ? state.plannings : state.archive;
                    const idx = arr.findIndex(x => x.id == id);
                    if(idx > -1 && confirm("Planung löschen?")) { arr.splice(idx, 1); saveState(); this.render(); }
                }
            },
            
            archivePlan(id) {
                const idx = state.plannings.findIndex(p => p.id == id);
                if(idx > -1) {
                    const p = state.plannings.splice(idx, 1)[0];
                    state.archive.push(p);
                    saveState();
                    this.render();
                }
            },
            unarchivePlan(id) {
                const idx = state.archive.findIndex(p => p.id == id);
                if(idx > -1) {
                    const p = state.archive.splice(idx, 1)[0];
                    state.plannings.push(p);
                    saveState();
                    this.render();
                }
            },
            savePlan() {
                const name = document.getElementById('plan-name').value;
                if(!name) { ui.showToast("Bitte Name eingeben", "error"); return; }
                
                const plan = {
                    id: this.editingPlanId || Date.now(),
                    name: name,
                    date: new Date().toLocaleDateString(),
                    balloonId: document.getElementById('plan-balloon').value,
                    balloonName: document.getElementById('plan-balloon').options[document.getElementById('plan-balloon').selectedIndex].text,
                    cylinders: [],
                    passengers: [],
                    temp: parseFloat(document.getElementById('plan-temp').value),
                    alt: parseFloat(document.getElementById('plan-alt').value)
                };
                
                document.querySelectorAll('.plan-cyl-item').forEach(el => plan.cylinders.push(el.dataset.pid));
                document.querySelectorAll('#plan-pax input:checked').forEach(cb => plan.passengers.push(cb.value));
                
                if(this.editingPlanId) {
                    const idx = state.plannings.findIndex(p => p.id == this.editingPlanId);
                    if(idx > -1) state.plannings[idx] = plan;
                } else {
                    state.plannings.push(plan);
                }
                
                saveState();
                this.editingPlanId = null;
                this.clearPlanForm();
                this.showToast("Planung gespeichert");
                // Refresh list
                document.getElementById('saved-plans-list').innerHTML = state.plannings.sort((a,b) => b.id - a.id).map(p => `<div class="flex justify-between items-center bg-slate-800 p-2 rounded text-xs group hover:bg-slate-700/50 transition"><div class="cursor-pointer flex-1" onclick="ui.loadPlan('${p.id}')"><div class="font-bold text-white">${p.name}</div><div class="text-slate-400 text-[10px]">${p.date} | ${p.balloonName}</div></div><div class="flex gap-1"><button onclick="ui.archivePlan(${p.id})" class="text-blue-400 hover:text-blue-300 p-1 px-2 bg-slate-900/50 rounded"><i class="fas fa-box-archive"></i></button><button onclick="ui.delete('plannings', ${p.id})" class="text-red-400 hover:text-red-300 p-1 px-2 bg-slate-900/50 rounded"><i class="fas fa-trash"></i></button></div></div>`).join('');
            },
            
            showSummary(logOrId, isEdit=false) {
                // If ID provided, find log
                let log = (typeof logOrId === 'object') ? logOrId : state.logs.find(l => l.id == logOrId);
                if (!log) return;
                
                document.getElementById('main-modal').style.display = 'flex';
                const c = document.getElementById('tab-content');
                
                // Get Balloon Image
                const b = state.balloons.find(x => x.callsign === log.balloon);
                const balloonImg = b && b.image ? b.image : null;

                // Basic Summary View
                if (!isEdit) {
                    // Display Photos Grid
                    let photosHtml = '';
                    if (log.photos && log.photos.length > 0) {
                        photosHtml = `
                            <h4 class="font-bold mb-2 text-sm text-slate-400 uppercase mt-4">Fotos</h4>
                            <div class="grid grid-cols-4 gap-2 mb-4">
                                ${log.photos.map(p => `
                                    <div class="aspect-square bg-cover bg-center rounded-lg border border-white/10 cursor-pointer hover:opacity-80 transition" onclick="ui.showPhoto('${p.src}')" style="background-image: url('${p.src}')"></div>
                                `).join('')}
                            </div>
                        `;
                    } else {
                        photosHtml = '<div class="text-xs text-slate-500 italic mt-4 mb-4">Keine Fotos vorhanden.</div>';
                    }

                    c.innerHTML = `
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-bold">Zusammenfassung</h3>
                            <button onclick="ui.switchTab('logbook')" class="text-slate-400">Schließen</button>
                        </div>
                        
                        <!-- Map Container (Moved Top) -->
                        <div class="relative w-full h-64 bg-slate-900 rounded-xl mb-4 border border-white/10 overflow-hidden">
                            <div id="summary-map" class="absolute inset-0 z-0"></div>
                            
                            <!-- Balloon Overlay (Left on Map) -->
                            <div class="absolute top-4 left-4 z-[400] flex items-center gap-3 pointer-events-none">
                                ${balloonImg ? 
                                    `<img src="${balloonImg}" class="w-16 h-16 rounded-full border-2 border-white object-cover shadow-lg bg-slate-800">` : 
                                    `<div class="w-16 h-16 rounded-full bg-blue-600/90 backdrop-blur flex items-center justify-center text-3xl border-2 border-white shadow-lg text-white">🎈</div>`
                                }
                                <div class="bg-slate-900/80 backdrop-blur-md px-3 py-2 rounded-lg border border-white/10 shadow-lg">
                                    <div class="font-bold text-white leading-tight">${log.balloon}</div>
                                    <div class="text-slate-400 text-xs">${new Date(log.start).toLocaleDateString()}</div>
                                </div>
                            </div>
                        </div>

                        <div class="glass-panel p-4 mb-4">
                            <!-- Locations & Duration -->
                             <div class="flex justify-between mb-2">
                                <span class="text-slate-400 text-sm">Startort:</span>
                                <span class="font-bold text-right">${log.startLoc}</span>
                            </div>
                            <div class="flex justify-between mb-2">
                                <span class="text-slate-400 text-sm">Landeort:</span>
                                <span class="font-bold text-right">${log.endLoc}</span>
                            </div>
                            <div class="flex justify-between mb-2">
                                <span class="text-slate-400 text-sm">Dauer:</span>
                                <span class="font-bold text-blue-400">${Math.floor((new Date(log.end)-new Date(log.start))/60000)} min</span>
                            </div>
                             <div class="flex justify-between mb-2">
                                <span class="text-slate-400 text-sm">Max Höhe:</span>
                                <span class="font-bold text-blue-400">${Math.round(log.maxAlt || 0)} m</span>
                            </div>

                            <!-- Notes -->
                            <div class="mt-4 pt-2 border-t border-white/10">
                                <span class="text-xs text-slate-500 uppercase font-bold mb-1 block">Bemerkungen</span>
                                <div class="text-sm italic text-slate-300 bg-slate-900/50 p-2 rounded min-h-[40px] whitespace-pre-wrap">${log.notes || "Keine Notizen vorhanden."}</div>
                            </div>
                        </div>
                        
                        <h4 class="font-bold mb-2 text-sm text-slate-400 uppercase">Passagiere</h4>
                        <div class="space-y-2 mb-4">
                            ${log.pax.map(pid => {
                                const p = state.passengers.find(x => x.id == pid);
                                return p ? `<div class="bg-slate-800 p-2 rounded flex justify-between items-center text-sm"><span>${p.firstName} ${p.lastName}</span> ${p.baptism ? '<span class="text-[10px] bg-amber-900/50 text-amber-500 px-1 rounded">Getauft</span>' : ''}</div>` : '';
                            }).join('')}
                        </div>
                        
                        ${photosHtml}
                        
                        <div class="flex gap-2 mt-6">
                            <button onclick="ui.generateReportImage(${log.id})" class="bg-blue-600 hover:bg-blue-500 w-12 h-12 rounded-lg flex items-center justify-center shadow-lg" title="Bildbericht"><i class="fas fa-image text-xl"></i></button>
                            <button onclick="ui.exportGPX(${log.id})" class="bg-slate-700 hover:bg-slate-600 w-12 h-12 rounded-lg flex items-center justify-center shadow-lg" title="GPX Export"><i class="fas fa-route text-xl"></i></button>
                            <button onclick="ui.showSummary(${log.id}, true)" class="bg-slate-800 hover:bg-slate-700 flex-1 h-12 rounded-lg font-bold text-sm border border-white/10">Bearbeiten & Taufen</button>
                        </div>
                    `;
                    
                    // Initialize Map after DOM is ready
                    setTimeout(() => {
                        if(this.summaryMap) { this.summaryMap.remove(); } // cleanup old instance
                        const m = L.map('summary-map', { zoomControl: false, attributionControl: false });
                        
                        // FIX: Use map style from settings
                        const style = state.settings.mapStyle || 'dark';
                        const tileUrl = mapManager.getTileUrl(style);
                        
                        L.tileLayer(tileUrl).addTo(m);
                        
                        if(log.track && log.track.length > 0) {
                            const line = L.polyline(log.track, { color: '#3b82f6', weight: 3 }).addTo(m);
                            m.fitBounds(line.getBounds(), { padding: [20, 20] });
                        } else {
                            m.setView([51.1657, 10.4515], 10);
                        }
                        this.summaryMap = m;
                    }, 100);

                } else {
                    // Edit View (Add Pax, Edit Notes, Baptism)
                    c.innerHTML = `
                        <div class="flex items-center justify-between mb-4">
                            <h3 class="text-xl font-bold">Fahrt Bearbeiten</h3>
                            <button onclick="ui.showSummary(${log.id}, false)" class="text-slate-400">Abbrechen</button>
                        </div>
                        
                        <div class="space-y-4">
                            <div><label>Startort</label><input type="text" id="sum-start" value="${log.startLoc}"></div>
                            <div><label>Landeort</label><input type="text" id="sum-end" value="${log.endLoc}"></div>
                            <div><label>Notizen</label><textarea id="sum-notes" rows="3">${log.notes}</textarea></div>
                            
                            <div class="border-t border-white/10 pt-4">
                                <div class="flex justify-between items-center mb-2">
                                    <label class="mb-0">Passagiere & Taufe</label>
                                    <button onclick="ui.addLogPassenger(${log.id})" class="text-xs bg-slate-700 px-2 py-1 rounded">+ Pax</button>
                                </div>
                                <div class="space-y-3">
                                    ${log.pax.map(pid => {
                                        const p = state.passengers.find(x => x.id == pid);
                                        if(!p) return '';
                                        return `
                                            <div class="bg-slate-800 p-3 rounded border border-white/5">
                                                <div class="flex justify-between items-center mb-2">
                                                    <span class="font-bold text-sm">${p.firstName} ${p.lastName}</span>
                                                    <button onclick="ui.removeLogPassenger(${log.id}, '${pid}')" class="text-red-400 text-xs"><i class="fas fa-times"></i></button>
                                                </div>
                                                <div class="flex gap-2">
                                                    <input type="text" id="bapt-name-${pid}" placeholder="Taufname eingeben..." value="${p.baptismName || ''}" class="text-xs flex-1">
                                                    <button onclick="aiService.getBaptismSuggestions('${p.firstName}', '${log.startLoc}', '${log.endLoc}', 'Tag', '${log.notes}', this, 'bapt-name-${pid}')" class="bg-purple-600/50 hover:bg-purple-500 px-2 rounded text-xs" title="KI Vorschlag"><i class="fas fa-magic"></i></button>
                                                </div>
                                            </div>
                                        `;
                                    }).join('')}
                                </div>
                            </div>
                            
                            <button onclick="ui.saveSummaryChanges(${log.id})" class="w-full bg-green-600 py-3 rounded font-bold mt-4">Speichern</button>
                        </div>
                    `;
                }
            },
            
            // --- GENERIC FORM BUILDER (Restored for Add/Edit Buttons) ---
            renderForm(c) {
                const id = this.editingId;
                const isNew = id === 'new';
                let html = '';
                
                if (this.tab === 'fleet') {
                    const b = isNew ? { 
                        id: Date.now().toString(), 
                        callsign: '', volume: 3000, mtom: 1000, weight: 200, image: '', defaultCylinders: [], 
                        matrix: [ [0.3,0.28,0.26], [0.28,0.26,0.24], [0.26,0.24,0.22], [0.24,0.22,0.20] ] // Default matrix
                    } : state.balloons.find(x => x.id === id);
                    
                    if(!b.matrix) b.matrix = [ [0.3,0.28,0.26], [0.28,0.26,0.24], [0.26,0.24,0.22], [0.24,0.22,0.20] ];

                    html = `
                        <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">${isNew ? 'Neuer Ballon' : 'Ballon bearbeiten'}</h3><button onclick="ui.switchTab('fleet')" class="text-slate-400">Abbrechen</button></div>
                        <div class="space-y-4">
                            <div class="flex justify-center mb-4 relative group">
                                <img src="${b.image || DEFAULT_BALLOON_IMG}" id="preview-balloon-img" class="w-24 h-24 rounded-full border-2 border-white object-cover bg-white">
                                <div class="absolute inset-0 flex items-center justify-center opacity-0 group-hover:opacity-100 transition"><button onclick="document.getElementById('edit-balloon-img').click()" class="bg-black/70 text-white rounded-full p-2"><i class="fas fa-camera"></i></button></div>
                                <input type="file" id="edit-balloon-img" class="hidden" accept="image/*" onchange="ui.handleImageUpload(this)">
                            </div>
                            <div><label>Kennzeichen</label><input type="text" id="edit-callsign" value="${b.callsign}"></div>
                            <div class="grid grid-cols-1 md:grid-cols-3 gap-2">
                                <div><label>Volumen (m³)</label><input type="number" id="edit-vol" value="${b.volume}"></div>
                                <div><label>MTOW (kg)</label><input type="number" id="edit-mtom" value="${b.mtom}"></div>
                                <div><label>Leergewicht (kg)</label><input type="number" id="edit-weight" value="${b.weight}"></div>
                            </div>
                            
                            <div>
                                <label>Standard-Flaschenbestückung</label>
                                <div class="glass-panel p-2 bg-slate-900/50 mb-2 min-h-[40px]" id="edit-cyl-list">
                                    ${b.defaultCylinders && b.defaultCylinders.length > 0 ? b.defaultCylinders.map(cid => {
                                        const cyl = state.cylinders.find(cy => cy.id === cid);
                                        return cyl ? `<div class="flex justify-between items-center bg-slate-800 p-2 rounded mb-1 text-xs default-cyl-item" data-id="${cid}"><span>${cyl.label} (${cyl.type})</span> <button onclick="ui.removeEditCylinder(this)" class="text-red-400 hover:text-red-300"><i class="fas fa-times"></i></button></div>` : '';
                                    }).join('') : '<div class="text-slate-500 italic text-xs p-1">Keine Standard-Flaschen</div>'}
                                </div>
                                <div class="flex gap-2">
                                    <select id="edit-cyl-select" onchange="ui.addEditCylinder()" class="text-xs"><option value="">+ Flasche wählen (Auto-Add)</option>${state.cylinders.map(cyl => `<option value="${cyl.id}">${cyl.label} (${cyl.type})</option>`).join('')}</select>
                                </div>
                            </div>
                            
                            <!-- Lift Matrix Editor - COLLAPSED BY DEFAULT -->
                            <div class="border-t border-white/10 pt-4">
                                <button onclick="document.getElementById('matrix-wrapper').classList.toggle('hidden')" class="flex justify-between items-center w-full text-left mb-2 text-slate-400 hover:text-white font-bold">
                                    <span>Tragkraft-Faktoren (Matrix)</span>
                                    <i class="fas fa-chevron-down"></i>
                                </button>
                                
                                <div id="matrix-wrapper" class="hidden">
                                    <div class="grid grid-cols-4 gap-2 text-xs items-center mb-2">
                                         <div class="text-right text-slate-500 font-bold">Alt / T</div>
                                         <div class="text-center text-blue-300 font-bold">0°C</div>
                                         <div class="text-center text-blue-300 font-bold">15°C</div>
                                         <div class="text-center text-blue-300 font-bold">30°C</div>
                                    </div>
                                    <div class="grid grid-cols-4 gap-2 text-xs items-center">
                                         <!-- 0m -->
                                         <div class="text-right text-slate-500 font-bold">0m</div>
                                         <input type="number" step="0.001" id="mx-0-0" value="${b.matrix[0][0]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-0-1" value="${b.matrix[0][1]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-0-2" value="${b.matrix[0][2]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">

                                         <!-- 1000m -->
                                         <div class="text-right text-slate-500 font-bold">1000m</div>
                                         <input type="number" step="0.001" id="mx-1-0" value="${b.matrix[1][0]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-1-1" value="${b.matrix[1][1]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-1-2" value="${b.matrix[1][2]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">

                                         <!-- 2000m -->
                                         <div class="text-right text-slate-500 font-bold">2000m</div>
                                         <input type="number" step="0.001" id="mx-2-0" value="${b.matrix[2][0]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-2-1" value="${b.matrix[2][1]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-2-2" value="${b.matrix[2][2]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">

                                         <!-- 3000m -->
                                         <div class="text-right text-slate-500 font-bold">3000m</div>
                                         <input type="number" step="0.001" id="mx-3-0" value="${b.matrix[3][0]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-3-1" value="${b.matrix[3][1]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                         <input type="number" step="0.001" id="mx-3-2" value="${b.matrix[3][2]}" class="p-1 text-center bg-slate-800 rounded border border-white/10">
                                    </div>
                                </div>
                            </div>

                            <button onclick="saveBalloon('${b.id}')" class="bg-green-600 w-full py-3 rounded font-bold mt-4">Speichern</button>
                        </div>
                    `;
                    // Define local save function
                    window.saveBalloon = (bid) => {
                        const callsign = document.getElementById('edit-callsign').value;
                        if(!callsign) return;
                        
                        // Collect Matrix
                        const matrix = [];
                        for(let i=0; i<4; i++) {
                            const row = [];
                            for(let j=0; j<3; j++) {
                                row.push(parseFloat(document.getElementById(`mx-${i}-${j}`).value) || 0);
                            }
                            matrix.push(row);
                        }

                        const newB = { 
                            id: bid, 
                            callsign: callsign, 
                            volume: parseFloat(document.getElementById('edit-vol').value), 
                            mtom: parseFloat(document.getElementById('edit-mtom').value), 
                            weight: parseFloat(document.getElementById('edit-weight').value), 
                            image: document.getElementById('preview-balloon-img').src, 
                            defaultCylinders: [],
                            matrix: matrix 
                        };
                        
                        // Robustly collect cylinder IDs from DOM
                        const cylItems = document.getElementById('edit-cyl-list').querySelectorAll('.default-cyl-item');
                        cylItems.forEach(el => {
                            const cylId = el.getAttribute('data-id');
                            if(cylId) newB.defaultCylinders.push(cylId);
                        });
                        
                        if (isNew) state.balloons.push(newB);
                        else { const idx = state.balloons.findIndex(x => x.id === bid); if(idx > -1) state.balloons[idx] = newB; }
                        saveState(); ui.switchTab('fleet');
                    };
                } else if (this.tab === 'cylinders') {
                    const cy = isNew ? { id: Date.now().toString(), label: '', type: 'VA50', tare: 20, gas: 20, sn: '', tuv: '' } : state.cylinders.find(x => x.id === id);
                    html = `
                        <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">${isNew ? 'Neue Flasche' : 'Flasche bearbeiten'}</h3><button onclick="ui.switchTab('cylinders')" class="text-slate-400">Abbrechen</button></div>
                        <div class="space-y-4">
                            <div><label>Bezeichnung / Label</label><input type="text" id="edit-cyl-label" value="${cy.label}" placeholder="z.B. Blau 1"></div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Typ</label><select id="edit-cyl-type"><option value="VA50" ${cy.type==='VA50'?'selected':''}>VA50</option><option value="VA70" ${cy.type==='VA70'?'selected':''}>VA70</option><option value="Master" ${cy.type==='Master'?'selected':''}>Master</option><option value="Standard" ${cy.type==='Standard'?'selected':''}>Standard</option></select></div>
                                <div><label>Seriennummer</label><input type="text" id="edit-cyl-sn" value="${cy.sn}"></div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Tara (kg)</label><input type="number" id="edit-cyl-tare" value="${cy.tare}"></div>
                                <div><label>Füllung (kg)</label><input type="number" id="edit-cyl-gas" value="${cy.gas}"></div>
                            </div>
                            <div><label>Nächster TÜV</label><input type="date" id="edit-cyl-tuv" value="${cy.tuv}"></div>
                            <button onclick="saveCylinder('${cy.id}')" class="bg-green-600 w-full py-3 rounded font-bold mt-4">Speichern</button>
                        </div>
                    `;
                    window.saveCylinder = (cid) => {
                        const label = document.getElementById('edit-cyl-label').value;
                        if(!label) return;
                        const newC = { 
                            id: cid, 
                            label: label, 
                            type: document.getElementById('edit-cyl-type').value, 
                            sn: document.getElementById('edit-cyl-sn').value, 
                            tare: parseFloat(document.getElementById('edit-cyl-tare').value), 
                            gas: parseFloat(document.getElementById('edit-cyl-gas').value),
                            tuv: document.getElementById('edit-cyl-tuv').value
                        };
                        if (isNew) state.cylinders.push(newC);
                        else { const idx = state.cylinders.findIndex(x => x.id === cid); if(idx > -1) state.cylinders[idx] = newC; }
                        saveState(); ui.switchTab('cylinders');
                    };
                } else if (this.tab === 'passengers') {
                    const p = isNew ? { id: Date.now().toString(), firstName: '', lastName: '', weight: 75, gender: 'm', phone: '', flights: 0, baptism: false } : state.passengers.find(x => x.id === id);
                    html = `
                        <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">${isNew ? 'Neuer Passagier' : 'Passagier bearbeiten'}</h3><button onclick="ui.switchTab('passengers')" class="text-slate-400">Abbrechen</button></div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Vorname</label><input type="text" id="edit-pax-first" value="${p.firstName}"></div>
                                <div><label>Nachname</label><input type="text" id="edit-pax-last" value="${p.lastName}"></div>
                            </div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Gewicht (kg)</label><input type="number" id="edit-pax-weight" value="${p.weight}"></div>
                                <div><label>Geschlecht</label><select id="edit-pax-gender"><option value="m" ${p.gender==='m'?'selected':''}>Männlich</option><option value="w" ${p.gender==='w'?'selected':''}>Weiblich</option><option value="d" ${p.gender==='d'?'selected':''}>Divers</option></select></div>
                            </div>
                            <div><label>Telefon</label><input type="tel" id="edit-pax-phone" value="${p.phone}"></div>
                            <button onclick="savePax('${p.id}')" class="bg-green-600 w-full py-3 rounded font-bold mt-4">Speichern</button>
                        </div>
                    `;
                    window.savePax = (pid) => {
                        const first = document.getElementById('edit-pax-first').value;
                        if(!first) return;
                        const newP = { 
                            id: pid, 
                            firstName: first, 
                            lastName: document.getElementById('edit-pax-last').value, 
                            weight: parseFloat(document.getElementById('edit-pax-weight').value), 
                            gender: document.getElementById('edit-pax-gender').value,
                            phone: document.getElementById('edit-pax-phone').value,
                            flights: p.flights,
                            baptism: p.baptism,
                            baptismName: p.baptismName,
                            lastFlight: p.lastFlight
                        };
                        if (isNew) state.passengers.push(newP);
                        else { const idx = state.passengers.findIndex(x => x.id === pid); if(idx > -1) state.passengers[idx] = newP; }
                        saveState(); ui.switchTab('passengers');
                    };
                } else if (this.tab === 'logbook') {
                    // Manual Log Entry
                    const l = { id: Date.now(), start: new Date().toISOString().slice(0,16), end: new Date().toISOString().slice(0,16), balloon: '', startLoc: '', endLoc: '', notes: '' };
                    html = `
                        <div class="flex justify-between items-center mb-4"><h3 class="text-xl font-bold">Manueller Logbuch-Eintrag</h3><button onclick="ui.switchTab('logbook')" class="text-slate-400">Abbrechen</button></div>
                        <div class="space-y-4">
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Startzeit</label><input type="datetime-local" id="edit-log-start" value="${l.start}"></div>
                                <div><label>Landung</label><input type="datetime-local" id="edit-log-end" value="${l.end}"></div>
                            </div>
                            <div><label>Ballon</label><input type="text" id="edit-log-balloon" placeholder="Kennzeichen"></div>
                            <div class="grid grid-cols-1 md:grid-cols-2 gap-2">
                                <div><label>Startort</label><input type="text" id="edit-log-sloc"></div>
                                <div><label>Landeort</label><input type="text" id="edit-log-eloc"></div>
                            </div>
                            <div><label>Notizen</label><textarea id="edit-log-notes" rows="3"></textarea></div>
                            <button onclick="saveManualLog()" class="bg-green-600 w-full py-3 rounded font-bold mt-4">Eintrag Erstellen</button>
                        </div>
                    `;
                    window.saveManualLog = () => {
                        const newL = { 
                            id: Date.now(), 
                            start: new Date(document.getElementById('edit-log-start').value).toISOString(), 
                            end: new Date(document.getElementById('edit-log-end').value).toISOString(), 
                            balloon: document.getElementById('edit-log-balloon').value, 
                            startLoc: document.getElementById('edit-log-sloc').value, 
                            endLoc: document.getElementById('edit-log-eloc').value, 
                            notes: document.getElementById('edit-log-notes').value, 
                            pax: [], cylinders: [], track: []
                        };
                        state.logs.push(newL);
                        saveState(); ui.switchTab('logbook');
                    };
                }
                c.innerHTML = html;
            }
        };

        // --- INIT ---
        window.onload = function() {
            mapManager.init();
            simulation.init();
            flightManager.init();
            ui.init();
            
            // Initial Render logic based on default tab
            ui.render();
        };

    </script>
</body>
</html>
