<!DOCTYPE html>
<html lang="de" class="h-full bg-slate-950">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>CompNavAir</title>

  <!-- PWA / “native-ish” -->
  <meta name="theme-color" content="#020617" />
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
  <meta name="apple-mobile-web-app-title" content="CompNavAir" />
  <meta name="mobile-web-app-capable" content="yes" />
  <link rel="icon" href='data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 64 64"><defs/><rect width="64" height="64" rx="14" fill="%23020b1a"/><path d="M32 10c10 0 18 9 18 20 0 7-3 13-8 17l-2 10H24l-2-10c-5-4-8-10-8-17 0-11 8-20 18-20Z" fill="%23ffffff"/><path d="M26 50h12l2-8c-2 1-5 2-8 2s-6-1-8-2l2 8Z" fill="%2394a3b8"/></svg>' />
  <link rel="manifest" href='data:application/manifest+json;charset=utf-8,{
    "name":"CompNavAir",
    "short_name":"CompNavAir",
    "start_url":".",
    "display":"standalone",
    "background_color":"#020617",
    "theme_color":"#020617",
    "description":"Wettkampf-Navigation & Tracking für Heißluftballon-Wettbewerbe",
    "icons":[
      {"src":"data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 rx=%2214%22 fill=%22%23020b1a%22/><path d=%22M32 10c10 0 18 9 18 20 0 7-3 13-8 17l-2 10H24l-2-10c-5-4-8-10-8-17 0-11 8-20 18-20Z%22 fill=%22%23ffffff%22/><path d=%22M26 50h12l2-8c-2 1-5 2-8 2s-6-1-8-2l2 8Z%22 fill=%22%2394a3b8%22/></svg>","sizes":"192x192","type":"image/svg+xml"},
      {"src":"data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 64 64%22><rect width=%2264%22 height=%2264%22 rx=%2214%22 fill=%22%23020b1a%22/><path d=%22M32 10c10 0 18 9 18 20 0 7-3 13-8 17l-2 10H24l-2-10c-5-4-8-10-8-17 0-11 8-20 18-20Z%22 fill=%22%23ffffff%22/><path d=%22M26 50h12l2-8c-2 1-5 2-8 2s-6-1-8-2l2 8Z%22 fill=%22%2394a3b8%22/></svg>","sizes":"512x512","type":"image/svg+xml"}
    ]
  }' />

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <!-- Leaflet -->
  <link
    rel="stylesheet"
    href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css"
    integrity="sha256-p4NxAoJBhIIN+hmNHrzRCf9tD/miZyoHS5obTRR9BMY="
    crossorigin=""
  />
  <script
    src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"
    integrity="sha256-20nQCchB9co0qIjJZRGuk2/Z9VM+kNiyxNV1lvTlZBo="
    crossorigin=""
  ></script>

  <!-- Leaflet-Omnivore (KML Import) -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-omnivore/0.3.4/leaflet-omnivore.min.js"></script>

  <!-- FontAwesome -->
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.0/css/all.min.css" />

  <style>
    /* Prevent rubber band scroll affecting the app feel */
    html, body { overscroll-behavior: none; }
    #map { height: 100%; width: 100%; }

    /* Leaflet control z-index vs overlays */
    .leaflet-control-container { z-index: 10; }

    /* Balloon icon */
    .balloon-marker {
      width: 44px;
      height: 44px;
      border-radius: 9999px;
      background: rgba(2,6,23,0.72);
      border: 1px solid rgba(148,163,184,0.35);
      backdrop-filter: blur(8px);
      display: grid;
      place-items: center;
      box-shadow: 0 10px 30px rgba(0,0,0,0.45);
    }
    .balloon-marker i {
      font-size: 18px;
      color: #e2e8f0;
    }
    .balloon-needle {
      width: 0; height: 0;
      border-left: 7px solid transparent;
      border-right: 7px solid transparent;
      border-top: 12px solid rgba(34,197,94,0.95); /* green needle */
      margin-top: -2px;
    }

    /* Toast animation */
    .toast-pop { animation: toastPop 180ms ease-out; }
    @keyframes toastPop {
      from { transform: translateY(-8px); opacity: 0; }
      to { transform: translateY(0); opacity: 1; }
    }

    /* Better tap targets */
    button, input, select { touch-action: manipulation; }
  </style>
</head>

<body class="h-full text-slate-100">
  <!-- App Shell -->
  <div class="h-full w-full flex flex-col">
    <!-- Header -->
    <header class="fixed top-0 left-0 right-0 z-40 bg-slate-950/80 backdrop-blur border-b border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex items-center gap-2 min-w-0">
          <div class="w-9 h-9 rounded-2xl bg-slate-900 border border-slate-800 grid place-items-center">
            <i class="fa-solid fa-balloon text-slate-100"></i>
          </div>
          <div class="min-w-0">
            <div class="text-sm font-semibold leading-tight truncate">CompNavAir</div>
            <div id="gpsStatus" class="text-[11px] text-slate-400 leading-tight truncate">
              GPS: — · Fix: —
            </div>
          </div>
        </div>

        <div class="flex-1"></div>

        <button id="btnFinish" class="hidden h-10 px-3 rounded-xl bg-emerald-600 hover:bg-emerald-500 active:bg-emerald-700 text-slate-950 font-semibold text-sm">
          <i class="fa-solid fa-flag-checkered mr-2"></i>Fertig
        </button>

        <button id="btnWindHud" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Wind HUD">
          <i class="fa-solid fa-wind"></i>
        </button>
        <button id="btnMapSettings" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Map Settings">
          <i class="fa-solid fa-layer-group"></i>
        </button>
        <button id="btnCenter" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Zentrieren">
          <i class="fa-solid fa-crosshairs"></i>
        </button>
        <button id="btnMenu" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Menü">
          <i class="fa-solid fa-bars"></i>
        </button>
      </div>
    </header>

    <!-- Main (Map) -->
    <main class="flex-1">
      <div class="pt-14 pb-20 h-full">
        <div id="map" class="h-full w-full"></div>
      </div>
    </main>

    <!-- Nav Toast -->
    <div id="navToastWrap" class="pointer-events-none fixed top-16 left-0 right-0 z-40 flex justify-center px-3">
      <div id="navToast" class="hidden toast-pop pointer-events-auto max-w-[92vw] rounded-2xl bg-slate-900/80 border border-slate-700 backdrop-blur px-3 py-2 shadow-xl">
        <div class="flex items-center gap-2">
          <i class="fa-solid fa-location-arrow text-slate-200"></i>
          <div class="min-w-0">
            <div id="navToastTitle" class="text-xs font-semibold truncate">—</div>
            <div id="navToastSub" class="text-[11px] text-slate-300 truncate">—</div>
          </div>
        </div>
      </div>
    </div>

    <!-- Wind HUD -->
    <div id="windHud" class="hidden fixed top-16 left-3 z-50 w-[320px] max-w-[90vw] rounded-2xl bg-slate-950/75 border border-slate-700 backdrop-blur shadow-2xl">
      <div class="p-3 border-b border-slate-800 flex items-center gap-2">
        <div class="font-semibold text-sm"><i class="fa-solid fa-wind mr-2"></i>Wind HUD</div>
        <div class="flex-1"></div>
        <button id="btnWindLoadOnline" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">
          <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Online
        </button>
        <button id="btnWindHudClose" class="h-9 w-9 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800" aria-label="Schließen">
          <i class="fa-solid fa-xmark"></i>
        </button>
      </div>
      <div class="p-3">
        <div id="windHudEmpty" class="hidden text-sm text-slate-300">
          Noch kein Windprofil. Lade Online oder füge manuell Einträge hinzu.
        </div>
        <div class="overflow-auto max-h-[45vh]">
          <table class="w-full text-xs">
            <thead class="text-slate-400">
              <tr>
                <th class="text-left py-1">Höhe</th>
                <th class="text-left py-1">Richtung</th>
                <th class="text-right py-1">Speed</th>
              </tr>
            </thead>
            <tbody id="windHudBody"></tbody>
          </table>
        </div>
        <div class="mt-3 text-[11px] text-slate-400 leading-snug">
          Hinweis: Richtung im HUD ist <span class="text-slate-200 font-semibold">Wind-von</span> (meteorologisch). Drift nutzt automatisch <span class="text-slate-200 font-semibold">Wind-nach</span>.
        </div>
      </div>
    </div>

    <!-- Simulation Controls -->
    <div id="simControls" class="hidden fixed left-3 top-1/2 -translate-y-1/2 z-50 flex flex-col gap-3">
      <button id="btnBurner" class="h-16 w-16 rounded-2xl bg-orange-500/90 text-slate-950 font-extrabold shadow-2xl active:scale-95">
        <i class="fa-solid fa-fire text-xl"></i>
        <div class="text-[11px] mt-1">Auf</div>
      </button>
      <button id="btnVent" class="h-16 w-16 rounded-2xl bg-sky-400/90 text-slate-950 font-extrabold shadow-2xl active:scale-95">
        <i class="fa-solid fa-droplet text-xl"></i>
        <div class="text-[11px] mt-1">Ab</div>
      </button>
    </div>

    <!-- Footer Cockpit -->
    <footer class="fixed bottom-0 left-0 right-0 z-40 bg-slate-950/80 backdrop-blur border-t border-slate-800">
      <div class="px-3 py-2 flex items-center gap-2">
        <div class="flex-1 grid grid-cols-3 gap-2">
          <div class="rounded-2xl bg-slate-900 border border-slate-800 px-3 py-2">
            <div class="text-[10px] text-slate-400">GS</div>
            <div id="instGS" class="text-sm font-semibold">—</div>
          </div>
          <div class="rounded-2xl bg-slate-900 border border-slate-800 px-3 py-2">
            <div class="text-[10px] text-slate-400">ALT</div>
            <div id="instALT" class="text-sm font-semibold">—</div>
          </div>
          <div class="rounded-2xl bg-slate-900 border border-slate-800 px-3 py-2">
            <div class="text-[10px] text-slate-400">Vario</div>
            <div id="instVARIO" class="text-sm font-semibold">—</div>
          </div>
        </div>

        <button id="btnMarker" class="h-16 w-16 rounded-3xl bg-fuchsia-500 text-slate-950 font-extrabold shadow-2xl active:scale-95" aria-label="Marker">
          <i class="fa-solid fa-location-dot text-2xl"></i>
        </button>
      </div>

      <div class="px-3 pb-2">
        <div class="rounded-2xl bg-slate-900/70 border border-slate-800 px-3 py-2 flex items-center gap-2">
          <i class="fa-solid fa-compass text-slate-300"></i>
          <div class="min-w-0">
            <div class="text-[11px] text-slate-400">Strategie</div>
            <div id="strategyLine" class="text-xs font-semibold truncate">—</div>
          </div>
          <div class="flex-1"></div>
          <div id="wakeLockBadge" class="hidden text-[11px] px-2 py-1 rounded-xl bg-emerald-500/15 border border-emerald-500/30 text-emerald-200">
            <i class="fa-solid fa-sun mr-1"></i>Wake
          </div>
        </div>
      </div>
    </footer>

    <!-- Right Side Menu -->
    <div id="menuOverlay" class="hidden fixed inset-0 z-50">
      <div id="menuBackdrop" class="absolute inset-0 bg-black/50"></div>

      <aside class="absolute right-0 top-0 bottom-0 w-[390px] max-w-[92vw] bg-slate-950 border-l border-slate-800 shadow-2xl flex flex-col">
        <div class="p-3 border-b border-slate-800 flex items-center gap-2">
          <div class="font-semibold">Menü</div>
          <div class="flex-1"></div>
          <button id="btnMenuClose" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Schließen">
            <i class="fa-solid fa-xmark"></i>
          </button>
        </div>

        <!-- Tabs -->
        <div class="p-3 border-b border-slate-800">
          <div class="grid grid-cols-4 gap-2">
            <button data-tab="task" class="tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 text-sm font-semibold">
              <i class="fa-solid fa-bullseye mr-2"></i>Task
            </button>
            <button data-tab="wind" class="tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 text-sm font-semibold">
              <i class="fa-solid fa-wind mr-2"></i>Wind
            </button>
            <button data-tab="setup" class="tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 text-sm font-semibold">
              <i class="fa-solid fa-gear mr-2"></i>Setup
            </button>
            <button data-tab="archive" class="tabBtn h-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800 text-sm font-semibold">
              <i class="fa-solid fa-box-archive mr-2"></i>Archiv
            </button>
          </div>
        </div>

        <!-- Content -->
        <div class="flex-1 overflow-auto p-3">
          <!-- TASK TAB -->
          <section id="tab-task" class="tabPanel space-y-4">
            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3">
              <div class="flex items-center gap-2">
                <div class="font-semibold"><i class="fa-solid fa-bullseye mr-2"></i>Aktive Aufgabe</div>
                <div class="flex-1"></div>
                <button id="btnTaskDeactivate" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">
                  Deaktivieren
                </button>
              </div>
              <div class="mt-2 text-sm">
                <div id="activeTaskLabel" class="text-slate-200 font-semibold">—</div>
                <div id="activeTaskHint" class="text-[12px] text-slate-400">—</div>
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3">
              <div class="font-semibold mb-2"><i class="fa-solid fa-plus mr-2"></i>Task anlegen</div>

              <div class="space-y-2">
                <label class="text-xs text-slate-400">CIA Task</label>
                <select id="taskType" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3">
                </select>

                <label class="text-xs text-slate-400">Titel</label>
                <input id="taskTitle" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="z.B. Task 3 · JDG Speyer" />

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Marker-Farbe</label>
                    <select id="taskMarkerColor" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3">
                      <option value="fuchsia">Fuchsia</option>
                      <option value="orange">Orange</option>
                      <option value="emerald">Grün</option>
                      <option value="sky">Blau</option>
                      <option value="rose">Rosa</option>
                      <option value="amber">Gelb</option>
                    </select>
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Punkte (A/B/C)</label>
                    <select id="taskPointsCount" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3">
                      <option value="1">1 Punkt</option>
                      <option value="2">2 Punkte</option>
                      <option value="3">3 Punkte</option>
                    </select>
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Lat (A)</label>
                    <input id="taskLatA" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="49.3033" inputmode="decimal" />
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Lon (A)</label>
                    <input id="taskLonA" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="8.4519" inputmode="decimal" />
                  </div>
                </div>

                <div id="taskPointB" class="hidden grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Lat (B)</label>
                    <input id="taskLatB" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="..." inputmode="decimal" />
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Lon (B)</label>
                    <input id="taskLonB" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="..." inputmode="decimal" />
                  </div>
                </div>

                <div id="taskPointC" class="hidden grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Lat (C)</label>
                    <input id="taskLatC" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="..." inputmode="decimal" />
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Lon (C)</label>
                    <input id="taskLonC" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="..." inputmode="decimal" />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Radius 1 (m)</label>
                    <input id="taskR1" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="0" inputmode="numeric" />
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Radius 2 (m)</label>
                    <input id="taskR2" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="0" inputmode="numeric" />
                  </div>
                </div>

                <div class="grid grid-cols-2 gap-2">
                  <div>
                    <label class="text-xs text-slate-400">Winkel / Richtung (°)</label>
                    <input id="taskAngle" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="0" inputmode="numeric" />
                  </div>
                  <div>
                    <label class="text-xs text-slate-400">Min/Max Höhe (m)</label>
                    <div class="grid grid-cols-2 gap-2">
                      <input id="taskAltMin" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="0" inputmode="numeric" />
                      <input id="taskAltMax" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="9999" inputmode="numeric" />
                    </div>
                  </div>
                </div>

                <div class="flex gap-2">
                  <button id="btnUseCurrentPos" class="flex-1 h-11 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
                    <i class="fa-solid fa-location-crosshairs mr-2"></i>Aktuelle Pos
                  </button>
                  <button id="btnCreateTask" class="flex-1 h-11 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-slate-950 text-sm font-extrabold">
                    <i class="fa-solid fa-check mr-2"></i>Anlegen
                  </button>
                </div>

                <div class="mt-2 text-[11px] text-slate-400 leading-snug">
                  Tipp: Für 3DT setze Radius 1 = innerer Kreis (ungültig), Radius 2 = äußerer Kreis (Ring).
                </div>
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3">
              <div class="font-semibold mb-2"><i class="fa-solid fa-list mr-2"></i>Tasks</div>
              <div id="taskList" class="space-y-2"></div>
            </div>
          </section>

          <!-- WIND TAB -->
          <section id="tab-wind" class="tabPanel hidden space-y-4">
            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3 space-y-3">
              <div class="flex items-center gap-2">
                <div class="font-semibold"><i class="fa-solid fa-wind mr-2"></i>Windprofil</div>
                <div class="flex-1"></div>
                <button id="btnWindClear" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">
                  Leeren
                </button>
              </div>

              <div class="grid grid-cols-3 gap-2">
                <div>
                  <label class="text-xs text-slate-400">Höhe (m)</label>
                  <input id="windAlt" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="500" inputmode="numeric" />
                </div>
                <div>
                  <label class="text-xs text-slate-400">Richtung von (°)</label>
                  <input id="windDirFrom" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="270" inputmode="numeric" />
                </div>
                <div>
                  <label class="text-xs text-slate-400">Speed (km/h)</label>
                  <input id="windSpd" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="15" inputmode="numeric" />
                </div>
              </div>

              <button id="btnWindAdd" class="w-full h-11 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-plus mr-2"></i>Wind-Eintrag hinzufügen
              </button>

              <div class="grid grid-cols-2 gap-2">
                <button id="btnWindFetchOnline2" class="h-11 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
                  <i class="fa-solid fa-cloud-arrow-down mr-2"></i>Open-Meteo laden
                </button>
                <button id="btnWindShowHud" class="h-11 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
                  <i class="fa-solid fa-up-right-and-down-left-from-center mr-2"></i>HUD anzeigen
                </button>
              </div>

              <div class="text-[11px] text-slate-400 leading-snug">
                Auto-Recording (Real): Wenn GS &gt; 10 km/h und ALT &Delta;&gt;50m oder Kurs &Delta;&gt;5°, wird ein Windpunkt aus Drift geschätzt.
              </div>
            </div>

            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3">
              <div class="font-semibold mb-2"><i class="fa-solid fa-layer-group mr-2"></i>Einträge</div>
              <div id="windList" class="space-y-2"></div>
            </div>
          </section>

          <!-- SETUP TAB -->
          <section id="tab-setup" class="tabPanel hidden space-y-4">
            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3 space-y-3">
              <div class="font-semibold"><i class="fa-solid fa-gear mr-2"></i>Allgemein</div>

              <div class="flex items-center justify-between gap-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
                <div>
                  <div class="font-semibold text-sm">Simulation</div>
                  <div class="text-[12px] text-slate-400">GPS wird ignoriert, Ballon driftet im Windprofil.</div>
                </div>
                <label class="inline-flex items-center cursor-pointer">
                  <input id="toggleSim" type="checkbox" class="sr-only peer">
                  <div class="w-12 h-7 bg-slate-800 peer-checked:bg-emerald-600 rounded-full relative transition">
                    <div class="w-5 h-5 bg-white rounded-full absolute top-1 left-1 peer-checked:left-6 transition"></div>
                  </div>
                </label>
              </div>

              <div class="flex items-center justify-between gap-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
                <div>
                  <div class="font-semibold text-sm">Wake Lock</div>
                  <div class="text-[12px] text-slate-400">Bildschirm bleibt an (wenn unterstützt).</div>
                </div>
                <button id="btnWakeLock" class="h-10 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
                  Aktivieren
                </button>
              </div>

              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="text-xs text-slate-400">Einheit Speed</label>
                  <select id="unitSpeed" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3">
                    <option value="kmh">km/h</option>
                    <option value="kn">kn</option>
                    <option value="ms">m/s</option>
                  </select>
                </div>
                <div>
                  <label class="text-xs text-slate-400">Traj Vektor</label>
                  <select id="trajMinutes" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3">
                    <option value="5,10,15">5/10/15 min</option>
                    <option value="5,10">5/10 min</option>
                    <option value="10">10 min</option>
                  </select>
                </div>
              </div>

              <div class="grid grid-cols-2 gap-2">
                <div>
                  <label class="text-xs text-slate-400">GPS Update (ms)</label>
                  <input id="gpsMinInterval" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="1000" inputmode="numeric" />
                </div>
                <div>
                  <label class="text-xs text-slate-400">Track Punkt Dist (m)</label>
                  <input id="trackMinDist" class="w-full h-11 rounded-xl bg-slate-950 border border-slate-700 px-3" placeholder="8" inputmode="numeric" />
                </div>
              </div>

              <button id="btnSetupSave" class="w-full h-11 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-slate-950 font-extrabold">
                <i class="fa-solid fa-floppy-disk mr-2"></i>Setup speichern
              </button>
            </div>

            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3 space-y-3">
              <div class="font-semibold"><i class="fa-solid fa-file-import mr-2"></i>KML Import</div>
              <input id="kmlFile" type="file" accept=".kml,application/vnd.google-earth.kml+xml" class="block w-full text-sm text-slate-300 file:mr-3 file:py-2 file:px-3 file:rounded-xl file:border-0 file:bg-slate-900 file:text-slate-100 hover:file:bg-slate-800" />
              <div class="text-[11px] text-slate-400 leading-snug">
                Importierte KML wird als Overlay angezeigt (z.B. Scoring Areas, Briefing-Layer, Lufträume).
              </div>
              <div id="kmlLayersList" class="space-y-2"></div>
            </div>
          </section>

          <!-- ARCHIVE TAB -->
          <section id="tab-archive" class="tabPanel hidden space-y-4">
            <div class="rounded-2xl bg-slate-900/70 border border-slate-800 p-3">
              <div class="flex items-center gap-2">
                <div class="font-semibold"><i class="fa-solid fa-box-archive mr-2"></i>Fahrten</div>
                <div class="flex-1"></div>
                <button id="btnArchiveClear" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">
                  Leeren
                </button>
              </div>
              <div class="mt-2 text-[12px] text-slate-400">
                “Fertig” beendet eine Fahrt und legt sie hier ab. Export enthält Track + Marker (Zeitstempel).
              </div>
            </div>

            <div id="archiveList" class="space-y-2"></div>
          </section>
        </div>

        <!-- Bottom mini-status -->
        <div class="p-3 border-t border-slate-800">
          <div id="appStatus" class="text-[11px] text-slate-400">
            —
          </div>
        </div>
      </aside>
    </div>

    <!-- Map Settings Panel (small modal) -->
    <div id="mapSettings" class="hidden fixed inset-0 z-50">
      <div id="mapSettingsBackdrop" class="absolute inset-0 bg-black/50"></div>
      <div class="absolute left-1/2 top-1/2 -translate-x-1/2 -translate-y-1/2 w-[360px] max-w-[92vw] rounded-2xl bg-slate-950 border border-slate-800 shadow-2xl">
        <div class="p-3 border-b border-slate-800 flex items-center gap-2">
          <div class="font-semibold"><i class="fa-solid fa-layer-group mr-2"></i>Karte</div>
          <div class="flex-1"></div>
          <button id="btnMapSettingsClose" class="h-10 w-10 rounded-xl bg-slate-900 border border-slate-800 hover:bg-slate-800" aria-label="Schließen">
            <i class="fa-solid fa-xmark"></i>
          </button>
        </div>
        <div class="p-3 space-y-3">
          <div class="grid grid-cols-2 gap-2">
            <button id="btnBaseOSM" class="h-11 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
              OSM
            </button>
            <button id="btnBaseSAT" class="h-11 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-sm font-semibold">
              Satellit
            </button>
          </div>

          <div class="flex items-center justify-between gap-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div>
              <div class="font-semibold text-sm">Track</div>
              <div class="text-[12px] text-slate-400">Roter Pfad (Trackpunkte).</div>
            </div>
            <label class="inline-flex items-center cursor-pointer">
              <input id="toggleTrack" type="checkbox" class="sr-only peer" checked>
              <div class="w-12 h-7 bg-slate-800 peer-checked:bg-emerald-600 rounded-full relative transition">
                <div class="w-5 h-5 bg-white rounded-full absolute top-1 left-1 peer-checked:left-6 transition"></div>
              </div>
            </label>
          </div>

          <div class="flex items-center justify-between gap-3 rounded-2xl bg-slate-950/60 border border-slate-800 p-3">
            <div>
              <div class="font-semibold text-sm">Trajectory</div>
              <div class="text-[12px] text-slate-400">Grüne Vektor-Vorschau (5/10/15 min).</div>
            </div>
            <label class="inline-flex items-center cursor-pointer">
              <input id="toggleTraj" type="checkbox" class="sr-only peer" checked>
              <div class="w-12 h-7 bg-slate-800 peer-checked:bg-emerald-600 rounded-full relative transition">
                <div class="w-5 h-5 bg-white rounded-full absolute top-1 left-1 peer-checked:left-6 transition"></div>
              </div>
            </label>
          </div>

          <button id="btnRebuildOverlays" class="w-full h-11 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-slate-950 font-extrabold">
            <i class="fa-solid fa-rotate mr-2"></i>Overlays neu zeichnen
          </button>
        </div>
      </div>
    </div>

    <!-- Simple toast -->
    <div id="snackbar" class="hidden fixed bottom-24 left-0 right-0 z-50 flex justify-center px-3">
      <div class="toast-pop max-w-[92vw] rounded-2xl bg-slate-900/90 border border-slate-700 backdrop-blur px-3 py-2 shadow-xl text-sm">
        <span id="snackbarText">—</span>
      </div>
    </div>
  </div>

  <script>
    /*********************************************************************
     * 1) Konstanten & Konfiguration
     *********************************************************************/
    const CONFIG = {
      APP_VERSION: "1.0.0",
      DEFAULT_CENTER: { lat: 49.3033, lon: 8.4519, zoom: 12 }, // Speyer / EDRY (approx)
      STORAGE_KEY: "compnavair_state_v1",
      STORAGE_ARCHIVE_KEY: "compnavair_archive_v1",
      STORAGE_KML_KEY: "compnavair_kml_overlays_v1",
      STORAGE_WIND_KEY: "compnavair_wind_v1",
      STORAGE_SETUP_KEY: "compnavair_setup_v1",
      GPS: {
        ENABLE_HIGH_ACCURACY: true,
        TIMEOUT_MS: 12000,
        MAX_AGE_MS: 1000,
        MIN_INTERVAL_MS: 1000,   // throttling in app
        MIN_DIST_M: 8            // min distance for track point
      },
      UNITS: {
        SPEED: "kmh" // kmh | kn | ms
      },
      TRAJ_MINUTES: [5, 10, 15],
      WIND_AUTO: {
        MIN_GS_KMH: 10,
        ALT_DELTA_M: 50,
        CRS_DELTA_DEG: 5
      },
      OPEN_METEO: {
        BASE_URL: "https://api.open-meteo.com/v1/forecast",
        // Pressure levels good for ballooning; altitudes are approx above sea level
        PRESSURE_LEVELS: [
          { hPa: 1000, approxM: 110 },
          { hPa: 975,  approxM: 320 },
          { hPa: 950,  approxM: 500 },
          { hPa: 925,  approxM: 800 },
          { hPa: 900,  approxM: 1000 },
          { hPa: 850,  approxM: 1500 },
          { hPa: 800,  approxM: 1900 }
        ]
      }
    };

    const CIA_TASKS = [
      { id: "15.1", code: "PDG", title: "SELBST GEWÄHLTES ZIEL", kind: "target", defaultPoints: 1 },
      { id: "15.2", code: "JDG", title: "VORGEGEBENES ZIEL", kind: "target", defaultPoints: 1 },
      { id: "15.3", code: "HWZ", title: "QUAL DER WAHL", kind: "multi_target", defaultPoints: 2 },
      { id: "15.4", code: "FIN", title: "FLY IN", kind: "target", defaultPoints: 1 },
      { id: "15.5", code: "FON", title: "FLY ON", kind: "target", defaultPoints: 1 },
      { id: "15.6", code: "HNH", title: "FUCHSJAGD", kind: "target", defaultPoints: 1 },
      { id: "15.7", code: "WSD", title: "FUCHSJAGD MIT ANLAUF", kind: "target", defaultPoints: 1 },
      { id: "15.8", code: "GBM", title: "GORDON BENNETT MEMORIAL", kind: "area_target", defaultPoints: 1 },
      { id: "15.9", code: "CRT", title: "ZIELFAHRT MIT ZEITFENSTER", kind: "area_target", defaultPoints: 1 },
      { id: "15.10", code: "RTA", title: "RENNEN ZUM WERTUNGSGEBIET", kind: "area_time", defaultPoints: 1 },
      { id: "15.11", code: "ELB", title: "ELLENBOGEN", kind: "logger_3pt", defaultPoints: 3 },
      { id: "15.12", code: "LRN", title: "DREIECKSFLÄCHE", kind: "logger_3pt", defaultPoints: 3 },
      { id: "15.13", code: "MDT", title: "MINIMUM DISTANCE MIT ZEITVORGABE", kind: "ref_target", defaultPoints: 1 },
      { id: "15.14", code: "SFL", title: "MINIMUM DISTANCE MIT WERTUNGSGEBIET", kind: "area_ref", defaultPoints: 1 },
      { id: "15.15", code: "MDD", title: "MINIMUM DISTANCE ZWEI MARKER", kind: "area_2mark", defaultPoints: 1 },
      { id: "15.16", code: "XDT", title: "MAXIMUM DISTANCE MIT ZEITVORGABE", kind: "ref_target", defaultPoints: 1 },
      { id: "15.17", code: "XDI", title: "MAXIMUM DISTANCE MIT WERTUNGSGEBIET", kind: "area_ref", defaultPoints: 1 },
      { id: "15.18", code: "XDD", title: "MAXIMUM DISTANCE ZWEI MARKER", kind: "area_2mark", defaultPoints: 1 },
      { id: "15.19", code: "ANG", title: "WINKEL", kind: "angle_2pt", defaultPoints: 2 },
      { id: "15.20", code: "3DT", title: "3D-AUFGABE", kind: "donut_track", defaultPoints: 1 },
      // CIA COH 2025 mentions “Altitude Profile Task (15.21)” – we keep it here for Vollständigkeit.
      { id: "15.21", code: "APT", title: "HÖHENPROFIL-AUFGABE", kind: "alt_profile", defaultPoints: 1 }
    ];

    /*********************************************************************
     * 2) Globale Variablen (State)
     *********************************************************************/
    const STATE = {
      map: null,
      layers: {
        baseOSM: null,
        baseSAT: null,
        activeBase: "OSM",
        track: null,
        trackLine: null,
        trajLines: [],
        tasksLayer: null,
        markersLayer: null,
        kmlOverlays: [] // {id,name,layer,visible}
      },
      ui: {
        menuOpen: false,
        activeTab: "task",
        windHudOpen: false,
        mapSettingsOpen: false,
        trackVisible: true,
        trajVisible: true
      },
      setup: {
        unitSpeed: CONFIG.UNITS.SPEED,
        trajMinutes: CONFIG.TRAJ_MINUTES.slice(),
        gpsMinInterval: CONFIG.GPS.MIN_INTERVAL_MS,
        trackMinDist: CONFIG.GPS.MIN_DIST_M
      },
      gps: {
        supported: "geolocation" in navigator,
        watching: false,
        watchId: null,
        lastUIUpdateTs: 0,
        lastTrackPt: null,     // {lat,lon,alt,ts}
        lastHeadingDeg: null,
        lastSpeedKmh: 0,
        lastAltM: null,
        lastWindAuto: null     // {alt,dirFrom,spdKmh,ts,headingTo}
      },
      wake: {
        supported: "wakeLock" in navigator,
        lock: null
      },
      sim: {
        enabled: false,
        timerId: null,
        verticalRateMps: 0,
        state: { lat: CONFIG.DEFAULT_CENTER.lat, lon: CONFIG.DEFAULT_CENTER.lon, altM: 120, headingDeg: 0, speedKmh: 0, ts: Date.now() }
      },
      wind: {
        // entries sorted by altitude: { altM, dirFromDeg, speedKmh, ts, source }
        entries: []
      },
      tasks: {
        list: [],        // { id, typeId, typeCode, typeTitle, title, points:[{label,lat,lon}], r1M, r2M, angleDeg, altMinM, altMaxM, markerColor, createdTs }
        activeTaskId: null
      },
      flight: {
        active: false,
        startedTs: null,
        track: [],       // {lat,lon,altM,ts}
        markers: []      // {lat,lon,altM,ts, color, label}
      },
      archive: [] // {id, title, startedTs, finishedTs, track[], markers[], tasksSnapshot?, windSnapshot?}
    };

    /*********************************************************************
     * 3) Helfer-Funktionen (Math, Formatting)
     *********************************************************************/
    function clamp(n, a, b) { return Math.max(a, Math.min(b, n)); }
    function isFiniteNum(x) { return typeof x === "number" && Number.isFinite(x); }
    function toNumOrNull(v) {
      if (v === null || v === undefined) return null;
      const n = Number(String(v).trim().replace(",", "."));
      return Number.isFinite(n) ? n : null;
    }
    function nowISO() { return new Date().toISOString(); }
    function fmtTs(ts) {
      try {
        const d = new Date(ts);
        return d.toLocaleString(undefined, { year:"numeric", month:"2-digit", day:"2-digit", hour:"2-digit", minute:"2-digit", second:"2-digit" });
      } catch { return String(ts); }
    }
    function fmtDist(m) {
      if (!isFiniteNum(m)) return "—";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(2)} km`;
    }
    function fmtAlt(m) {
      if (!isFiniteNum(m)) return "—";
      return `${Math.round(m)} m`;
    }
    function fmtSpeedKmh(kmh) {
      if (!isFiniteNum(kmh)) return "—";
      const u = STATE.setup.unitSpeed;
      if (u === "kmh") return `${Math.round(kmh)} km/h`;
      if (u === "kn") return `${Math.round(kmh / 1.852)} kn`;
      if (u === "ms") return `${(kmh / 3.6).toFixed(1)} m/s`;
      return `${Math.round(kmh)} km/h`;
    }
    function fmtVario(mps) {
      if (!isFiniteNum(mps)) return "—";
      const sign = mps > 0.05 ? "+" : (mps < -0.05 ? "−" : "");
      return `${sign}${Math.abs(mps).toFixed(1)} m/s`;
    }
    function degToRad(d) { return d * Math.PI / 180; }
    function radToDeg(r) { return r * 180 / Math.PI; }
    function normDeg(d) {
      let x = d % 360;
      if (x < 0) x += 360;
      return x;
    }
    function angDiffDeg(a, b) {
      const d = Math.abs(normDeg(a) - normDeg(b));
      return Math.min(d, 360 - d);
    }

    // Haversine distance (meters)
    function distMeters(a, b) {
      const R = 6371000;
      const lat1 = degToRad(a.lat), lat2 = degToRad(b.lat);
      const dLat = degToRad(b.lat - a.lat);
      const dLon = degToRad(b.lon - a.lon);
      const s = Math.sin(dLat/2)**2 + Math.cos(lat1)*Math.cos(lat2)*Math.sin(dLon/2)**2;
      const c = 2 * Math.atan2(Math.sqrt(s), Math.sqrt(1-s));
      return R * c;
    }

    // Bearing from A to B (degrees, 0=N, 90=E)
    function bearingDeg(a, b) {
      const lat1 = degToRad(a.lat), lat2 = degToRad(b.lat);
      const dLon = degToRad(b.lon - a.lon);
      const y = Math.sin(dLon) * Math.cos(lat2);
      const x = Math.cos(lat1)*Math.sin(lat2) - Math.sin(lat1)*Math.cos(lat2)*Math.cos(dLon);
      return normDeg(radToDeg(Math.atan2(y, x)));
    }

    // Move point by distance (m) at bearing (deg)
    function movePoint(a, bearing, distM) {
      const R = 6371000;
      const br = degToRad(bearing);
      const lat1 = degToRad(a.lat);
      const lon1 = degToRad(a.lon);
      const dr = distM / R;

      const lat2 = Math.asin(Math.sin(lat1)*Math.cos(dr) + Math.cos(lat1)*Math.sin(dr)*Math.cos(br));
      const lon2 = lon1 + Math.atan2(Math.sin(br)*Math.sin(dr)*Math.cos(lat1), Math.cos(dr)-Math.sin(lat1)*Math.sin(lat2));
      return { lat: radToDeg(lat2), lon: radToDeg(lon2) };
    }

    // meteorological wind direction "from" -> drift direction "to"
    function windFromTo(windFromDeg) {
      return normDeg(windFromDeg + 180);
    }

    function safeJsonParse(s, fallback) {
      try { return JSON.parse(s); } catch { return fallback; }
    }

    function genId(prefix="id") {
      return `${prefix}_${Math.random().toString(16).slice(2)}_${Date.now().toString(16)}`;
    }

    function setStatus(msg) {
      const el = document.getElementById("appStatus");
      if (el) el.textContent = msg;
    }

    function showSnackbar(msg, ms=2000) {
      const wrap = document.getElementById("snackbar");
      const text = document.getElementById("snackbarText");
      if (!wrap || !text) return;
      text.textContent = msg;
      wrap.classList.remove("hidden");
      window.clearTimeout(showSnackbar._t);
      showSnackbar._t = window.setTimeout(() => wrap.classList.add("hidden"), ms);
    }

    function colorToTailwind(color) {
      // maps markerColor to Tailwind-ish classes
      const map = {
        fuchsia: { btn: "bg-fuchsia-500", ring: "#d946ef" },
        orange:  { btn: "bg-orange-500",  ring: "#f97316" },
        emerald: { btn: "bg-emerald-500", ring: "#10b981" },
        sky:     { btn: "bg-sky-400",     ring: "#38bdf8" },
        rose:    { btn: "bg-rose-500",    ring: "#f43f5e" },
        amber:   { btn: "bg-amber-400",   ring: "#fbbf24" }
      };
      return map[color] || map.fuchsia;
    }

    function persistAll() {
      try {
        localStorage.setItem(CONFIG.STORAGE_SETUP_KEY, JSON.stringify(STATE.setup));
        localStorage.setItem(CONFIG.STORAGE_WIND_KEY, JSON.stringify(STATE.wind.entries));
        localStorage.setItem(CONFIG.STORAGE_KEY, JSON.stringify({
          tasks: STATE.tasks,
          flight: STATE.flight,
          ui: { trackVisible: STATE.ui.trackVisible, trajVisible: STATE.ui.trajVisible }
        }));
        localStorage.setItem(CONFIG.STORAGE_ARCHIVE_KEY, JSON.stringify(STATE.archive));
        localStorage.setItem(CONFIG.STORAGE_KML_KEY, JSON.stringify(STATE.layers.kmlOverlays.map(o => ({
          id: o.id, name: o.name, visible: o.visible
        }))));
      } catch (e) {
        console.warn("persistAll failed", e);
      }
    }

    function restoreAll() {
      try {
        const setup = safeJsonParse(localStorage.getItem(CONFIG.STORAGE_SETUP_KEY) || "", null);
        if (setup && typeof setup === "object") {
          STATE.setup.unitSpeed = setup.unitSpeed || STATE.setup.unitSpeed;
          STATE.setup.gpsMinInterval = isFiniteNum(setup.gpsMinInterval) ? setup.gpsMinInterval : STATE.setup.gpsMinInterval;
          STATE.setup.trackMinDist = isFiniteNum(setup.trackMinDist) ? setup.trackMinDist : STATE.setup.trackMinDist;
          STATE.setup.trajMinutes = Array.isArray(setup.trajMinutes) ? setup.trajMinutes.map(n => Number(n)).filter(Number.isFinite) : STATE.setup.trajMinutes;
        }

        const wind = safeJsonParse(localStorage.getItem(CONFIG.STORAGE_WIND_KEY) || "", null);
        if (Array.isArray(wind)) {
          STATE.wind.entries = wind.filter(e => e && isFiniteNum(e.altM) && isFiniteNum(e.dirFromDeg) && isFiniteNum(e.speedKmh));
        }

        const core = safeJsonParse(localStorage.getItem(CONFIG.STORAGE_KEY) || "", null);
        if (core && typeof core === "object") {
          if (core.tasks && typeof core.tasks === "object") {
            STATE.tasks.list = Array.isArray(core.tasks.list) ? core.tasks.list : [];
            STATE.tasks.activeTaskId = core.tasks.activeTaskId || null;
          }
          if (core.flight && typeof core.flight === "object") {
            STATE.flight.active = !!core.flight.active;
            STATE.flight.startedTs = core.flight.startedTs || null;
            STATE.flight.track = Array.isArray(core.flight.track) ? core.flight.track : [];
            STATE.flight.markers = Array.isArray(core.flight.markers) ? core.flight.markers : [];
          }
          if (core.ui && typeof core.ui === "object") {
            STATE.ui.trackVisible = core.ui.trackVisible !== false;
            STATE.ui.trajVisible = core.ui.trajVisible !== false;
          }
        }

        const arch = safeJsonParse(localStorage.getItem(CONFIG.STORAGE_ARCHIVE_KEY) || "", null);
        if (Array.isArray(arch)) STATE.archive = arch;

      } catch (e) {
        console.warn("restoreAll failed", e);
      }
    }

    /*********************************************************************
     * 4) UI-Render-Funktionen
     *********************************************************************/
    function renderTaskTypeDropdown() {
      const sel = document.getElementById("taskType");
      if (!sel) return;
      sel.innerHTML = "";
      for (const t of CIA_TASKS) {
        const opt = document.createElement("option");
        opt.value = t.id;
        opt.textContent = `${t.id} ${t.code} — ${t.title}`;
        sel.appendChild(opt);
      }
    }

    function renderTaskPointsVisibility() {
      const cntSel = document.getElementById("taskPointsCount");
      const cnt = Number(cntSel?.value || 1);
      const b = document.getElementById("taskPointB");
      const c = document.getElementById("taskPointC");
      if (b) b.classList.toggle("hidden", cnt < 2);
      if (c) c.classList.toggle("hidden", cnt < 3);
    }

    function renderActiveTaskBox() {
      const label = document.getElementById("activeTaskLabel");
      const hint  = document.getElementById("activeTaskHint");
      const btnFinish = document.getElementById("btnFinish");

      const task = getActiveTask();
      if (!label || !hint || !btnFinish) return;

      if (!task) {
        label.textContent = "—";
        hint.textContent = "Keine Aufgabe aktiv.";
        btnFinish.classList.toggle("hidden", !STATE.flight.active);
        return;
      }

      label.textContent = `${task.typeId} ${task.typeCode} — ${task.title || task.typeTitle}`;
      hint.textContent = taskHint(task);
      btnFinish.classList.toggle("hidden", !STATE.flight.active);
    }

    function taskHint(task) {
      if (!task) return "—";
      if (task.typeCode === "3DT") {
        return "3DT: Innerer Kreis ungültig · Ring = Distanz maximieren · Außen = Zentrum anfliegen.";
      }
      if (task.typeCode === "ANG") {
        return "ANG: Winkel zwischen Vorgaberichtung und Linie A–B maximieren.";
      }
      if (task.typeCode === "LRN") {
        return "LRN: Fläche Dreieck A–B–C maximieren (Logger/Track).";
      }
      if (task.typeCode === "ELB") {
        return "ELB: Größte Richtungsänderung (180° − Winkel ABC).";
      }
      if (task.kind.includes("area")) {
        return "Area-Task: Nutze KML-Overlay oder setze Radius als Näherung.";
      }
      return "Zielnavigation: Distanz/Bearing zum Ziel wird angezeigt.";
    }

    function renderTaskList() {
      const wrap = document.getElementById("taskList");
      if (!wrap) return;
      wrap.innerHTML = "";

      if (!STATE.tasks.list.length) {
        const empty = document.createElement("div");
        empty.className = "text-sm text-slate-400";
        empty.textContent = "Noch keine Tasks angelegt.";
        wrap.appendChild(empty);
        return;
      }

      for (const t of STATE.tasks.list.slice().sort((a,b) => (b.createdTs||0)-(a.createdTs||0))) {
        const active = t.id === STATE.tasks.activeTaskId;

        const row = document.createElement("div");
        row.className = `rounded-2xl border ${active ? "border-emerald-500/40 bg-emerald-500/10" : "border-slate-800 bg-slate-950/40"} p-3`;
        row.innerHTML = `
          <div class="flex items-center gap-2">
            <div class="min-w-0">
              <div class="text-sm font-semibold truncate">${escapeHtml(`${t.typeId} ${t.typeCode} — ${t.title || t.typeTitle}`)}</div>
              <div class="text-[12px] text-slate-400 truncate">${escapeHtml(pointSummary(t))}</div>
            </div>
            <div class="flex-1"></div>
            <button data-act="activate" data-id="${t.id}" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">${active ? "Aktiv" : "Aktivieren"}</button>
          </div>
          <div class="mt-2 flex gap-2">
            <button data-act="zoom" data-id="${t.id}" class="flex-1 h-10 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold"><i class="fa-solid fa-magnifying-glass-location mr-2"></i>Zoom</button>
            <button data-act="delete" data-id="${t.id}" class="h-10 px-3 rounded-xl bg-slate-900 border border-rose-700/50 hover:bg-rose-900/30 text-xs font-semibold text-rose-200"><i class="fa-solid fa-trash mr-2"></i>Löschen</button>
          </div>
        `;
        wrap.appendChild(row);
      }

      wrap.querySelectorAll("button[data-act]").forEach(btn => {
        btn.addEventListener("click", () => {
          const act = btn.getAttribute("data-act");
          const id = btn.getAttribute("data-id");
          if (!id) return;
          if (act === "activate") setActiveTask(id);
          if (act === "zoom") zoomToTask(id);
          if (act === "delete") deleteTask(id);
        });
      });
    }

    function pointSummary(t) {
      if (!t || !Array.isArray(t.points) || !t.points.length) return "—";
      const first = t.points[0];
      const s = `${first.label}: ${first.lat.toFixed(5)}, ${first.lon.toFixed(5)}`;
      const r = [];
      if (isFiniteNum(t.r1M) && t.r1M > 0) r.push(`R1=${Math.round(t.r1M)}m`);
      if (isFiniteNum(t.r2M) && t.r2M > 0) r.push(`R2=${Math.round(t.r2M)}m`);
      return `${s}${r.length ? " · " + r.join(" · ") : ""}`;
    }

    function escapeHtml(s) {
      return String(s)
        .replaceAll("&", "&amp;")
        .replaceAll("<", "&lt;")
        .replaceAll(">", "&gt;")
        .replaceAll('"', "&quot;")
        .replaceAll("'", "&#039;");
    }

    function renderWindList() {
      const wrap = document.getElementById("windList");
      if (!wrap) return;
      wrap.innerHTML = "";

      const entries = STATE.wind.entries.slice().sort((a,b) => a.altM - b.altM);
      if (!entries.length) {
        const empty = document.createElement("div");
        empty.className = "text-sm text-slate-400";
        empty.textContent = "Noch keine Wind-Einträge.";
        wrap.appendChild(empty);
        return;
      }

      for (const e of entries) {
        const row = document.createElement("div");
        row.className = "rounded-2xl bg-slate-950/40 border border-slate-800 p-3";
        row.innerHTML = `
          <div class="flex items-center gap-2">
            <div class="min-w-0">
              <div class="text-sm font-semibold">${Math.round(e.altM)} m</div>
              <div class="text-[12px] text-slate-400 truncate">${Math.round(e.dirFromDeg)}° von · ${Math.round(e.speedKmh)} km/h · ${escapeHtml(e.source || "manuell")}</div>
            </div>
            <div class="flex-1"></div>
            <button data-del="${e.ts}" class="h-9 w-9 rounded-xl bg-slate-900 border border-rose-700/50 hover:bg-rose-900/30 text-rose-200" aria-label="Löschen">
              <i class="fa-solid fa-trash"></i>
            </button>
          </div>
        `;
        wrap.appendChild(row);
      }

      wrap.querySelectorAll("button[data-del]").forEach(btn => {
        btn.addEventListener("click", () => {
          const ts = Number(btn.getAttribute("data-del"));
          STATE.wind.entries = STATE.wind.entries.filter(x => x.ts !== ts);
          persistAll();
          renderWindList();
          renderWindHud();
          rebuildTrajectory();
          showSnackbar("Wind-Eintrag gelöscht.");
        });
      });
    }

    function renderWindHud() {
      const body = document.getElementById("windHudBody");
      const empty = document.getElementById("windHudEmpty");
      if (!body || !empty) return;

      body.innerHTML = "";
      const entries = STATE.wind.entries.slice().sort((a,b) => a.altM - b.altM);
      empty.classList.toggle("hidden", entries.length > 0);

      for (const e of entries) {
        const to = windFromTo(e.dirFromDeg);
        const tr = document.createElement("tr");
        tr.className = "border-t border-slate-800/60";
        tr.innerHTML = `
          <td class="py-2">${Math.round(e.altM)} m</td>
          <td class="py-2">
            <span class="inline-flex items-center gap-2">
              <span class="inline-block" style="transform: rotate(${Math.round(to)}deg)">➤</span>
              <span class="text-slate-300">${Math.round(e.dirFromDeg)}°</span>
            </span>
          </td>
          <td class="py-2 text-right">${Math.round(e.speedKmh)} km/h</td>
        `;
        body.appendChild(tr);
      }
    }

    function renderArchive() {
      const wrap = document.getElementById("archiveList");
      if (!wrap) return;
      wrap.innerHTML = "";

      if (!STATE.archive.length) {
        const empty = document.createElement("div");
        empty.className = "text-sm text-slate-400";
        empty.textContent = "Archiv ist leer.";
        wrap.appendChild(empty);
        return;
      }

      for (const f of STATE.archive.slice().sort((a,b)=> (b.finishedTs||0)-(a.finishedTs||0))) {
        const row = document.createElement("div");
        row.className = "rounded-2xl bg-slate-900/70 border border-slate-800 p-3";
        const pts = Array.isArray(f.track) ? f.track.length : 0;
        const mks = Array.isArray(f.markers) ? f.markers.length : 0;
        row.innerHTML = `
          <div class="flex items-center gap-2">
            <div class="min-w-0">
              <div class="text-sm font-semibold truncate">${escapeHtml(f.title || "Fahrt")}</div>
              <div class="text-[12px] text-slate-400 truncate">${escapeHtml(fmtTs(f.startedTs))} → ${escapeHtml(fmtTs(f.finishedTs))} · Track ${pts} · Marker ${mks}</div>
            </div>
            <div class="flex-1"></div>
            <button data-kml="${f.id}" class="h-9 px-3 rounded-xl bg-emerald-600 hover:bg-emerald-500 text-slate-950 text-xs font-extrabold">
              <i class="fa-solid fa-file-arrow-down mr-2"></i>KML Export
            </button>
          </div>
          <div class="mt-2 flex gap-2">
            <button data-zoomflight="${f.id}" class="flex-1 h-10 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold"><i class="fa-solid fa-magnifying-glass-location mr-2"></i>Zoom Track</button>
            <button data-delarch="${f.id}" class="h-10 px-3 rounded-xl bg-slate-900 border border-rose-700/50 hover:bg-rose-900/30 text-xs font-semibold text-rose-200"><i class="fa-solid fa-trash mr-2"></i>Löschen</button>
          </div>
        `;
        wrap.appendChild(row);
      }

      wrap.querySelectorAll("button[data-kml]").forEach(btn => {
        btn.addEventListener("click", () => exportFlightKml(btn.getAttribute("data-kml")));
      });
      wrap.querySelectorAll("button[data-delarch]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-delarch");
          if (!id) return;
          STATE.archive = STATE.archive.filter(x => x.id !== id);
          persistAll();
          renderArchive();
          showSnackbar("Archiv-Eintrag gelöscht.");
        });
      });
      wrap.querySelectorAll("button[data-zoomflight]").forEach(btn => {
        btn.addEventListener("click", () => zoomToFlight(btn.getAttribute("data-zoomflight")));
      });
    }

    function renderKmlLayersList() {
      const wrap = document.getElementById("kmlLayersList");
      if (!wrap) return;
      wrap.innerHTML = "";

      if (!STATE.layers.kmlOverlays.length) {
        const empty = document.createElement("div");
        empty.className = "text-sm text-slate-400";
        empty.textContent = "Keine KML Overlays geladen.";
        wrap.appendChild(empty);
        return;
      }

      for (const o of STATE.layers.kmlOverlays) {
        const row = document.createElement("div");
        row.className = "rounded-2xl bg-slate-950/40 border border-slate-800 p-3 flex items-center gap-2";
        row.innerHTML = `
          <div class="min-w-0">
            <div class="text-sm font-semibold truncate">${escapeHtml(o.name || "KML")}</div>
            <div class="text-[12px] text-slate-400 truncate">${o.visible ? "sichtbar" : "versteckt"}</div>
          </div>
          <div class="flex-1"></div>
          <button data-kmltoggle="${o.id}" class="h-9 px-3 rounded-xl bg-slate-900 border border-slate-700 hover:bg-slate-800 text-xs font-semibold">${o.visible ? "Ausblenden" : "Einblenden"}</button>
          <button data-kmldel="${o.id}" class="h-9 w-9 rounded-xl bg-slate-900 border border-rose-700/50 hover:bg-rose-900/30 text-rose-200" aria-label="Löschen">
            <i class="fa-solid fa-trash"></i>
          </button>
        `;
        wrap.appendChild(row);
      }

      wrap.querySelectorAll("button[data-kmltoggle]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-kmltoggle");
          const ov = STATE.layers.kmlOverlays.find(x => x.id === id);
          if (!ov || !STATE.map) return;
          ov.visible = !ov.visible;
          if (ov.visible) ov.layer.addTo(STATE.map);
          else STATE.map.removeLayer(ov.layer);
          persistAll();
          renderKmlLayersList();
          showSnackbar(ov.visible ? "KML eingeblendet." : "KML ausgeblendet.");
        });
      });

      wrap.querySelectorAll("button[data-kmldel]").forEach(btn => {
        btn.addEventListener("click", () => {
          const id = btn.getAttribute("data-kmldel");
          const idx = STATE.layers.kmlOverlays.findIndex(x => x.id === id);
          if (idx < 0 || !STATE.map) return;
          const ov = STATE.layers.kmlOverlays[idx];
          try { STATE.map.removeLayer(ov.layer); } catch {}
          STATE.layers.kmlOverlays.splice(idx,1);
          persistAll();
          renderKmlLayersList();
          showSnackbar("KML Overlay entfernt.");
        });
      });
    }

    function updateHeaderGpsStatus({ ok, accM, altM, speedKmh, provider }) {
      const el = document.getElementById("gpsStatus");
      if (!el) return;
      const fix = ok ? `Fix: ${Math.round(accM)}m` : "Fix: —";
      const spd = isFiniteNum(speedKmh) ? ` · ${fmtSpeedKmh(speedKmh)}` : "";
      const alt = isFiniteNum(altM) ? ` · ${Math.round(altM)}m` : "";
      el.textContent = `GPS: ${provider || "Real"} · ${fix}${alt}${spd}`;
    }

    function updateCockpitInstruments({ speedKmh, altM, varioMps }) {
      const gs = document.getElementById("instGS");
      const alt = document.getElementById("instALT");
      const vario = document.getElementById("instVARIO");
      if (gs) gs.textContent = fmtSpeedKmh(speedKmh);
      if (alt) alt.textContent = fmtAlt(altM);
      if (vario) vario.textContent = fmtVario(varioMps);
    }

    function updateMarkerButtonColor(colorName) {
      const btn = document.getElementById("btnMarker");
      if (!btn) return;
      // remove known bg classes
      btn.classList.remove("bg-fuchsia-500","bg-orange-500","bg-emerald-500","bg-sky-400","bg-rose-500","bg-amber-400");
      btn.classList.add(colorToTailwind(colorName).btn);
    }

    function showNavToast(title, sub) {
      const wrap = document.getElementById("navToast");
      const t = document.getElementById("navToastTitle");
      const s = document.getElementById("navToastSub");
      if (!wrap || !t || !s) return;
      t.textContent = title || "—";
      s.textContent = sub || "—";
      wrap.classList.remove("hidden");
    }

    function hideNavToast() {
      const wrap = document.getElementById("navToast");
      if (wrap) wrap.classList.add("hidden");
    }

    function updateStrategyLine(text) {
      const el = document.getElementById("strategyLine");
      if (el) el.textContent = text || "—";
    }

    function updateWakeBadge() {
      const badge = document.getElementById("wakeLockBadge");
      if (!badge) return;
      badge.classList.toggle("hidden", !STATE.wake.lock);
    }

    function renderAll() {
      renderActiveTaskBox();
      renderTaskList();
      renderWindList();
      renderWindHud();
      renderArchive();
      renderKmlLayersList();
      updateMarkerButtonColor(getActiveTask()?.markerColor || "fuchsia");
    }

    /*********************************************************************
     * 5) Kern-Logik (GPS, Map, Simulation)
     *********************************************************************/
    function initMap() {
      const map = L.map("map", { zoomControl: false });

      // Base layers
      STATE.layers.baseOSM = L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", {
        maxZoom: 19,
        attribution: "&copy; OpenStreetMap"
      });

      // Esri World Imagery
      STATE.layers.baseSAT = L.tileLayer(
        "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}",
        { maxZoom: 19, attribution: "Tiles &copy; Esri" }
      );

      STATE.layers.baseOSM.addTo(map);
      STATE.layers.activeBase = "OSM";

      // Overlays
      STATE.layers.track = L.layerGroup().addTo(map);
      STATE.layers.tasksLayer = L.layerGroup().addTo(map);
      STATE.layers.markersLayer = L.layerGroup().addTo(map);

      // Track polyline (created later)
      STATE.layers.trackLine = L.polyline([], { color: "#ef4444", weight: 4, opacity: 0.9 }).addTo(STATE.layers.track);

      // Trajectory lines
      STATE.layers.trajLines = [];

      // Balloon marker (rotating)
      const balloonIcon = L.divIcon({
        className: "",
        html: `
          <div class="balloon-marker">
            <div style="display:flex;flex-direction:column;align-items:center;line-height:1;">
              <i class="fa-solid fa-location-arrow"></i>
              <div class="balloon-needle"></div>
            </div>
          </div>
        `,
        iconSize: [44, 44],
        iconAnchor: [22, 22]
      });
      STATE.layers.balloonMarker = L.marker([CONFIG.DEFAULT_CENTER.lat, CONFIG.DEFAULT_CENTER.lon], { icon: balloonIcon, interactive: false }).addTo(map);

      // Center initial
      map.setView([CONFIG.DEFAULT_CENTER.lat, CONFIG.DEFAULT_CENTER.lon], CONFIG.DEFAULT_CENTER.zoom);

      // Simple zoom control bottom-right
      L.control.zoom({ position: "bottomright" }).addTo(map);

      STATE.map = map;

      // Draw from restored flight
      if (STATE.flight.track.length) {
        const latlngs = STATE.flight.track.map(p => [p.lat, p.lon]);
        STATE.layers.trackLine.setLatLngs(latlngs);
      }

      rebuildTaskOverlays();
      rebuildMarkersOverlays();
      rebuildTrajectory();

      setStatus(`Bereit · v${CONFIG.APP_VERSION}`);
    }

    function startGps() {
      if (!STATE.gps.supported) {
        showSnackbar("Geolocation nicht verfügbar.");
        updateHeaderGpsStatus({ ok:false, provider:"Real" });
        return;
      }

      // If already watching, stop first
      stopGps();

      try {
        STATE.gps.watching = true;
        const opts = {
          enableHighAccuracy: CONFIG.GPS.ENABLE_HIGH_ACCURACY,
          timeout: CONFIG.GPS.TIMEOUT_MS,
          maximumAge: CONFIG.GPS.MAX_AGE_MS
        };

        STATE.gps.watchId = navigator.geolocation.watchPosition(
          (pos) => {
            if (STATE.sim.enabled) return; // ignore in sim mode
            onGpsPosition(pos);
          },
          (err) => {
            console.warn("GPS error", err);
            updateHeaderGpsStatus({ ok:false, provider:"Real" });
            showSnackbar(`GPS Fehler: ${err?.message || err}`);
          },
          opts
        );
      } catch (e) {
        console.warn("startGps failed", e);
        showSnackbar("GPS konnte nicht gestartet werden.");
      }
    }

    function stopGps() {
      try {
        if (STATE.gps.watchId !== null && navigator.geolocation) {
          navigator.geolocation.clearWatch(STATE.gps.watchId);
        }
      } catch {}
      STATE.gps.watchId = null;
      STATE.gps.watching = false;
    }

    function onGpsPosition(pos) {
      const ts = pos?.timestamp || Date.now();
      const c = pos?.coords;
      if (!c) return;

      // app-level throttling
      if (ts - STATE.gps.lastUIUpdateTs < STATE.setup.gpsMinInterval) return;
      STATE.gps.lastUIUpdateTs = ts;

      const lat = c.latitude;
      const lon = c.longitude;
      const acc = c.accuracy;
      const alt = isFiniteNum(c.altitude) ? c.altitude : null;
      const spdMps = isFiniteNum(c.speed) ? c.speed : null;
      const spdKmh = isFiniteNum(spdMps) ? (spdMps * 3.6) : null;

      // Heading: use sensor if available else compute from last track point
      let heading = isFiniteNum(c.heading) ? c.heading : null;

      const pt = { lat, lon, altM: alt, ts };

      if (heading === null && STATE.gps.lastTrackPt) {
        const last = STATE.gps.lastTrackPt;
        heading = bearingDeg({ lat:last.lat, lon:last.lon }, { lat, lon });
      }

      // Vario from last alt
      let vario = null;
      if (STATE.gps.lastAltM !== null && alt !== null && STATE.gps.lastTrackPt) {
        const dt = (ts - STATE.gps.lastTrackPt.ts) / 1000;
        if (dt > 0.2) vario = (alt - STATE.gps.lastAltM) / dt;
      }
      STATE.gps.lastAltM = alt !== null ? alt : STATE.gps.lastAltM;

      updateHeaderGpsStatus({ ok:true, accM: acc, altM: alt, speedKmh: spdKmh, provider:"Real" });
      updateCockpitInstruments({ speedKmh: spdKmh, altM: alt, varioMps: vario });

      // Update balloon marker + rotation
      updateBalloonMarker(lat, lon, heading);

      // Start flight automatically on first good fix if not active
      if (!STATE.flight.active) {
        beginFlight("Live Flight");
      }

      // Track logging
      maybeAddTrackPoint(pt);

      // Auto wind recording
      maybeAutoRecordWind({ altM: alt, headingToDeg: heading, speedKmh: spdKmh, ts });

      // Strategy + nav toast
      updateNavAndStrategy();

      // Persist occasionally
      persistAll();
    }

    function updateBalloonMarker(lat, lon, headingDegVal) {
      if (!STATE.layers.balloonMarker) return;
      try {
        STATE.layers.balloonMarker.setLatLng([lat, lon]);
        const iconEl = STATE.layers.balloonMarker.getElement();
        if (iconEl && headingDegVal !== null && headingDegVal !== undefined) {
          // rotate the whole marker around center
          iconEl.style.transformOrigin = "center center";
          iconEl.style.transform = `rotate(${Math.round(headingDegVal)}deg)`;
        }
      } catch {}
    }

    function beginFlight(title) {
      STATE.flight.active = true;
      STATE.flight.startedTs = Date.now();
      STATE.flight.track = STATE.flight.track || [];
      STATE.flight.markers = STATE.flight.markers || [];
      document.getElementById("btnFinish")?.classList.remove("hidden");
      showSnackbar("Fahrt gestartet.");
    }

    function finishFlight() {
      if (!STATE.flight.active) return;

      const finishedTs = Date.now();
      const activeTask = getActiveTask();
      const title = activeTask ? `${activeTask.typeCode} — ${activeTask.title || activeTask.typeTitle}` : "Fahrt";

      const entry = {
        id: genId("flight"),
        title,
        startedTs: STATE.flight.startedTs,
        finishedTs,
        track: STATE.flight.track.slice(),
        markers: STATE.flight.markers.slice(),
        tasksSnapshot: {
          activeTaskId: STATE.tasks.activeTaskId,
          list: STATE.tasks.list.slice()
        },
        windSnapshot: STATE.wind.entries.slice()
      };

      STATE.archive.push(entry);

      // Reset current flight
      STATE.flight.active = false;
      STATE.flight.startedTs = null;
      STATE.flight.track = [];
      STATE.flight.markers = [];

      // Clear map layers
      try { STATE.layers.trackLine.setLatLngs([]); } catch {}
      try { STATE.layers.markersLayer.clearLayers(); } catch {}

      document.getElementById("btnFinish")?.classList.add("hidden");

      persistAll();
      renderArchive();
      rebuildMarkersOverlays();
      showSnackbar("Fahrt beendet & archiviert.");
    }

    function maybeAddTrackPoint(pt) {
      if (!STATE.flight.active) return;

      const last = STATE.gps.lastTrackPt;
      const minDist = STATE.setup.trackMinDist;

      if (!last) {
        // first
        STATE.gps.lastTrackPt = { lat: pt.lat, lon: pt.lon, altM: pt.altM, ts: pt.ts };
        STATE.flight.track.push({ lat: pt.lat, lon: pt.lon, altM: pt.altM ?? null, ts: pt.ts });
        appendTrackToMap(pt.lat, pt.lon);
        return;
      }

      const d = distMeters({ lat:last.lat, lon:last.lon }, { lat:pt.lat, lon:pt.lon });
      if (d < minDist) return;

      STATE.gps.lastTrackPt = { lat: pt.lat, lon: pt.lon, altM: pt.altM, ts: pt.ts };
      STATE.flight.track.push({ lat: pt.lat, lon: pt.lon, altM: pt.altM ?? null, ts: pt.ts });

      appendTrackToMap(pt.lat, pt.lon);
      rebuildTrajectory(); // keep it live
    }

    function appendTrackToMap(lat, lon) {
      if (!STATE.ui.trackVisible) return;
      if (!STATE.layers.trackLine) return;
      try {
        const latlngs = STATE.layers.trackLine.getLatLngs();
        latlngs.push([lat, lon]);
        STATE.layers.trackLine.setLatLngs(latlngs);
      } catch {}
    }

    function maybeAutoRecordWind({ altM, headingToDeg, speedKmh, ts }) {
      if (!isFiniteNum(altM) || !isFiniteNum(headingToDeg) || !isFiniteNum(speedKmh)) return;
      if (speedKmh < CONFIG.WIND_AUTO.MIN_GS_KMH) return;

      const last = STATE.gps.lastWindAuto;
      if (!last) {
        STATE.gps.lastWindAuto = { altM, headingToDeg, speedKmh, ts };
        addWindEntry({ altM, dirFromDeg: windFromTo(headingToDeg + 180) /* noop */, speedKmh, source: "auto(gps)" });
        return;
      }

      const altDelta = Math.abs(altM - last.altM);
      const crsDelta = angDiffDeg(headingToDeg, last.headingToDeg);

      if (altDelta >= CONFIG.WIND_AUTO.ALT_DELTA_M || crsDelta >= CONFIG.WIND_AUTO.CRS_DELTA_DEG) {
        STATE.gps.lastWindAuto = { altM, headingToDeg, speedKmh, ts };
        // Convert drift heading (to) -> wind from
        const dirFrom = normDeg(headingToDeg + 180);
        addWindEntry({ altM, dirFromDeg: dirFrom, speedKmh, source: "auto(gps)" });
      }
    }

    function addWindEntry({ altM, dirFromDeg, speedKmh, source }) {
      if (!isFiniteNum(altM) || !isFiniteNum(dirFromDeg) || !isFiniteNum(speedKmh)) return;
      const e = {
        altM: Math.round(altM),
        dirFromDeg: normDeg(dirFromDeg),
        speedKmh: Math.max(0, speedKmh),
        ts: Date.now(),
        source: source || "manuell"
      };
      // merge if a very close altitude exists (avoid spam)
      const nearIdx = STATE.wind.entries.findIndex(x => Math.abs(x.altM - e.altM) <= 10 && x.source === e.source);
      if (nearIdx >= 0) STATE.wind.entries.splice(nearIdx, 1, e);
      else STATE.wind.entries.push(e);

      persistAll();
      renderWindList();
      renderWindHud();
      rebuildTrajectory();
    }

    function getActiveTask() {
      const id = STATE.tasks.activeTaskId;
      if (!id) return null;
      return STATE.tasks.list.find(t => t.id === id) || null;
    }

    function setActiveTask(taskId) {
      const t = STATE.tasks.list.find(x => x.id === taskId);
      if (!t) return;
      STATE.tasks.activeTaskId = taskId;
      persistAll();
      renderActiveTaskBox();
      renderTaskList();
      rebuildTaskOverlays();
      updateMarkerButtonColor(t.markerColor || "fuchsia");
      updateNavAndStrategy();
      showSnackbar("Task aktiviert.");
    }

    function deactivateTask() {
      STATE.tasks.activeTaskId = null;
      persistAll();
      renderActiveTaskBox();
      renderTaskList();
      rebuildTaskOverlays();
      updateMarkerButtonColor("fuchsia");
      updateNavAndStrategy();
      showSnackbar("Task deaktiviert.");
    }

    function deleteTask(taskId) {
      const t = STATE.tasks.list.find(x => x.id === taskId);
      if (!t) return;
      STATE.tasks.list = STATE.tasks.list.filter(x => x.id !== taskId);
      if (STATE.tasks.activeTaskId === taskId) STATE.tasks.activeTaskId = null;
      persistAll();
      renderAll();
      rebuildTaskOverlays();
      updateNavAndStrategy();
      showSnackbar("Task gelöscht.");
    }

    function zoomToTask(taskId) {
      const t = STATE.tasks.list.find(x => x.id === taskId);
      if (!t || !STATE.map || !t.points?.length) return;
      const latlngs = t.points.map(p => L.latLng(p.lat, p.lon));
      const bounds = L.latLngBounds(latlngs);
      if (bounds.isValid()) STATE.map.fitBounds(bounds.pad(0.25));
      showSnackbar("Zoom auf Task.");
    }

    function zoomToFlight(flightId) {
      const f = STATE.archive.find(x => x.id === flightId);
      if (!f || !STATE.map || !Array.isArray(f.track) || !f.track.length) return;
      const latlngs = f.track.map(p => L.latLng(p.lat, p.lon));
      const bounds = L.latLngBounds(latlngs);
      if (bounds.isValid()) STATE.map.fitBounds(bounds.pad(0.2));
      showSnackbar("Zoom auf Track.");
    }

    function rebuildTaskOverlays() {
      if (!STATE.layers.tasksLayer) return;
      try { STATE.layers.tasksLayer.clearLayers(); } catch {}

      for (const t of STATE.tasks.list) {
        drawTask(t, t.id === STATE.tasks.activeTaskId);
      }
    }

    function drawTask(t, isActive) {
      if (!STATE.layers.tasksLayer || !t?.points?.length) return;

      const color = colorToTailwind(t.markerColor || "fuchsia").ring;
      const weight = isActive ? 4 : 2;
      const opacity = isActive ? 0.95 : 0.6;

      // Points
      const pts = t.points.map(p => ({ ...p }));

      for (const p of pts) {
        const m = L.circleMarker([p.lat, p.lon], {
          radius: isActive ? 9 : 7,
          color,
          weight: isActive ? 3 : 2,
          fillColor: color,
          fillOpacity: 0.35
        }).addTo(STATE.layers.tasksLayer);
        m.bindTooltip(`${t.typeCode} ${p.label}`, { direction: "top", offset: [0,-8], opacity: 0.9 });
      }

      // Circles / Donut
      const center = pts[0];
      if (isFiniteNum(t.r2M) && t.r2M > 0) {
        L.circle([center.lat, center.lon], { radius: t.r2M, color, weight, opacity, fillOpacity: 0.06 }).addTo(STATE.layers.tasksLayer);
      }
      if (isFiniteNum(t.r1M) && t.r1M > 0) {
        L.circle([center.lat, center.lon], { radius: t.r1M, color, weight, opacity: opacity*0.9, fillOpacity: 0.02, dashArray: "4 6" }).addTo(STATE.layers.tasksLayer);
      }

      // Connection lines for multi-point tasks
      if (pts.length >= 2) {
        const line = L.polyline(pts.map(p => [p.lat, p.lon]), { color: "#60a5fa", weight: isActive ? 4 : 2, opacity: isActive ? 0.9 : 0.55 }).addTo(STATE.layers.tasksLayer);
        line.bindTooltip(`${t.typeId} ${t.typeCode} Linie`, { opacity: 0.9 });
      }

      // ANG direction helper (from A, show "set direction")
      if (t.typeCode === "ANG" && isFiniteNum(t.angleDeg) && pts[0]) {
        const lenM = 1200;
        const toPt = movePoint({ lat: pts[0].lat, lon: pts[0].lon }, normDeg(t.angleDeg), lenM);
        L.polyline([[pts[0].lat, pts[0].lon],[toPt.lat, toPt.lon]], { color: "#fbbf24", weight: 3, opacity: 0.85, dashArray: "6 6" }).addTo(STATE.layers.tasksLayer)
          .bindTooltip(`Vorgaberichtung ${Math.round(t.angleDeg)}°`, { opacity: 0.9 });
      }
    }

    function rebuildMarkersOverlays() {
      if (!STATE.layers.markersLayer) return;
      try { STATE.layers.markersLayer.clearLayers(); } catch {}

      const markers = STATE.flight.active ? STATE.flight.markers : [];
      for (const m of markers) drawMarker(m);
    }

    function drawMarker(m) {
      if (!STATE.layers.markersLayer) return;
      const c = colorToTailwind(m.color || "fuchsia").ring;
      const mk = L.circleMarker([m.lat, m.lon], {
        radius: 8,
        color: c,
        weight: 3,
        fillColor: c,
        fillOpacity: 0.35
      }).addTo(STATE.layers.markersLayer);

      mk.bindTooltip(`Marker · ${fmtTs(m.ts)}`, { opacity: 0.95 });
    }

    function getCurrentPosition() {
      if (STATE.sim.enabled) return { lat: STATE.sim.state.lat, lon: STATE.sim.state.lon, altM: STATE.sim.state.altM, ts: STATE.sim.state.ts, provider: "Sim" };
      const last = STATE.gps.lastTrackPt;
      if (!last) return null;
      return { lat: last.lat, lon: last.lon, altM: last.altM ?? null, ts: last.ts, provider: "Real" };
    }

    function centerMap() {
      const p = getCurrentPosition();
      if (!p || !STATE.map) return;
      STATE.map.setView([p.lat, p.lon], Math.max(STATE.map.getZoom(), 14), { animate: true });
    }

    function rebuildTrajectory() {
      if (!STATE.map) return;

      // remove old
      for (const l of STATE.layers.trajLines) {
        try { STATE.map.removeLayer(l); } catch {}
      }
      STATE.layers.trajLines = [];

      if (!STATE.ui.trajVisible) return;

      const p = getCurrentPosition();
      if (!p) return;

      const wind = getWindAtAltitude(p.altM ?? 0);
      if (!wind) return;

      const mins = STATE.setup.trajMinutes;
      const dirTo = windFromTo(wind.dirFromDeg);
      const speedMps = wind.speedKmh / 3.6;

      for (const m of mins) {
        const dist = speedMps * (m * 60);
        const q = movePoint({ lat:p.lat, lon:p.lon }, dirTo, dist);
        const poly = L.polyline([[p.lat,p.lon],[q.lat,q.lon]], {
          color: "#22c55e",
          weight: 4,
          opacity: 0.75,
          dashArray: m === mins[0] ? null : (m === mins[1] ? "8 8" : "3 10")
        }).addTo(STATE.map);
        poly.bindTooltip(`Traj ${m} min · ${Math.round(dist)} m`, { opacity: 0.9 });
        STATE.layers.trajLines.push(poly);
      }
    }

    function getWindAtAltitude(altM) {
      const entries = STATE.wind.entries.slice().sort((a,b)=>a.altM-b.altM);
      if (!entries.length) return null;

      // direct nearest (simple + robust)
      let best = entries[0];
      let bestD = Math.abs(entries[0].altM - altM);
      for (const e of entries) {
        const d = Math.abs(e.altM - altM);
        if (d < bestD) { best = e; bestD = d; }
      }
      return best;
    }

    function updateNavAndStrategy() {
      const pos = getCurrentPosition();
      const task = getActiveTask();

      if (!pos || !task) {
        hideNavToast();
        updateStrategyLine(STATE.wind.entries.length ? "Kein aktiver Task." : "Kein Windprofil. Lade Winddaten.");
        return;
      }

      updateMarkerButtonColor(task.markerColor || "fuchsia");

      // Distance to primary target A (best effort)
      const target = task.points?.[0];
      if (!target) {
        hideNavToast();
        updateStrategyLine("Task ohne Zielpunkt A.");
        return;
      }

      const d = distMeters({ lat:pos.lat, lon:pos.lon }, { lat:target.lat, lon:target.lon });
      const brg = bearingDeg({ lat:pos.lat, lon:pos.lon }, { lat:target.lat, lon:target.lon });

      // Toast content
      showNavToast(`${task.typeCode} · ${task.title || task.typeTitle}`, `Distanz: ${fmtDist(d)} · Bearing: ${Math.round(brg)}°`);

      // 3DT special
      if (task.typeCode === "3DT" && isFiniteNum(task.r1M) && isFiniteNum(task.r2M) && task.r2M > 0) {
        const inner = task.r1M || 0;
        const outer = task.r2M;
        let msg = "3DT: ";
        if (d < inner) msg += "Ungültig (innerer Kreis). Raus in den Ring!";
        else if (d <= outer) msg += "Im Ring: Distanz maximieren (Track).";
        else msg += "Außerhalb: Ziel = Zentrum anfliegen.";
        updateStrategyLine(msg);
        return;
      }

      // Best layer recommendation (angle match to target bearing)
      if (!STATE.wind.entries.length) {
        updateStrategyLine("Kein Windprofil. Lade Winddaten.");
        return;
      }

      const best = chooseBestWindLayer({ pos, targetBearingDeg: brg });
      if (!best) {
        updateStrategyLine("Kein passender Windlayer.");
        return;
      }

      const altNow = pos.altM ?? null;
      const altTarget = best.altM;
      let rec = "Layer: ";
      rec += `${Math.round(best.altM)}m · Wind ${Math.round(best.dirFromDeg)}°/${Math.round(best.speedKmh)} km/h`;

      if (isFiniteNum(altNow)) {
        const delta = altTarget - altNow;
        if (Math.abs(delta) < 40) rec = `Halten auf ~${Math.round(altTarget)}m · ${rec}`;
        else if (delta > 0) rec = `Steigen auf ${Math.round(altTarget)}m (+${Math.round(delta)}m) · ${rec}`;
        else rec = `Sinken auf ${Math.round(altTarget)}m (${Math.round(delta)}m) · ${rec}`;
      } else {
        rec = `Empfehlung: ${Math.round(altTarget)}m · ${rec}`;
      }

      updateStrategyLine(rec);
    }

    function chooseBestWindLayer({ pos, targetBearingDeg }) {
      const entries = STATE.wind.entries.slice().sort((a,b)=>a.altM-b.altM);
      if (!entries.length) return null;

      // minimize angular difference between drift direction and bearing-to-target
      let best = null;
      let bestScore = Infinity;

      for (const e of entries) {
        const driftTo = windFromTo(e.dirFromDeg);
        const diff = angDiffDeg(driftTo, targetBearingDeg);

        // slight preference for more speed (faster correction)
        const speedBonus = clamp(e.speedKmh, 0, 40) / 40; // 0..1
        const score = diff - speedBonus * 6; // up to 6° improvement

        if (score < bestScore) {
          bestScore = score;
          best = e;
        }
      }
      return best;
    }

    function dropMarker() {
      const pos = getCurrentPosition();
      if (!pos) {
        showSnackbar("Keine Position verfügbar.");
        return;
      }
      if (!STATE.flight.active) beginFlight("Live Flight");

      const task = getActiveTask();
      const color = task?.markerColor || "fuchsia";

      const m = { lat: pos.lat, lon: pos.lon, altM: pos.altM ?? null, ts: Date.now(), color, label: "Marker" };
      STATE.flight.markers.push(m);
      drawMarker(m);
      persistAll();
      showSnackbar("Marker gesetzt.");
    }

    async function fetchWindFromOpenMeteo() {
      const pos = getCurrentPosition();
      if (!pos) {
        showSnackbar("Keine Position für Online-Wind.");
        return;
      }

      const levels = CONFIG.OPEN_METEO.PRESSURE_LEVELS.map(x => x.hPa);
      const hourlyVars = [];

      // wind speed/direction + geopotential height for precise level alt
      for (const hPa of levels) {
        hourlyVars.push(`wind_speed_${hPa}hPa`);
        hourlyVars.push(`wind_direction_${hPa}hPa`);
        hourlyVars.push(`geopotential_height_${hPa}hPa`);
      }

      const url = new URL(CONFIG.OPEN_METEO.BASE_URL);
      url.searchParams.set("latitude", String(pos.lat));
      url.searchParams.set("longitude", String(pos.lon));
      url.searchParams.set("hourly", hourlyVars.join(","));
      url.searchParams.set("wind_speed_unit", "kmh");
      url.searchParams.set("timezone", "auto");
      url.searchParams.set("forecast_hours", "6"); // small window
      url.searchParams.set("past_hours", "0");

      showSnackbar("Lade Open-Meteo Wind…", 1800);

      try {
        const res = await fetch(url.toString(), { method: "GET" });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();

        const hourly = data?.hourly;
        if (!hourly || !Array.isArray(hourly.time)) throw new Error("Ungültige API-Antwort");

        // pick the closest time to "now"
        const now = Date.now();
        let idx = 0;
        let best = Infinity;
        for (let i=0;i<hourly.time.length;i++) {
          const t = Date.parse(hourly.time[i]);
          if (!Number.isFinite(t)) continue;
          const d = Math.abs(t - now);
          if (d < best) { best = d; idx = i; }
        }

        let added = 0;
        for (const meta of CONFIG.OPEN_METEO.PRESSURE_LEVELS) {
          const hPa = meta.hPa;

          const sp = hourly[`wind_speed_${hPa}hPa`];
          const di = hourly[`wind_direction_${hPa}hPa`];
          const gh = hourly[`geopotential_height_${hPa}hPa`];

          const spv = Array.isArray(sp) ? sp[idx] : null;
          const div = Array.isArray(di) ? di[idx] : null;
          const ghv = Array.isArray(gh) ? gh[idx] : null;

          if (Number.isFinite(spv) && Number.isFinite(div)) {
            // Use geopotential height if available, else fallback to approx
            const alt = Number.isFinite(ghv) ? ghv : meta.approxM;
            addWindEntry({ altM: alt, dirFromDeg: div, speedKmh: spv, source: "open-meteo" });
            added++;
          }
        }

        if (added) {
          showSnackbar(`Open-Meteo: ${added} Layer aktualisiert.`);
        } else {
          showSnackbar("Open-Meteo: Keine Winddaten gefunden.");
        }
      } catch (e) {
        console.warn("Open-Meteo failed", e);
        showSnackbar(`Open-Meteo Fehler: ${e?.message || e}`);
      }
    }

    function startSimulation() {
      stopGps();

      // If no wind, still allow sim but it won't drift
      STATE.sim.enabled = true;
      document.getElementById("simControls")?.classList.remove("hidden");

      // init sim at last known position or default
      const last = STATE.gps.lastTrackPt;
      if (last) {
        STATE.sim.state.lat = last.lat;
        STATE.sim.state.lon = last.lon;
        STATE.sim.state.altM = last.altM ?? 120;
      } else {
        STATE.sim.state.lat = CONFIG.DEFAULT_CENTER.lat;
        STATE.sim.state.lon = CONFIG.DEFAULT_CENTER.lon;
        STATE.sim.state.altM = 120;
      }
      STATE.sim.state.ts = Date.now();
      STATE.sim.state.speedKmh = 0;

      // Ensure flight is active
      if (!STATE.flight.active) beginFlight("Sim Flight");

      // Tick @ 1 Hz
      window.clearInterval(STATE.sim.timerId);
      STATE.sim.timerId = window.setInterval(() => simTick(), 1000);

      updateHeaderGpsStatus({ ok:true, accM: 0, altM: STATE.sim.state.altM, speedKmh: STATE.sim.state.speedKmh, provider:"Sim" });
      centerMap();
      rebuildTrajectory();
      showSnackbar("Simulation aktiviert.");
    }

    function stopSimulation() {
      STATE.sim.enabled = false;
      document.getElementById("simControls")?.classList.add("hidden");
      window.clearInterval(STATE.sim.timerId);
      STATE.sim.timerId = null;
      STATE.sim.verticalRateMps = 0;
      startGps();
      showSnackbar("Simulation deaktiviert.");
    }

    function simTick() {
      const s = STATE.sim.state;
      const ts = Date.now();
      const dt = (ts - s.ts) / 1000;
      s.ts = ts;

      // vertical
      s.altM = Math.max(0, s.altM + STATE.sim.verticalRateMps * dt);

      // drift from wind profile
      const w = getWindAtAltitude(s.altM);
      let speedKmh = 0;
      let headingTo = 0;
      if (w) {
        speedKmh = w.speedKmh;
        headingTo = windFromTo(w.dirFromDeg);
        const distM = (speedKmh/3.6) * dt;
        const np = movePoint({ lat: s.lat, lon: s.lon }, headingTo, distM);
        s.lat = np.lat;
        s.lon = np.lon;
      }

      s.speedKmh = speedKmh;
      s.headingDeg = headingTo;

      // update UI + map
      updateHeaderGpsStatus({ ok:true, accM: 0, altM: s.altM, speedKmh: s.speedKmh, provider:"Sim" });

      // compute vario (use vertical rate as truth)
      updateCockpitInstruments({ speedKmh: s.speedKmh, altM: s.altM, varioMps: STATE.sim.verticalRateMps });

      updateBalloonMarker(s.lat, s.lon, s.headingDeg);

      // Track
      maybeAddTrackPoint({ lat: s.lat, lon: s.lon, altM: s.altM, ts: ts });

      updateNavAndStrategy();
      persistAll();
    }

    function setSimVerticalRate(rateMps) {
      STATE.sim.verticalRateMps = rateMps;
    }

    function exportFlightKml(flightId) {
      const f = STATE.archive.find(x => x.id === flightId);
      if (!f) {
        showSnackbar("Fahrt nicht gefunden.");
        return;
      }

      try {
        const kml = buildKmlForFlight(f);
        const blob = new Blob([kml], { type: "application/vnd.google-earth.kml+xml" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `${sanitizeFilename(f.title || "flight")}_${new Date(f.finishedTs||Date.now()).toISOString().slice(0,19).replaceAll(":","-")}.kml`;
        document.body.appendChild(a);
        a.click();
        a.remove();
        URL.revokeObjectURL(url);
        showSnackbar("KML Export gestartet.");
      } catch (e) {
        console.warn("KML export failed", e);
        showSnackbar("KML Export fehlgeschlagen.");
      }
    }

    function sanitizeFilename(s) {
      return String(s).replace(/[^\w\-]+/g, "_").slice(0, 60);
    }

    function buildKmlForFlight(f) {
      const name = escapeXml(f.title || "Flight");
      const track = Array.isArray(f.track) ? f.track : [];
      const markers = Array.isArray(f.markers) ? f.markers : [];

      const coords = track.map(p => {
        const alt = isFiniteNum(p.altM) ? p.altM : 0;
        return `${p.lon},${p.lat},${alt}`;
      }).join(" ");

      const markerPlacemarks = markers.map((m, idx) => {
        const alt = isFiniteNum(m.altM) ? m.altM : 0;
        const when = new Date(m.ts).toISOString();
        const mName = `Marker ${idx+1}`;
        return `
          <Placemark>
            <name>${escapeXml(mName)}</name>
            <TimeStamp><when>${escapeXml(when)}</when></TimeStamp>
            <Point><coordinates>${m.lon},${m.lat},${alt}</coordinates></Point>
          </Placemark>
        `.trim();
      }).join("\n");

      // Valid KML 2.2 – simple & widely compatible
      return `<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <name>${name}</name>
    <Folder>
      <name>Track</name>
      <Placemark>
        <name>Flight Track</name>
        <Style>
          <LineStyle><color>ff4444ef</color><width>4</width></LineStyle>
        </Style>
        <LineString>
          <tessellate>1</tessellate>
          <altitudeMode>absolute</altitudeMode>
          <coordinates>${coords}</coordinates>
        </LineString>
      </Placemark>
    </Folder>
    <Folder>
      <name>Markers</name>
      ${markerPlacemarks}
    </Folder>
  </Document>
</kml>`;
    }

    function escapeXml(s) {
      return String(s)
        .replaceAll("&","&amp;")
        .replaceAll("<","&lt;")
        .replaceAll(">","&gt;")
        .replaceAll('"',"&quot;")
        .replaceAll("'","&apos;");
    }

    function setBaseLayer(name) {
      if (!STATE.map) return;
      if (name === "OSM") {
        try { STATE.map.removeLayer(STATE.layers.baseSAT); } catch {}
        try { STATE.layers.baseOSM.addTo(STATE.map); } catch {}
        STATE.layers.activeBase = "OSM";
      } else {
        try { STATE.map.removeLayer(STATE.layers.baseOSM); } catch {}
        try { STATE.layers.baseSAT.addTo(STATE.map); } catch {}
        STATE.layers.activeBase = "SAT";
      }
      showSnackbar(`Basemap: ${STATE.layers.activeBase}`);
    }

    async function toggleWakeLock() {
      if (!STATE.wake.supported) {
        showSnackbar("Wake Lock nicht unterstützt.");
        return;
      }

      try {
        if (STATE.wake.lock) {
          await STATE.wake.lock.release();
          STATE.wake.lock = null;
          updateWakeBadge();
          document.getElementById("btnWakeLock").textContent = "Aktivieren";
          showSnackbar("Wake Lock aus.");
        } else {
          STATE.wake.lock = await navigator.wakeLock.request("screen");
          updateWakeBadge();
          document.getElementById("btnWakeLock").textContent = "Deaktivieren";
          showSnackbar("Wake Lock an.");
          STATE.wake.lock.addEventListener("release", () => {
            STATE.wake.lock = null;
            updateWakeBadge();
            const b = document.getElementById("btnWakeLock");
            if (b) b.textContent = "Aktivieren";
          });
        }
      } catch (e) {
        console.warn("WakeLock failed", e);
        showSnackbar("Wake Lock Fehler.");
      }
    }

    async function importKmlFile(file) {
      if (!file || !STATE.map) return;
      try {
        const text = await file.text();
        const blob = new Blob([text], { type: "application/vnd.google-earth.kml+xml" });
        const url = URL.createObjectURL(blob);

        const layer = omnivore.kml(url);
        const id = genId("kml");
        const name = file.name || "KML";

        layer.on("ready", () => {
          try {
            layer.addTo(STATE.map);
            // best-effort style: blue-ish
            try { layer.setStyle && layer.setStyle({ color:"#60a5fa", weight:3, opacity:0.8 }); } catch {}
            try {
              const b = layer.getBounds?.();
              if (b && b.isValid && b.isValid()) STATE.map.fitBounds(b.pad(0.15));
            } catch {}
          } finally {
            URL.revokeObjectURL(url);
          }
        });

        layer.on("error", (e) => {
          console.warn("KML load error", e);
          URL.revokeObjectURL(url);
          showSnackbar("KML Import fehlgeschlagen.");
        });

        STATE.layers.kmlOverlays.push({ id, name, layer, visible: true });

        persistAll();
        renderKmlLayersList();
        showSnackbar("KML geladen.");
      } catch (e) {
        console.warn("importKmlFile failed", e);
        showSnackbar("KML Import fehlgeschlagen.");
      }
    }

    function rebuildOverlays() {
      rebuildTaskOverlays();
      rebuildMarkersOverlays();
      rebuildTrajectory();
      showSnackbar("Overlays neu gezeichnet.");
    }

    /*********************************************************************
     * 6) Event-Listener & Initialisierung (window.onload am Ende)
     *********************************************************************/
    window.onload = () => {
      // Restore state
      restoreAll();

      // UI init
      renderTaskTypeDropdown();

      // Fill defaults in setup UI
      const unitSpeed = document.getElementById("unitSpeed");
      const trajMinutes = document.getElementById("trajMinutes");
      const gpsMinInterval = document.getElementById("gpsMinInterval");
      const trackMinDist = document.getElementById("trackMinDist");

      if (unitSpeed) unitSpeed.value = STATE.setup.unitSpeed;
      if (gpsMinInterval) gpsMinInterval.value = String(STATE.setup.gpsMinInterval);
      if (trackMinDist) trackMinDist.value = String(STATE.setup.trackMinDist);
      if (trajMinutes) trajMinutes.value = STATE.setup.trajMinutes.join(",");

      const toggleTrack = document.getElementById("toggleTrack");
      const toggleTraj = document.getElementById("toggleTraj");
      if (toggleTrack) toggleTrack.checked = STATE.ui.trackVisible;
      if (toggleTraj) toggleTraj.checked = STATE.ui.trajVisible;

      // Initialize map
      initMap();

      // Populate task form defaults
      const tSel = document.getElementById("taskType");
      const ptsCnt = document.getElementById("taskPointsCount");
      if (tSel && ptsCnt) {
        const applyDefaults = () => {
          const typeId = tSel.value;
          const meta = CIA_TASKS.find(x => x.id === typeId);
          if (meta) {
            ptsCnt.value = String(meta.defaultPoints || 1);
            renderTaskPointsVisibility();
          }
        };
        tSel.addEventListener("change", applyDefaults);
        applyDefaults();
      }
      if (ptsCnt) ptsCnt.addEventListener("change", renderTaskPointsVisibility);

      // Render everything
      renderAll();
      updateWakeBadge();

      // Start GPS or sim
      const toggleSim = document.getElementById("toggleSim");
      if (toggleSim) {
        toggleSim.checked = !!STATE.sim.enabled;
      }
      if (STATE.sim.enabled) startSimulation();
      else startGps();

      // Header buttons
      document.getElementById("btnCenter")?.addEventListener("click", centerMap);

      document.getElementById("btnWindHud")?.addEventListener("click", () => {
        STATE.ui.windHudOpen = !STATE.ui.windHudOpen;
        document.getElementById("windHud")?.classList.toggle("hidden", !STATE.ui.windHudOpen);
        renderWindHud();
      });
      document.getElementById("btnWindHudClose")?.addEventListener("click", () => {
        STATE.ui.windHudOpen = false;
        document.getElementById("windHud")?.classList.add("hidden");
      });
      document.getElementById("btnWindLoadOnline")?.addEventListener("click", fetchWindFromOpenMeteo);

      document.getElementById("btnMapSettings")?.addEventListener("click", () => {
        STATE.ui.mapSettingsOpen = true;
        document.getElementById("mapSettings")?.classList.remove("hidden");
      });
      document.getElementById("btnMapSettingsClose")?.addEventListener("click", () => {
        STATE.ui.mapSettingsOpen = false;
        document.getElementById("mapSettings")?.classList.add("hidden");
      });
      document.getElementById("mapSettingsBackdrop")?.addEventListener("click", () => {
        STATE.ui.mapSettingsOpen = false;
        document.getElementById("mapSettings")?.classList.add("hidden");
      });

      document.getElementById("btnBaseOSM")?.addEventListener("click", () => setBaseLayer("OSM"));
      document.getElementById("btnBaseSAT")?.addEventListener("click", () => setBaseLayer("SAT"));

      document.getElementById("toggleTrack")?.addEventListener("change", (e) => {
        STATE.ui.trackVisible = !!e.target.checked;
        if (!STATE.ui.trackVisible) {
          try { STATE.layers.trackLine.setLatLngs([]); } catch {}
        } else {
          try {
            const latlngs = STATE.flight.track.map(p => [p.lat, p.lon]);
            STATE.layers.trackLine.setLatLngs(latlngs);
          } catch {}
        }
        persistAll();
      });

      document.getElementById("toggleTraj")?.addEventListener("change", (e) => {
        STATE.ui.trajVisible = !!e.target.checked;
        rebuildTrajectory();
        persistAll();
      });

      document.getElementById("btnRebuildOverlays")?.addEventListener("click", rebuildOverlays);

      // Menu open/close
      const openMenu = () => {
        STATE.ui.menuOpen = true;
        document.getElementById("menuOverlay")?.classList.remove("hidden");
      };
      const closeMenu = () => {
        STATE.ui.menuOpen = false;
        document.getElementById("menuOverlay")?.classList.add("hidden");
      };

      document.getElementById("btnMenu")?.addEventListener("click", openMenu);
      document.getElementById("btnMenuClose")?.addEventListener("click", closeMenu);
      document.getElementById("menuBackdrop")?.addEventListener("click", closeMenu);

      // Tabs
      document.querySelectorAll(".tabBtn").forEach(btn => {
        btn.addEventListener("click", () => {
          const tab = btn.getAttribute("data-tab");
          if (!tab) return;
          STATE.ui.activeTab = tab;

          document.querySelectorAll(".tabPanel").forEach(p => p.classList.add("hidden"));
          document.getElementById(`tab-${tab}`)?.classList.remove("hidden");

          // small UX: refresh lists
          if (tab === "wind") renderWindList();
          if (tab === "task") renderTaskList();
          if (tab === "archive") renderArchive();
          if (tab === "setup") renderKmlLayersList();
        });
      });

      // Task controls
      document.getElementById("btnTaskDeactivate")?.addEventListener("click", deactivateTask);

      document.getElementById("btnUseCurrentPos")?.addEventListener("click", () => {
        const pos = getCurrentPosition();
        if (!pos) { showSnackbar("Keine aktuelle Position."); return; }
        const latA = document.getElementById("taskLatA");
        const lonA = document.getElementById("taskLonA");
        if (latA) latA.value = pos.lat.toFixed(6);
        if (lonA) lonA.value = pos.lon.toFixed(6);
        showSnackbar("Aktuelle Position übernommen.");
      });

      document.getElementById("btnCreateTask")?.addEventListener("click", () => {
        const typeId = document.getElementById("taskType")?.value || "15.2";
        const meta = CIA_TASKS.find(x => x.id === typeId) || CIA_TASKS[0];

        const title = (document.getElementById("taskTitle")?.value || "").trim();
        const markerColor = document.getElementById("taskMarkerColor")?.value || "fuchsia";

        const pointsCount = Number(document.getElementById("taskPointsCount")?.value || meta.defaultPoints || 1);

        const latA = toNumOrNull(document.getElementById("taskLatA")?.value);
        const lonA = toNumOrNull(document.getElementById("taskLonA")?.value);
        const latB = toNumOrNull(document.getElementById("taskLatB")?.value);
        const lonB = toNumOrNull(document.getElementById("taskLonB")?.value);
        const latC = toNumOrNull(document.getElementById("taskLatC")?.value);
        const lonC = toNumOrNull(document.getElementById("taskLonC")?.value);

        if (!isFiniteNum(latA) || !isFiniteNum(lonA)) {
          showSnackbar("Bitte Lat/Lon (A) setzen.");
          return;
        }

        const points = [{ label:"A", lat: latA, lon: lonA }];
        if (pointsCount >= 2) {
          if (!isFiniteNum(latB) || !isFiniteNum(lonB)) { showSnackbar("Bitte Lat/Lon (B) setzen."); return; }
          points.push({ label:"B", lat: latB, lon: lonB });
        }
        if (pointsCount >= 3) {
          if (!isFiniteNum(latC) || !isFiniteNum(lonC)) { showSnackbar("Bitte Lat/Lon (C) setzen."); return; }
          points.push({ label:"C", lat: latC, lon: lonC });
        }

        const r1 = toNumOrNull(document.getElementById("taskR1")?.value) || 0;
        const r2 = toNumOrNull(document.getElementById("taskR2")?.value) || 0;
        const ang = toNumOrNull(document.getElementById("taskAngle")?.value) || 0;
        const altMin = toNumOrNull(document.getElementById("taskAltMin")?.value) || 0;
        const altMax = toNumOrNull(document.getElementById("taskAltMax")?.value);
        const altMaxSafe = isFiniteNum(altMax) ? altMax : 9999;

        const t = {
          id: genId("task"),
          typeId: meta.id,
          typeCode: meta.code,
          typeTitle: meta.title,
          kind: meta.kind,
          title: title || `${meta.code}`,
          points,
          r1M: Math.max(0, r1),
          r2M: Math.max(0, r2),
          angleDeg: normDeg(ang),
          altMinM: Math.max(0, altMin),
          altMaxM: Math.max(0, altMaxSafe),
          markerColor,
          createdTs: Date.now()
        };

        STATE.tasks.list.push(t);
        persistAll();
        renderTaskList();
        rebuildTaskOverlays();
        zoomToTask(t.id);
        showSnackbar("Task angelegt.");

        // auto activate newly created
        setActiveTask(t.id);
      });

      // Wind controls
      document.getElementById("btnWindAdd")?.addEventListener("click", () => {
        const alt = toNumOrNull(document.getElementById("windAlt")?.value);
        const dir = toNumOrNull(document.getElementById("windDirFrom")?.value);
        const spd = toNumOrNull(document.getElementById("windSpd")?.value);
        if (!isFiniteNum(alt) || !isFiniteNum(dir) || !isFiniteNum(spd)) {
          showSnackbar("Wind: Bitte Höhe/Richtung/Speed eingeben.");
          return;
        }
        addWindEntry({ altM: alt, dirFromDeg: dir, speedKmh: spd, source: "manuell" });
        showSnackbar("Wind-Eintrag hinzugefügt.");
      });

      document.getElementById("btnWindFetchOnline2")?.addEventListener("click", fetchWindFromOpenMeteo);
      document.getElementById("btnWindShowHud")?.addEventListener("click", () => {
        STATE.ui.windHudOpen = true;
        document.getElementById("windHud")?.classList.remove("hidden");
        renderWindHud();
      });

      document.getElementById("btnWindClear")?.addEventListener("click", () => {
        STATE.wind.entries = [];
        persistAll();
        renderWindList();
        renderWindHud();
        rebuildTrajectory();
        showSnackbar("Windprofil geleert.");
      });

      // Setup controls
      document.getElementById("btnWakeLock")?.addEventListener("click", toggleWakeLock);

      document.getElementById("btnSetupSave")?.addEventListener("click", () => {
        const u = document.getElementById("unitSpeed")?.value || "kmh";
        const traj = document.getElementById("trajMinutes")?.value || "5,10,15";
        const gpsI = toNumOrNull(document.getElementById("gpsMinInterval")?.value);
        const minD = toNumOrNull(document.getElementById("trackMinDist")?.value);

        STATE.setup.unitSpeed = u;
        STATE.setup.trajMinutes = traj.split(",").map(x => Number(x)).filter(Number.isFinite);
        STATE.setup.gpsMinInterval = isFiniteNum(gpsI) ? clamp(gpsI, 200, 5000) : STATE.setup.gpsMinInterval;
        STATE.setup.trackMinDist = isFiniteNum(minD) ? clamp(minD, 1, 100) : STATE.setup.trackMinDist;

        persistAll();
        rebuildTrajectory();
        showSnackbar("Setup gespeichert.");
      });

      document.getElementById("toggleSim")?.addEventListener("change", (e) => {
        const on = !!e.target.checked;
        if (on) startSimulation();
        else stopSimulation();
        persistAll();
      });

      // KML import
      document.getElementById("kmlFile")?.addEventListener("change", (e) => {
        const file = e.target.files?.[0];
        if (file) importKmlFile(file);
        e.target.value = "";
      });

      // Archive controls
      document.getElementById("btnArchiveClear")?.addEventListener("click", () => {
        STATE.archive = [];
        persistAll();
        renderArchive();
        showSnackbar("Archiv geleert.");
      });

      // Finish flight
      document.getElementById("btnFinish")?.addEventListener("click", finishFlight);

      // Marker button
      document.getElementById("btnMarker")?.addEventListener("click", dropMarker);

      // Sim controls - hold to set vertical rate
      const btnBurner = document.getElementById("btnBurner");
      const btnVent = document.getElementById("btnVent");

      const bindHold = (el, rate) => {
        if (!el) return;
        const down = (ev) => { ev.preventDefault(); if (STATE.sim.enabled) setSimVerticalRate(rate); };
        const up = (ev) => { ev.preventDefault(); if (STATE.sim.enabled) setSimVerticalRate(0); };
        el.addEventListener("pointerdown", down);
        el.addEventListener("pointerup", up);
        el.addEventListener("pointercancel", up);
        el.addEventListener("pointerleave", up);
      };
      bindHold(btnBurner, +2.0);
      bindHold(btnVent, -2.0);

      // Keep wake lock on visibility changes (best effort)
      document.addEventListener("visibilitychange", async () => {
        if (document.visibilityState === "visible" && STATE.wake.lock) {
          try {
            // Some browsers release wake lock when hidden; re-request
            STATE.wake.lock = await navigator.wakeLock.request("screen");
            updateWakeBadge();
          } catch {}
        }
      });

      // initial nav/strategy render
      updateNavAndStrategy();
      rebuildTrajectory();
    };
  </script>
</body>
</html>
